<?xml version="1.0"?>
<rss version="2.0" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Planet SymPy</title>
    <link>http://planet.sympy.org/</link>
    <language>en</language>
    <description>Planet SymPy - http://planet.sympy.org/</description>
    <atom:link href="http://planet.sympy.org/rss10.xml" rel="self" type="application/rss+xml"/>
    <item>
      <guid isPermaLink="false">https://smit-create.github.io/Smit-create.github.io/2020/08/16/week_12</guid>
      <author>Smit Lunagariya (Smit-create)</author>
      <title>Smit Lunagariya (Smit-create): Week 12-GSoC 2020</title>
      <pubDate>Sun, 16 Aug 2020 00:00:00 GMT</pubDate>
      <link>https://smit-create.github.io/Smit-create.github.io/2020/08/16/week_12.html</link>
      <description>&lt;p&gt;This is the final blog of the official program highlighting the final week. Some of the key discussions were:</description>
    </item>
    <item>
      <guid isPermaLink="false">https://namannimmo10.github.io/emerald//week_9,10</guid>
      <author>Naman Gera (namannimmo10)</author>
      <title>Naman Gera (namannimmo10): Week 9 &amp; 10 - GSoC 2020</title>
      <pubDate>Tue, 11 Aug 2020 00:00:00 GMT</pubDate>
      <link>https://namannimmo10.github.io/emerald//week_9,10</link>
      <description>&lt;p&gt;This blog post describes my progress in Weeks 9 and 10 of Google Summer of Code 2020.&lt;/p&gt; &lt;p&gt;I ended up week 8 by making changes in the &lt;code class="language-plaintext highlighter-rouge"&gt;Parallel&lt;/code&gt; class to make support for MIMO transfer function interconnection.&lt;/p&gt; &lt;h1 id="week-9"&gt;Week 9&lt;/h1&gt; &lt;p&gt;I decided to do the similar thing for...</description>
    </item>
    <item>
      <guid isPermaLink="false">https://smit-create.github.io/Smit-create.github.io/2020/08/09/week_11</guid>
      <author>Smit Lunagariya (Smit-create)</author>
      <title>Smit Lunagariya (Smit-create): Week 11-GSoC 2020</title>
      <pubDate>Sun, 09 Aug 2020 00:00:00 GMT</pubDate>
      <link>https://smit-create.github.io/Smit-create.github.io/2020/08/09/week_11.html</link>
      <description>&lt;p&gt;This blog describes the 11th week of the program. Some of the key highlights of this week are:</description>
    </item>
    <item>
      <guid isPermaLink="false">https://smit-create.github.io/Smit-create.github.io/2020/08/02/week_10</guid>
      <author>Smit Lunagariya (Smit-create)</author>
      <title>Smit Lunagariya (Smit-create): Week 10-GSoC 2020</title>
      <pubDate>Sun, 02 Aug 2020 00:00:00 GMT</pubDate>
      <link>https://smit-create.github.io/Smit-create.github.io/2020/08/02/week_10.html</link>
      <description>&lt;p&gt;This blogs describes the 10th week of the program. Some of the highlights of this week are:</description>
    </item>
    <item>
      <guid isPermaLink="false">https://smit-create.github.io/Smit-create.github.io/2020/07/26/week_9</guid>
      <author>Smit Lunagariya (Smit-create)</author>
      <title>Smit Lunagariya (Smit-create): Week 9-GSoC 2020</title>
      <pubDate>Sun, 26 Jul 2020 00:00:00 GMT</pubDate>
      <link>https://smit-create.github.io/Smit-create.github.io/2020/07/26/week_9.html</link>
      <description>&lt;p&gt;This blogs describes the week 9, the beginning week of the final phase. This week, I continued to work on the extension of Compound Distributions as well as completing the Matrix Distributions. Some of the highlights of this week are:</description>
    </item>
    <item>
      <guid isPermaLink="false">https://namannimmo10.github.io/emerald//week_8</guid>
      <author>Naman Gera (namannimmo10)</author>
      <title>Naman Gera (namannimmo10): Week 8 - GSoC 2020</title>
      <pubDate>Tue, 21 Jul 2020 00:00:00 GMT</pubDate>
      <link>https://namannimmo10.github.io/emerald//week_8</link>
      <description>&lt;p&gt;This blog post describes my progress in week 8, the last week of Phase 2. Since we already have a SISO transfer function object available for block diagram algebra, so now, I thought of adding a MIMO transfer function object in this control systems engineering package. The way it works...</description>
    </item>
    <item>
      <guid isPermaLink="false">https://smit-create.github.io/Smit-create.github.io/2020/07/19/week_8</guid>
      <author>Smit Lunagariya (Smit-create)</author>
      <title>Smit Lunagariya (Smit-create): Week 8-GSoC 2020</title>
      <pubDate>Sun, 19 Jul 2020 00:00:00 GMT</pubDate>
      <link>https://smit-create.github.io/Smit-create.github.io/2020/07/19/week_8.html</link>
      <description>&lt;p&gt;This blog provides the brief description of last week of the second Phase i.e. week 8. Some of the key highlights of this week are:</description>
    </item>
    <item>
      <guid isPermaLink="false">https://namannimmo10.github.io/emerald//week_6,7</guid>
      <author>Naman Gera (namannimmo10)</author>
      <title>Naman Gera (namannimmo10): Week 6 &amp; 7 - GSoC 2020</title>
      <pubDate>Tue, 14 Jul 2020 00:00:00 GMT</pubDate>
      <link>https://namannimmo10.github.io/emerald//week_6,7</link>
      <description>&lt;p&gt;Hi everyone :) Long time no see.&lt;/p&gt; &lt;p&gt;First of all, &lt;em&gt;GOOD NEWS&lt;/em&gt;: My &lt;a href="https://github.com/sympy/sympy/pull/19390"&gt;PR&lt;/a&gt; on adding a SISO transfer function object is finally merged. Yay!! A robust transfer function object is now available for Single Input Single Output (SISO) block diagram algebra.. Here is the &lt;a href="https://docs.sympy.org/dev/modules/physics/control/lti.html"&gt;documentation&lt;/a&gt;.&lt;/p&gt; &lt;p&gt;&lt;img src="/emerald/img/woohoo.png"...</description>
    </item>
    <item>
      <guid isPermaLink="false">https://sachin-4099.github.io//GSoC-2020-Week-8</guid>
      <author>Sachin Agarwal (sachin-4099)</author>
      <title>Sachin Agarwal (sachin-4099): GSoC 2020 - Week 8</title>
      <pubDate>Sun, 12 Jul 2020 00:00:00 GMT</pubDate>
      <link>https://sachin-4099.github.io//GSoC-2020-Week-8</link>
      <description>&lt;p&gt;Key &lt;code class="language-plaintext highlighter-rouge"&gt;highlights&lt;/code&gt; of this week&amp;#8217;s work are:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;&lt;a href="https://github.com/sympy/sympy/pull/19716"&gt;Fixed incorrect limit evaluation related to LambertW function&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;This was a minor bug fix. We added the &lt;code class="language-plaintext highlighter-rouge"&gt;_singularities&lt;/code&gt; feature to the &lt;code class="language-plaintext highlighter-rouge"&gt;LambertW&lt;/code&gt; function so that its limit gets evaluated using the &lt;code class="language-plaintext highlighter-rouge"&gt;meromorphic check&lt;/code&gt; already present in the limit codebase.
&lt;br /&gt;&lt;br /&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;&lt;a href="https://github.com/sympy/sympy/pull/18696"&gt;Fixed errors in assumptions when rewriting RisingFactorial / FallingFactorial as gamma or factorial&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt;
    &lt;ul&gt;
      &lt;li&gt;This was a long pending issue. The rewrite to &lt;code class="language-plaintext highlighter-rouge"&gt;gamma&lt;/code&gt; or &lt;code class="language-plaintext highlighter-rouge"&gt;factorial&lt;/code&gt; methods of &lt;code class="language-plaintext highlighter-rouge"&gt;RisingFactorial&lt;/code&gt; and &lt;code class="language-plaintext highlighter-rouge"&gt;FallingFactorial&lt;/code&gt; did not handle all the possible cases, which caused errors in some evaluations.
Thus, we decided to come up with a proper rewrite using &lt;code class="language-plaintext highlighter-rouge"&gt;Piecewise&lt;/code&gt; which accordingly returned the correct rewrite depending on the assumptions on the variables.
Handling such rewrites using &lt;code class="language-plaintext highlighter-rouge"&gt;Piecewise&lt;/code&gt; is never easy, and thus there were a lot of failing testcases.
After spending a lot of time debugging and fixing each failing testcase, we were finally able to merge this.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;This marks the end of &lt;code class="language-plaintext highlighter-rouge"&gt;Phase-2&lt;/code&gt; of the program. I learnt a lot during these two months and gained many important things from my mentors.&lt;/p&gt;</description>
    </item>
    <item>
      <guid isPermaLink="false">https://smit-create.github.io/Smit-create.github.io/2020/07/12/week_7</guid>
      <author>Smit Lunagariya (Smit-create)</author>
      <title>Smit Lunagariya (Smit-create): Week 7-GSoC 2020</title>
      <pubDate>Sun, 12 Jul 2020 00:00:00 GMT</pubDate>
      <link>https://smit-create.github.io/Smit-create.github.io/2020/07/12/week_7.html</link>
      <description>&lt;p&gt;This blog describes the 7th week of the program and the 3rd week of Phase 2. Some of the key highlights on the discussions and the implementations during this week are:</description>
    </item>
    <item>
      <guid isPermaLink="false">https://sachin-4099.github.io//GSoC-2020-Week-7</guid>
      <author>Sachin Agarwal (sachin-4099)</author>
      <title>Sachin Agarwal (sachin-4099): GSoC 2020 - Week 7</title>
      <pubDate>Sun, 05 Jul 2020 00:00:00 GMT</pubDate>
      <link>https://sachin-4099.github.io//GSoC-2020-Week-7</link>
      <description>&lt;p&gt;Key &lt;code class="language-plaintext highlighter-rouge"&gt;highlights&lt;/code&gt; of this week&amp;#8217;s work are:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;&lt;a href="https://github.com/sympy/sympy/pull/19680"&gt;Improved the limit evaluations of Power objects&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;
        &lt;p&gt;This PR improves the limit evaluations of Power objects.
We first check if the limit expression is a &lt;code class="language-plaintext highlighter-rouge"&gt;Power object&lt;/code&gt; and then accordingly evaluate the limit depending on different cases.
First of all, we express &lt;code class="language-plaintext highlighter-rouge"&gt;b**e&lt;/code&gt; in the form of &lt;code class="language-plaintext highlighter-rouge"&gt;exp(e*log(b))&lt;/code&gt;. After this, we check if &lt;code class="language-plaintext highlighter-rouge"&gt;e*log(b)&lt;/code&gt; is &lt;code class="language-plaintext highlighter-rouge"&gt;meromorphic&lt;/code&gt; and accordingly evaluate the final result.
This check helps us to handle the trivial cases in the beginning itself.&lt;/p&gt;

        &lt;p&gt;Now, if &lt;code class="language-plaintext highlighter-rouge"&gt;e*log(b)&lt;/code&gt; is not meromorphic, then we separately evaluate the limit of the base and the exponent.
This helps us to determine the &lt;code class="language-plaintext highlighter-rouge"&gt;indeterminant form&lt;/code&gt; of the limit expression if present. 
As we know, there are 3 indeterminate forms corresponding to power objects: &lt;code class="language-plaintext highlighter-rouge"&gt;0**0&lt;/code&gt;, &lt;code class="language-plaintext highlighter-rouge"&gt;oo**0&lt;/code&gt;, and &lt;code class="language-plaintext highlighter-rouge"&gt;1**oo&lt;/code&gt;, which need to be handled carefully.
If there is no indeterminate form present, then no further evaluations are required. Otherwise, we handle all the three cases separately and correctly evaluate the final result.&lt;/p&gt;

        &lt;p&gt;We also added some code to improve the evaluation of limits having &lt;code class="language-plaintext highlighter-rouge"&gt;Abs()&lt;/code&gt; expressions.
For every &lt;code class="language-plaintext highlighter-rouge"&gt;Abs()&lt;/code&gt; term present in the limit expression, we replace it simply by its argument or the negative of its argument, depending on
whether the value of the limit of the argument is greater than zero or less than zero for the given limit variable.&lt;/p&gt;

        &lt;p&gt;Finally, we were able to merge this after resolving some failing testcases.
&lt;br /&gt;&lt;br /&gt;&lt;/p&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;&lt;a href="https://github.com/sympy/sympy/pull/19697"&gt;Fixed limit evaluations involving error functions&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt;
    &lt;ul&gt;
      &lt;li&gt;
        &lt;p&gt;The incorrect limit evaluations of &lt;code class="language-plaintext highlighter-rouge"&gt;error functions&lt;/code&gt; were mainly because the &lt;code class="language-plaintext highlighter-rouge"&gt;tractable&lt;/code&gt; rewrite was wrong and did not handle all the possible cases.
For a proper rewrite, it was required that the limit variable be passed to the corresponding rewrite method.
This is because, to define a correct rewrite we had to evaluate the limit of the argument of the &lt;code class="language-plaintext highlighter-rouge"&gt;error function&lt;/code&gt;, for the passed limit variable.
Thus, we added a default argument &lt;code class="language-plaintext highlighter-rouge"&gt;limitvar&lt;/code&gt; to all the &lt;code class="language-plaintext highlighter-rouge"&gt;tractable rewrite&lt;/code&gt; methods and resolved this issue.
While debugging, we also noticed that the &lt;code class="language-plaintext highlighter-rouge"&gt;_eval_as_leading_term&lt;/code&gt; method of error function was wrong, hence it was also fixed.&lt;/p&gt;

        &lt;p&gt;Finally, we were able to merge this after resolving some failing testcases.&lt;/p&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;</description>
    </item>
    <item>
      <guid isPermaLink="false">https://smit-create.github.io/Smit-create.github.io/2020/07/05/week_6</guid>
      <author>Smit Lunagariya (Smit-create)</author>
      <title>Smit Lunagariya (Smit-create): Week 6-GSoC 2020</title>
      <pubDate>Sun, 05 Jul 2020 00:00:00 GMT</pubDate>
      <link>https://smit-create.github.io/Smit-create.github.io/2020/07/05/week_6.html</link>
      <description>&lt;p&gt;This blog describes the 6th week of the official program and the 2nd week of Phase 2. By the end of this week, Compound Distributions framework is ready as targeted and I would now focus on the Joint Distributions in the upcoming weeks of this Phase.</description>
    </item>
    <item>
      <guid isPermaLink="false">https://namannimmo10.github.io/emerald//week_5</guid>
      <author>Naman Gera (namannimmo10)</author>
      <title>Naman Gera (namannimmo10): Week 5 - GSoC 2020</title>
      <pubDate>Tue, 30 Jun 2020 00:00:00 GMT</pubDate>
      <link>https://namannimmo10.github.io/emerald//week_5</link>
      <description>&lt;p&gt;This blog post describes my progress in Week 5 of Google Summer of Code 2020!&lt;/p&gt; &lt;p&gt;I ended up Week 4 by adding unit tests and a rough draft for &lt;code class="language-plaintext highlighter-rouge"&gt;Series&lt;/code&gt; and &lt;code class="language-plaintext highlighter-rouge"&gt;Parallel&lt;/code&gt; classes. Now in this week, to complete the implementation, we decided to add another...</description>
    </item>
    <item>
      <guid isPermaLink="false">https://sachin-4099.github.io//GSoC-2020-Week-6</guid>
      <author>Sachin Agarwal (sachin-4099)</author>
      <title>Sachin Agarwal (sachin-4099): GSoC 2020 - Week 6</title>
      <pubDate>Sun, 28 Jun 2020 00:00:00 GMT</pubDate>
      <link>https://sachin-4099.github.io//GSoC-2020-Week-6</link>
      <description>&lt;p&gt;Key &lt;code class="language-plaintext highlighter-rouge"&gt;highlights&lt;/code&gt; of this week&amp;#8217;s work are:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;&lt;a href="https://github.com/sympy/sympy/pull/19646"&gt;Fixed RecursionError and Timeout in limit evaluations&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;
        &lt;p&gt;The &lt;code class="language-plaintext highlighter-rouge"&gt;Recursion Errors&lt;/code&gt; in limit evaluations were mainly due to the fact that the indeterminant form of &lt;code class="language-plaintext highlighter-rouge"&gt;1**oo&lt;/code&gt; was not handled accurately in the &lt;code class="language-plaintext highlighter-rouge"&gt;mrv()&lt;/code&gt; function of the
&lt;code class="language-plaintext highlighter-rouge"&gt;Gruntz algorithm&lt;/code&gt;. So, some minor changes were required to fix those.&lt;/p&gt;

        &lt;p&gt;The major issue was to handle those cases which were timing out. On deep digging, we identified that the 
&lt;code class="language-plaintext highlighter-rouge"&gt;cancel()&lt;/code&gt; function of &lt;code class="language-plaintext highlighter-rouge"&gt;polytools.py&lt;/code&gt; was the reason. Thus, we decided to completely transform the &lt;code class="language-plaintext highlighter-rouge"&gt;cancel()&lt;/code&gt; function to speed up its algorithm. 
Now after this major modification, many testcases were failing as the &lt;code class="language-plaintext highlighter-rouge"&gt;cancel()&lt;/code&gt; function plays an important role in simplifying evaluations and 
is thus used at many places across the codebase. Therefore, a lot of time was spent in debugging and rectifying these testcases.&lt;/p&gt;

        &lt;p&gt;Finally we were able to merge this, enhancing the limit evaluation capabilities of &lt;code class="language-plaintext highlighter-rouge"&gt;SymPy&lt;/code&gt;.&lt;/p&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;</description>
    </item>
    <item>
      <guid isPermaLink="false">https://smit-create.github.io/Smit-create.github.io/2020/06/28/week_5</guid>
      <author>Smit Lunagariya (Smit-create)</author>
      <title>Smit Lunagariya (Smit-create): Week 5-GSoC 2020</title>
      <pubDate>Sun, 28 Jun 2020 00:00:00 GMT</pubDate>
      <link>https://smit-create.github.io/Smit-create.github.io/2020/06/28/week_5.html</link>
      <description>&lt;p&gt;This blogs describes the week 5, the beginning week of the Phase 2. Phase 2 will be mostly focused on Compound Distributions which were stalled from 2018, and additions to Joint Distributions.</description>
    </item>
    <item>
      <guid isPermaLink="false">https://namannimmo10.github.io/emerald//week_4</guid>
      <author>Naman Gera (namannimmo10)</author>
      <title>Naman Gera (namannimmo10): Week 4 - GSoC 2020</title>
      <pubDate>Tue, 23 Jun 2020 00:00:00 GMT</pubDate>
      <link>https://namannimmo10.github.io/emerald//week_4</link>
      <description>&lt;p&gt;With this, the fourth week and phase 1 of GSoC 2020 is over. Here I will give you a brief summary of my progress this week.&lt;/p&gt; &lt;p&gt;The initial days were spent mostly on modifying unit tests for &lt;code class="language-plaintext highlighter-rouge"&gt;Series&lt;/code&gt; and &lt;code class="language-plaintext highlighter-rouge"&gt;Parallel&lt;/code&gt; classes which I added in the...</description>
    </item>
    <item>
      <guid isPermaLink="false">https://sachin-4099.github.io//GSoC-2020-Week-5</guid>
      <author>Sachin Agarwal (sachin-4099)</author>
      <title>Sachin Agarwal (sachin-4099): GSoC 2020 - Week 5</title>
      <pubDate>Sun, 21 Jun 2020 00:00:00 GMT</pubDate>
      <link>https://sachin-4099.github.io//GSoC-2020-Week-5</link>
      <description>&lt;p&gt;Key &lt;code class="language-plaintext highlighter-rouge"&gt;highlights&lt;/code&gt; of this week&amp;#8217;s work are:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;&lt;a href="https://github.com/sympy/sympy/pull/19555"&gt;Adds cdir parameter to handle series expansions on branch cuts&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;
        &lt;p&gt;Finally, after spending almost 2 weeks on this, we were able to merge the PR, adding a very important functionality of &lt;code class="language-plaintext highlighter-rouge"&gt;series expansions&lt;/code&gt; on the &lt;code class="language-plaintext highlighter-rouge"&gt;branch cuts&lt;/code&gt; to the codebase. 
Previously, either &lt;code class="language-plaintext highlighter-rouge"&gt;SymPy&lt;/code&gt; raised some error or the series expansion was computed incorrectly, when the value in the input was on the branch cut. But now, for most of the functions, the expansion produced is correct.&lt;/p&gt;

        &lt;p&gt;Not only this, we added the &lt;code class="language-plaintext highlighter-rouge"&gt;cdir&lt;/code&gt; parameter to &lt;code class="language-plaintext highlighter-rouge"&gt;leadterm&lt;/code&gt; and &lt;code class="language-plaintext highlighter-rouge"&gt;as_leading_term&lt;/code&gt; functions as well. We even extended the functionality a bit to the &lt;code class="language-plaintext highlighter-rouge"&gt;limits&lt;/code&gt; module, so now, 
&lt;code class="language-plaintext highlighter-rouge"&gt;limits&lt;/code&gt; of values lying on the branch cuts of a function are also computed correctly in most cases.&lt;/p&gt;

        &lt;p&gt;We are planning to extend this functionality to all the remaining &lt;code class="language-plaintext highlighter-rouge"&gt;special functions&lt;/code&gt; and wherever else possible to make the codebase even more &lt;code class="language-plaintext highlighter-rouge"&gt;robust&lt;/code&gt;.&lt;/p&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;</description>
    </item>
    <item>
      <guid isPermaLink="false">https://smit-create.github.io/Smit-create.github.io/2020/06/21/phase_1</guid>
      <author>Smit Lunagariya (Smit-create)</author>
      <title>Smit Lunagariya (Smit-create): Phase-1-Highlights</title>
      <pubDate>Sun, 21 Jun 2020 00:00:00 GMT</pubDate>
      <link>https://smit-create.github.io/Smit-create.github.io/2020/06/21/phase_1.html</link>
      <description>&lt;p&gt;With this blog it completes the awesome month of statistical learning and coding, and the official Phase 1 of the Google Summer of Code-2020.</description>
    </item>
    <item>
      <guid isPermaLink="false">https://namannimmo10.github.io/emerald//week_3</guid>
      <author>Naman Gera (namannimmo10)</author>
      <title>Naman Gera (namannimmo10): Week 3 - GSoC 2020</title>
      <pubDate>Tue, 16 Jun 2020 00:00:00 GMT</pubDate>
      <link>https://namannimmo10.github.io/emerald//week_3</link>
      <description>&lt;p&gt;In the starting days of Week 3, I made further changes in the class level docstrings for &lt;code class="language-plaintext highlighter-rouge"&gt;TransferFunction&lt;/code&gt; after Jason and Nikhil reviewed the PR. Jason also mentioned that I had to add a new page in sympy docs which should include the purpose of adding a control...</description>
    </item>
    <item>
      <guid isPermaLink="false">https://sachin-4099.github.io//GSoC-2020-Week-4</guid>
      <author>Sachin Agarwal (sachin-4099)</author>
      <title>Sachin Agarwal (sachin-4099): GSoC 2020 - Week 4</title>
      <pubDate>Sun, 14 Jun 2020 00:00:00 GMT</pubDate>
      <link>https://sachin-4099.github.io//GSoC-2020-Week-4</link>
      <description>&lt;p&gt;Key &lt;code class="language-plaintext highlighter-rouge"&gt;highlights&lt;/code&gt; of this week&amp;#8217;s work are:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;&lt;a href="https://github.com/sympy/sympy/pull/19515"&gt;Fixed incorrect evaluation caused due to subfactorial in limit_seq expression&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;This was a minor bug fix. 
The functionality of rewriting the &lt;code class="language-plaintext highlighter-rouge"&gt;subfactorial&lt;/code&gt; term present in an expression into an equivalent term expressed in 
the form of &lt;code class="language-plaintext highlighter-rouge"&gt;factorial&lt;/code&gt; or &lt;code class="language-plaintext highlighter-rouge"&gt;gamma&lt;/code&gt; was added which helped resolve the issue.
&lt;br /&gt;&lt;br /&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;&lt;a href="https://github.com/sympy/sympy/pull/19555"&gt;Adds cdir parameter to handle series expansions on branch cuts&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt;
    &lt;ul&gt;
      &lt;li&gt;
        &lt;p&gt;Currently, many functions in the codebase are unable to produce correct &lt;code class="language-plaintext highlighter-rouge"&gt;series expansions&lt;/code&gt; on &lt;code class="language-plaintext highlighter-rouge"&gt;branch cuts&lt;/code&gt;. As a result,
the limit evaluation takes place incorrectly for these functions when the limiting value lies on the branch cuts.&lt;/p&gt;

        &lt;p&gt;Thus, we have decided to come up with a parameter named &lt;code class="language-plaintext highlighter-rouge"&gt;cdir&lt;/code&gt; which stands for &lt;code class="language-plaintext highlighter-rouge"&gt;complex direction&lt;/code&gt; and it indicates the direction from which the series expansion is required, thus helping us
to produce the correct series expansion. Special care needs to be taken while handling series expansions on the &lt;code class="language-plaintext highlighter-rouge"&gt;branch points&lt;/code&gt;.&lt;/p&gt;

        &lt;p&gt;Once we are finished with this work, it will be a &lt;code class="language-plaintext highlighter-rouge"&gt;major enhancement&lt;/code&gt; to the limit evaluation and series expansion capabilities of &lt;code class="language-plaintext highlighter-rouge"&gt;SymPy&lt;/code&gt;.&lt;/p&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;This marks the end of &lt;code class="language-plaintext highlighter-rouge"&gt;Phase-1&lt;/code&gt; of the program. I learnt a lot during this one month and gained many important things from my mentors.&lt;/p&gt;</description>
    </item>
    <item>
      <guid isPermaLink="false">https://smit-create.github.io/Smit-create.github.io/2020/06/14/week_4</guid>
      <author>Smit Lunagariya (Smit-create)</author>
      <title>Smit Lunagariya (Smit-create): Week 4-GSoC 2020</title>
      <pubDate>Sun, 14 Jun 2020 00:00:00 GMT</pubDate>
      <link>https://smit-create.github.io/Smit-create.github.io/2020/06/14/week_4.html</link>
      <description>&lt;p&gt;This blog provides the brief description of the last week i.e week 4 of the Phase 1. Some of the key highlights on the discussions and the implementation during this week are described below:</description>
    </item>
    <item>
      <guid isPermaLink="false">https://namannimmo10.github.io/emerald//week_2</guid>
      <author>Naman Gera (namannimmo10)</author>
      <title>Naman Gera (namannimmo10): Week 2 - GSoC 2020</title>
      <pubDate>Tue, 09 Jun 2020 00:00:00 GMT</pubDate>
      <link>https://namannimmo10.github.io/emerald//week_2</link>
      <description>&lt;p&gt;Week 2 of the coding period is now over. It was a week full of learning and a lot of challenges. I had my first meeting with Nikhil and Ishan on June 4, between 5:00 - 6:00 p.m. where we discussed a few things regarding the implementation part for this...</description>
    </item>
    <item>
      <guid isPermaLink="false">https://sachin-4099.github.io//GSoC-2020-Week-3</guid>
      <author>Sachin Agarwal (sachin-4099)</author>
      <title>Sachin Agarwal (sachin-4099): GSoC 2020 - Week 3</title>
      <pubDate>Sun, 07 Jun 2020 00:00:00 GMT</pubDate>
      <link>https://sachin-4099.github.io//GSoC-2020-Week-3</link>
      <description>&lt;p&gt;Key &lt;code class="language-plaintext highlighter-rouge"&gt;highlights&lt;/code&gt; of this week&amp;#8217;s work are:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;&lt;a href="https://github.com/sympy/sympy/pull/19508"&gt;Fixed _eval_nseries() of Power&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;
        &lt;p&gt;This was a long pending issue. 
Previously, in the codebase the &lt;code class="language-plaintext highlighter-rouge"&gt;series expansion of b**e&lt;/code&gt; was computed by breaking the code into different cases, depending on the 
values of the exponent or if the exponent has a symbol etc. Moreover, there was code to handle specific cases, and 
it was not written in a general way. As a result, the code was very long and it was difficult to debug it when some issue popped up.&lt;/p&gt;

        &lt;p&gt;Hence, it was very important to completely rewrite and clean-up &lt;code class="language-plaintext highlighter-rouge"&gt;Pow._eval_nseries()&lt;/code&gt;, so that many issues get resolved and 
it becomes easy to debug any further issues related to series expansions or limit evaluations.&lt;/p&gt;

        &lt;p&gt;Thus, we came up with a &lt;code class="language-plaintext highlighter-rouge"&gt;general algorithm&lt;/code&gt; covering all the cases.&lt;/p&gt;

        &lt;p&gt;The series expansion of &lt;code class="language-plaintext highlighter-rouge"&gt;b**e&lt;/code&gt; is computed as follows:&lt;/p&gt;

        &lt;ul&gt;
          &lt;li&gt;We express &lt;code class="language-plaintext highlighter-rouge"&gt;b&lt;/code&gt; as &lt;code class="language-plaintext highlighter-rouge"&gt;f*(1 + g)&lt;/code&gt; where &lt;code class="language-plaintext highlighter-rouge"&gt;f&lt;/code&gt; is the leading term of &lt;code class="language-plaintext highlighter-rouge"&gt;b&lt;/code&gt;. &lt;code class="language-plaintext highlighter-rouge"&gt;g&lt;/code&gt; has order &lt;code class="language-plaintext highlighter-rouge"&gt;O(x**d)&lt;/code&gt; where &lt;code class="language-plaintext highlighter-rouge"&gt;d&lt;/code&gt; is strictly positive.&lt;/li&gt;
          &lt;li&gt;Then &lt;code class="language-plaintext highlighter-rouge"&gt;b**e&lt;/code&gt; = &lt;code class="language-plaintext highlighter-rouge"&gt;(f**e)*((1 + g)**e)&lt;/code&gt;where, &lt;code class="language-plaintext highlighter-rouge"&gt;(1 + g)**e&lt;/code&gt; is computed using the concept of &lt;code class="language-plaintext highlighter-rouge"&gt;binomial series&lt;/code&gt;.&lt;/li&gt;
        &lt;/ul&gt;

        &lt;p&gt;The major challenge which we had to face was the fragile nature of the existing code of &lt;code class="language-plaintext highlighter-rouge"&gt;Pow._eval_nseries()&lt;/code&gt;. 
Changing the code even a bit resulted in many test failures, as this function plays an important role in both series expansions and limit evaluations.&lt;/p&gt;

        &lt;p&gt;At times, it became extremely difficult to debug the cause of failures because there were several other functions as well on which the code of this function depended. 
Not only this, fixing one failure caused several others to pop-up.&lt;/p&gt;

        &lt;p&gt;Ultimately, after a week of hard-work, we got everything working.
After which, we further optimised the code ensuring that we are not compromising with efficiency.
At last, this issue was resolved and we ended up adding an extremely optimised implementation of the function to the codebase.&lt;/p&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;</description>
    </item>
    <item>
      <guid isPermaLink="false">https://namannimmo10.github.io/emerald//week_1</guid>
      <author>Naman Gera (namannimmo10)</author>
      <title>Naman Gera (namannimmo10): Week 1 - GSoC 2020</title>
      <pubDate>Tue, 02 Jun 2020 00:00:00 GMT</pubDate>
      <link>https://namannimmo10.github.io/emerald//week_1</link>
      <description>&lt;p&gt;This specific blog describes the first official week of the coding period. I actually started coding from May 21 by opening &lt;a href="https://github.com/sympy/sympy/pull/19390"&gt;#19390&lt;/a&gt;. I decided to start off the coding period by adding &lt;code class="language-plaintext highlighter-rouge"&gt;TransferFunction&lt;/code&gt; class&amp;#8230; which was basically a class for representing the LTI (Linear, time-invariant) systems in...</description>
    </item>
    <item>
      <guid isPermaLink="false">https://namannimmo10.github.io/emerald//community_period</guid>
      <author>Naman Gera (namannimmo10)</author>
      <title>Naman Gera (namannimmo10): GSoC 2020 - Community Bonding Period</title>
      <pubDate>Sun, 31 May 2020 00:00:00 GMT</pubDate>
      <link>https://namannimmo10.github.io/emerald//community_period</link>
      <description>&lt;p&gt;On May 4, I got an email from Google that my proposal with &lt;a href="https://github.com/sympy/sympy"&gt;SymPy&lt;/a&gt; has been accepted! Seriously, that was the best day of my life. I have learned a lot from this open source community from the past 6 months, and I hope to continue that.&lt;/p&gt; &lt;p&gt;The community...</description>
    </item>
    <item>
      <guid isPermaLink="false">https://sachin-4099.github.io//GSoC-2020-Week-2</guid>
      <author>Sachin Agarwal (sachin-4099)</author>
      <title>Sachin Agarwal (sachin-4099): GSoC 2020 - Week 2</title>
      <pubDate>Sun, 31 May 2020 00:00:00 GMT</pubDate>
      <link>https://sachin-4099.github.io//GSoC-2020-Week-2</link>
      <description>&lt;p&gt;Key &lt;code class="language-plaintext highlighter-rouge"&gt;highlights&lt;/code&gt; of this week&amp;#8217;s work are:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;&lt;a href="https://github.com/sympy/sympy/pull/19369"&gt;Fixed _eval_nseries() of Mul&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;
        &lt;p&gt;This was a long pending issue. 
Previously, in the codebase the &lt;code class="language-plaintext highlighter-rouge"&gt;series expansion of a product&lt;/code&gt; was computed as the &lt;code class="language-plaintext highlighter-rouge"&gt;product of expansions of the factors&lt;/code&gt;. 
This approach was correct only when the &lt;code class="language-plaintext highlighter-rouge"&gt;leading term of each series&lt;/code&gt; is a &lt;code class="language-plaintext highlighter-rouge"&gt;constant&lt;/code&gt; but not in general.&lt;/p&gt;

        &lt;p&gt;For example, to compute the expansion of &lt;code class="language-plaintext highlighter-rouge"&gt;f(x)/x**10&lt;/code&gt; at &lt;code class="language-plaintext highlighter-rouge"&gt;x = 0&lt;/code&gt; to order &lt;code class="language-plaintext highlighter-rouge"&gt;O(x**10)&lt;/code&gt; it is necessary to compute the series expansion 
of the function &lt;code class="language-plaintext highlighter-rouge"&gt;f(x)&lt;/code&gt; to order &lt;code class="language-plaintext highlighter-rouge"&gt;O(x**20)&lt;/code&gt; and thus, computing till order &lt;code class="language-plaintext highlighter-rouge"&gt;O(x**10)&lt;/code&gt; would not suffice.&lt;/p&gt;

        &lt;p&gt;The strategy we implemented to resolve this issue was:&lt;/p&gt;

        &lt;ul&gt;
          &lt;li&gt;Compute the order &lt;code class="language-plaintext highlighter-rouge"&gt;n0&lt;/code&gt; of the &lt;code class="language-plaintext highlighter-rouge"&gt;leading term of the product&lt;/code&gt; as the &lt;code class="language-plaintext highlighter-rouge"&gt;sum of the orders&lt;/code&gt; of the &lt;code class="language-plaintext highlighter-rouge"&gt;leading terms of the factors&lt;/code&gt;.&lt;/li&gt;
          &lt;li&gt;For each factor, compute &lt;code class="language-plaintext highlighter-rouge"&gt;n - n0&lt;/code&gt; terms of its series expansion (starting from its &lt;code class="language-plaintext highlighter-rouge"&gt;leading term of order n1&lt;/code&gt; and &lt;code class="language-plaintext highlighter-rouge"&gt;ending at order n - n0 + n1&lt;/code&gt;).&lt;/li&gt;
          &lt;li&gt;Multiply the expansions (&lt;code class="language-plaintext highlighter-rouge"&gt;truncating at terms of order n&lt;/code&gt;).&lt;/li&gt;
        &lt;/ul&gt;

        &lt;p&gt;I enjoyed implementing all this because at every step we had to ensure that we are not compromising with the efficiency of the code. 
Finally, this issue was resolved and we ended up adding an extremely optimised implementation of the function to the codebase.
&lt;br /&gt;&lt;br /&gt;&lt;/p&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;&lt;a href="https://github.com/sympy/sympy/pull/19432"&gt;Used is_meromorphic() function to speed up limit evaluations&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;
        &lt;p&gt;In this PR, we made use of the &lt;code class="language-plaintext highlighter-rouge"&gt;is_meromorphic()&lt;/code&gt; function of SymPy to speed up limit evaluations for certain type of cases.&lt;/p&gt;

        &lt;p&gt;A function is said to be &lt;code class="language-plaintext highlighter-rouge"&gt;meromorphic&lt;/code&gt; at a point, if at that point the &lt;code class="language-plaintext highlighter-rouge"&gt;limit of the function exists but is infinite&lt;/code&gt;. 
In these cases, the value of the limit can usually be determined with the help of the &lt;code class="language-plaintext highlighter-rouge"&gt;series expansion of that function&lt;/code&gt; and 
thus, there is no need to invoke the &lt;code class="language-plaintext highlighter-rouge"&gt;Gruntz algorithm&lt;/code&gt;.&lt;/p&gt;

        &lt;p&gt;While working on the implementation of this functionality, we required the &lt;code class="language-plaintext highlighter-rouge"&gt;leading term&lt;/code&gt; of the &lt;code class="language-plaintext highlighter-rouge"&gt;series expansion of the function in the limit expression at the point at which the limit needs to be evaluated&lt;/code&gt;.&lt;/p&gt;

        &lt;p&gt;But we came across a weird situation, where for some functions, we got &lt;code class="language-plaintext highlighter-rouge"&gt;Complex Infinity&lt;/code&gt; as the &lt;code class="language-plaintext highlighter-rouge"&gt;leading term&lt;/code&gt;.
Thus, we had to rectify the &lt;code class="language-plaintext highlighter-rouge"&gt;_eval_as_leading_term()&lt;/code&gt; methods of these functions (done in a separate &lt;strong&gt;&lt;a href="https://github.com/sympy/sympy/pull/19461"&gt;PR&lt;/a&gt;&lt;/strong&gt;).&lt;/p&gt;

        &lt;p&gt;After resolving this issue, we succeeded in adding the required functionality and hence, increased the efficiency of the limit evaluation algorithm of SymPy.&lt;/p&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;</description>
    </item>
    <item>
      <guid isPermaLink="false">https://sachin-4099.github.io//GSoC-2020-Week-1</guid>
      <author>Sachin Agarwal (sachin-4099)</author>
      <title>Sachin Agarwal (sachin-4099): GSoC 2020 - Week 1</title>
      <pubDate>Sun, 24 May 2020 00:00:00 GMT</pubDate>
      <link>https://sachin-4099.github.io//GSoC-2020-Week-1</link>
      <description>&lt;p&gt;Key &lt;code class="language-plaintext highlighter-rouge"&gt;highlights&lt;/code&gt; of this week&amp;#8217;s work are:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;&lt;a href="https://github.com/sympy/sympy/pull/19292"&gt;Fixed incorrect limit evaluations caused due to different assumptions of the limit variable&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;In this issue, due to different assumptions of the limit variable, the output was coming out to be different and incorrect for the same limit expression.
On digging deep into this issue, we observed that the assumption &lt;code class="language-plaintext highlighter-rouge"&gt;integer = True&lt;/code&gt; was common between all the incorrectly evaluated limit expressions.
Thus, we concluded that the &lt;code class="language-plaintext highlighter-rouge"&gt;Gruntz algorithm&lt;/code&gt; is not able to correctly evaluate those expressions where the limit variable possesses &lt;code class="language-plaintext highlighter-rouge"&gt;integer = True&lt;/code&gt; property.
So, in order to get all the correct mathematical behaviour from the expression, we decided to define a dummy variable lacking &lt;code class="language-plaintext highlighter-rouge"&gt;integer = True&lt;/code&gt; property. 
After which, we simply had to substitute the limit variable with this dummy variable for these type of limit expressions to resolve the issue.
&lt;br /&gt;&lt;br /&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;&lt;a href="https://github.com/sympy/sympy/pull/19297"&gt;Fixed incorrect limit evaluations caused due to bug in rewriting&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;At first, this issue seemed tough to resolve because we were unable to find the source of the error. But then, we decided to examine each expression which is generated during evaluation.
This helped us to observe that &lt;code class="language-plaintext highlighter-rouge"&gt;rewriting&lt;/code&gt; of the expression was taking place incorrectly and we shifted our focus towards the &lt;code class="language-plaintext highlighter-rouge"&gt;rewrite()&lt;/code&gt; function.
Afterwards, it was pretty evident that the &lt;code class="language-plaintext highlighter-rouge"&gt;xreplace()&lt;/code&gt; function utilised for rewriting is not sufficient, as it did not find everything that needs to replaced.
Thus, replacing the &lt;code class="language-plaintext highlighter-rouge"&gt;xreplace()&lt;/code&gt; function with the &lt;code class="language-plaintext highlighter-rouge"&gt;subs()&lt;/code&gt; function helped us to resolve this issue.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;</description>
    </item>
    <item>
      <guid isPermaLink="false">https://sachin-4099.github.io//GSoC-2020-Community-Bonding-Period</guid>
      <author>Sachin Agarwal (sachin-4099)</author>
      <title>Sachin Agarwal (sachin-4099): GSoC 2020 - Community Bonding Period</title>
      <pubDate>Sun, 17 May 2020 00:00:00 GMT</pubDate>
      <link>https://sachin-4099.github.io//GSoC-2020-Community-Bonding-Period</link>
      <description>&lt;p&gt;The first part of my GSoC journey was the Community Bonding Period.&lt;/p&gt;

&lt;p&gt;In this period, I mainly focussed on the following things:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Setting up my blog, where I will provide weekly reports on the progress of my project, and synchronizing it with Planet SymPy.&lt;/li&gt;
  &lt;li&gt;Setting up a public gitter channel for discussions regarding the project.&lt;/li&gt;
  &lt;li&gt;Prioritising the issues to be solved.&lt;/li&gt;
  &lt;li&gt;Deciding the finer details of the workflow with my mentors and working out efficient ways to solve each particular issue.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Since I have been contributing to SymPy for the past 8-9 months, it was easier for me to blend into the community.&lt;/p&gt;

&lt;p&gt;Now, as everything has gone as planned, I have decided to make a head start and begin with the implementation of my project.&lt;/p&gt;</description>
    </item>
    <item>
      <guid isPermaLink="false">https://sachin-4099.github.io//GSoC-2020-with-sympy</guid>
      <author>Sachin Agarwal (sachin-4099)</author>
      <title>Sachin Agarwal (sachin-4099): GSoC 2020 Acceptance</title>
      <pubDate>Thu, 07 May 2020 00:00:00 GMT</pubDate>
      <link>https://sachin-4099.github.io//GSoC-2020-with-sympy</link>
      <description>&lt;p&gt;&lt;img src="https://sachin-4099.github.io/public/gsoc.png" style="width: 30%; height: 30%; float: left;" /&gt;
&lt;img src="https://sachin-4099.github.io/public/sympy.png" style="width: 25%; height: 25%; float: right; margin-right: 100px;" /&gt;&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;br /&gt;&lt;br /&gt;&lt;br /&gt;&lt;br /&gt;&lt;br /&gt;&lt;br /&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;The results of &lt;strong&gt;&lt;a href="https://summerofcode.withgoogle.com/organizations/4831132022996992/#5816442299088896"&gt;Google Summer of Code&lt;/a&gt;&lt;/strong&gt; were out on 04 May 2020 and I am pleased to share with you that my proposal with &lt;strong&gt;&lt;a href="http://sympy.org"&gt;SymPy&lt;/a&gt;&lt;/strong&gt; was accepted.&lt;/p&gt;

&lt;p&gt;I would like to thank all the members of the organisation especially &lt;a href="https://github.com/jksuom"&gt;Kalevi Suominen&lt;/a&gt; for guiding me in my proposal and PR&amp;#8217;s. I am really excited to work for such an amazing organization.&lt;/p&gt;

&lt;p&gt;I will be working on my project, &lt;a href="https://drive.google.com/file/d/1OgbnWLzQzaLfmmSM-fK09TCJmUzJ6tq4/view?usp=sharing"&gt;Amendments to Limit Evaluation and Series Expansion&lt;/a&gt;, during a period of 3 months spanning from June to August, under the mentorship of &lt;a href="https://github.com/jksuom"&gt;Kalevi Suominen&lt;/a&gt; and &lt;a href="https://github.com/leosartaj"&gt;Sartaj Singh&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;My primary focus will be to work on the &lt;code class="language-plaintext highlighter-rouge"&gt;series&lt;/code&gt; module and make it more robust as it is the backbone of all the limit evaluations performed by the library.&lt;/p&gt;

&lt;p&gt;Looking forward for a really productive and wonderful summer ahead.&lt;/p&gt;</description>
    </item>
    <item>
      <guid isPermaLink="false">https://asmeurer.com/blog/posts/verifying-the-riemann-hypothesis-with-sympy-and-mpmath/</guid>
      <author>Aaron Meurer (asmeurer)</author>
      <title>Aaron Meurer (asmeurer): Verifying the Riemann Hypothesis with SymPy and mpmath</title>
      <pubDate>Tue, 31 Mar 2020 21:12:54 GMT</pubDate>
      <link>https://asmeurer.com/blog/posts/verifying-the-riemann-hypothesis-with-sympy-and-mpmath/</link>
      <description>&lt;div&gt;&lt;p&gt;Like most people, I've had a lot of free time recently, and I've spent some of
it watching various YouTube videos about the &lt;a href="https://en.wikipedia.org/wiki/Riemann_hypothesis"&gt;Riemann
Hypothesis&lt;/a&gt;. I've collected
the videos I've watched into &lt;a href="https://www.youtube.com/playlist?list=PLrFrByaoJbcqKjzgJvLs2-spSmzP7jolT"&gt;YouTube
playlist&lt;/a&gt;.
The playlist is sorted with the most mathematically approachable videos first,
so even if you haven't studied complex analysis before, you can watch the
first few. If you have studied complex analysis, all the videos will be within
your reach (none of them are highly technical with proofs). Each video
contains parts that aren't in any of the other videos, so you will get
something out of watching each of them.&lt;/p&gt;
&lt;p&gt;One of the &lt;a href="https://www.youtube.com/watch?v=lyf9W2PWm40&amp;amp;list=PLrFrByaoJbcqKjzgJvLs2-spSmzP7jolT&amp;amp;index=8"&gt;videos near the end of the
playlist&lt;/a&gt;
is a lecture by Keith Conrad. In it, he mentioned a method by which one could
go about verifying the Riemann Hypothesis with a computer. I wanted to see if
I could do this with SymPy and mpmath. It turns out you can.&lt;/p&gt;
&lt;h2&gt;Background Mathematics&lt;/h2&gt;
&lt;h3&gt;Euler's Product Formula&lt;/h3&gt;
&lt;p&gt;Before we get to the computations, let's go over some mathematical background.
As you may know, the Riemann Hypothesis is one of the 7 &lt;a href="https://en.wikipedia.org/wiki/Millennium_Prize_Problems"&gt;Millennium Prize
Problems&lt;/a&gt; outlined by
the Clay Mathematics Institute in 2000. The problems have gained some fame
because each problem comes with a $1,000,000 prize if solved. One problem, the
&lt;a href="https://en.wikipedia.org/wiki/Poincar%C3%A9_conjecture"&gt;Poincar&amp;#233; conjecture&lt;/a&gt;,
has already been solved (Grigori Perelman who solved it turned down the 1
million dollar prize). The remainder remain unsolved.&lt;/p&gt;
&lt;p&gt;The Riemann Hypothesis is one of the most famous of these problems. The reason
for this is that the problem is central many open questions in number theory.
There are hundreds of theorems which are only known to be true contingent on
the Riemann Hypothesis, meaning that if the Riemann Hypothesis were proven,
immediately hundreds of theorems would be proven as well. Also, unlike some
other Millennium Prize problems, like P=NP, the Riemann Hypothesis is almost
universally believed to be true by mathematicians. So it's not a question of
whether or not it is true, just one of how to actually prove it. The problem
has been open for over 160 years, and while many advances have been made, no
one has yet come up with a proof of it (crackpot proofs aside).&lt;/p&gt;
&lt;p&gt;To understand the statement of the hypothesis, we must first define the zeta
function. Let&lt;/p&gt;
&lt;p&gt;$$\zeta(s) = \sum_{n=1}^\infty \frac{1}{n^s}$$&lt;/p&gt;
&lt;p&gt;(that squiggle $\zeta$ is the lowercase Greek letter zeta). This expression
makes sense if $s$ is an integer greater than or equal to 2, $s=2, 3, 4, \ldots$,
since we know from simple arguments from calculus that the summation converges
in those cases (it isn't important for us what those values are, only that the
summation converges). The story begins with Euler, who in 1740 considered the
following infinite product:&lt;/p&gt;
&lt;p&gt;$$\prod_{\text{$p$ prime}}\frac{1}{1 -
\frac{1}{p^s}}.$$&lt;/p&gt;
&lt;p&gt;The product ranges over all prime numbers, i.e., it is
$$\left(\frac{1}{1 - \frac{1}{2^s}}\right)\cdot\left(\frac{1}{1 -
\frac{1}{3^s}}\right)\cdot\left(\frac{1}{1 - \frac{1}{5^s}}\right)\cdots.$$
The fraction $\frac{1}{1 - \frac{1}{p}}$ may seem odd at first, but consider
the famous geometric series formula, $$\sum_{k=0}^\infty r^k = \frac{1}{1 -
r},$$ which is true for $|r| &amp;lt; 1$. Our fraction is exactly of this form, with
$r = \frac{1}{p^s}$. So substituting, we have&lt;/p&gt;
&lt;p&gt;$$\prod_{\text{$p$ prime}}\frac{1}{1 - \frac{1}{p^s}} =
\prod_{\text{$p$ prime}}\sum_{k=0}^\infty \left(\frac{1}{p^s}\right)^k =
\prod_{\text{$p$ prime}}\sum_{k=0}^\infty \left(\frac{1}{p^k}\right)^s.$$&lt;/p&gt;
&lt;p&gt;Let's take a closer look at what this is. It is&lt;/p&gt;
&lt;p&gt;$$\left(1 + \frac{1}{p_1^s} + \frac{1}{p_1^{2s}} + \frac{1}{p_1^{3s}} +
\cdots\right)\cdot\left(1 + \frac{1}{p_2^s} + \frac{1}{p_2^{2s}} +
\frac{1}{p_2^{3s}} + \cdots\right)\cdot\left(1 + \frac{1}{p_3^s} + \frac{1}{p_3^{2s}} +
\frac{1}{p_3^{3s}} + \cdots\right)\cdots,$$&lt;/p&gt;
&lt;p&gt;where $p_1$ is the first prime, $p_2$ is the second prime, and so on. Now
think about how to expand finite products of finite sums, for instance,
$$(x_1 + x_2 + x_3)(y_1 + y_2 + y_3)(z_1 + z_2 + z_3).$$ To expand the above,
you would take a sum of every combination where you pick one $x$ term, one $y$
term, and one $z$ term, giving&lt;/p&gt;
&lt;p&gt;$$x_1y_1z_1 + x_1y_1z_2 + \cdots + x_2y_1z_3 + \cdots + x_3y_2z_1 + \cdots + x_3y_3z_3.$$&lt;/p&gt;
&lt;p&gt;So to expand the infinite product, we do the same thing. We take every
combination of picking $1/p_i^{ks}$, with one $k$ for each $i$. If we pick
infinitely many non-$1$ powers, the product will be zero, so we only need to
consider terms where there are finitely many primes. The resulting sum will be
something like&lt;/p&gt;
&lt;p&gt;$$\frac{1}{1^s} + \frac{1}{p_1^s} + \frac{1}{p_2^s} + \frac{1}{\left(p_1^2\right)^s} +
\frac{1}{p_3^s} + \frac{1}{\left(p_1p_2\right)^s} + \cdots,$$&lt;/p&gt;
&lt;p&gt;where each prime power combination is picked exactly once. However, we know by
the &lt;a href="https://en.wikipedia.org/wiki/Fundamental_theorem_of_arithmetic"&gt;Fundamental Theorem of
Arithmetic&lt;/a&gt;
that when you take all combinations of products of primes that you get each
positive integer exactly once. So the above sum is just&lt;/p&gt;
&lt;p&gt;$$\frac{1}{1^s} + \frac{1}{2^s} + \frac{1}{3^s} + \cdots,$$ which is just
$\zeta(s)$ as we defined it above.&lt;/p&gt;
&lt;p&gt;In other words,&lt;/p&gt;
&lt;p&gt;$$\zeta(s) = \sum_{n=1}^\infty \frac{1}{n^s} = \prod_{\text{$p$
prime}}\frac{1}{1 - \frac{1}{p^s}},$$ for $s = 2, 3, 4, \ldots$. This is known
as Euler's product formula for the zeta function. Euler's product formula
gives us our first clue as to why the zeta function can give us insights into
prime numbers.&lt;/p&gt;
&lt;h3&gt;Analytic Continuation&lt;/h3&gt;
&lt;p&gt;In 1859, Bernhard Riemann wrote a &lt;a href="https://en.wikipedia.org/wiki/On_the_Number_of_Primes_Less_Than_a_Given_Magnitude"&gt;short 9 page paper on number theory and the
zeta
function&lt;/a&gt;.
It was the only paper Riemann ever wrote on the subject of number theory, but
it is undoubtedly one of the most important papers every written on the
subject.&lt;/p&gt;
&lt;p&gt;In the paper, Riemann considered that the zeta function summation,&lt;/p&gt;
&lt;p&gt;$$\zeta(s) = \sum_{n=1}^\infty \frac{1}{n^s},$$&lt;/p&gt;
&lt;p&gt;makes sense not just for integers $s = 2, 3, 4, \ldots$, but for any real
number $s &amp;gt; 1$ (if $s = 1$, the summation is the &lt;a href="https://en.wikipedia.org/wiki/Harmonic_series_(mathematics)"&gt;harmonic
series&lt;/a&gt;, which
famously diverges). In fact, it is not hard to see that for complex $s$, the
summation makes sense so long as $\mathrm{Re}(s) &amp;gt; 1$ (for more about what it
even means for $s$ to be complex in that formula, and the basic ideas of
analytic continuation, I recommend &lt;a href="https://www.youtube.com/watch?v=sD0NjbwqlYw&amp;amp;list=PLrFrByaoJbcqKjzgJvLs2-spSmzP7jolT&amp;amp;index=3"&gt;3Blue1Brown's
video&lt;/a&gt;
from my YouTube playlist).&lt;/p&gt;
&lt;p&gt;Riemann wanted to extend this function to the entire complex plane, not just
$\mathrm{Re}(s) &amp;gt; 1$. The process of doing this is called &lt;a href="https://en.wikipedia.org/wiki/Analytic_continuation"&gt;analytic
continuation&lt;/a&gt;. The theory
of complex analysis tells us that if we can find an extension of $\zeta(s)$ to
the whole complex plan that remains differentiable, then that extension is
unique, and we can reasonably say that that &lt;em&gt;is&lt;/em&gt; the definition of the
function everywhere.&lt;/p&gt;
&lt;p&gt;Riemann used the following approach. Consider what we might call the
"completed zeta function"&lt;/p&gt;
&lt;p&gt;$$Z(s) = \pi^{-\frac{s}{2}}\Gamma\left(\frac{s}{2}\right)\zeta(s).$$&lt;/p&gt;
&lt;p&gt;Using Fourier analysis, Riemann gave a formula for $Z(s)$ that is defined
everywhere, allowing us to use it to define $\zeta(s)$ to the left of 1. I
won't repeat Riemann's formula for $Z(s)$ as the exact formula isn't
important, but from it one could also see&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;$Z(s)$ is defined everywhere in the complex plane, except for simple poles at 0
and 1.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;$Z(s) = Z(1 - s).$ This means if we have a value for $s$ that is right of
the line $\mathrm{Re}(z) = \frac{1}{2},$ we can get a value to the left of
it by reflecting it over the real-axis and the line at $\frac{1}{2}$ (to
see this, note that the average of $s$ and $1 - s$ is $1/2$, so the
midpoint of a line connecting the two should always go through the point
$1/2$).&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;img alt="Reflection of s and 1 - s" src="https://asmeurer.com/blog/s-and-1-s.svg" width="608" /&gt;
&lt;p&gt;(Reflection of $s$ and $1 - s$. Created with
&lt;a href="https://www.geogebra.org/graphing/c9rzy9hj"&gt;Geogebra&lt;/a&gt;)&lt;/p&gt;
&lt;h3&gt;Zeros&lt;/h3&gt;
&lt;p&gt;Looking at $Z(s)$, it is a product of three parts. So the zeros and poles of
$Z(s)$ correspond to the zeros and poles of these parts, unless they cancel.
$\pi^{-\frac{s}{2}}$ is the easiest: it has no zeros and no poles. The second
part is the &lt;a href="https://en.wikipedia.org/wiki/Gamma_function"&gt;gamma function&lt;/a&gt;.
$\Gamma(z)$ has no zeros and has simple poles at nonpositive integers $z=0,
-1, -2, \ldots$.&lt;/p&gt;
&lt;p&gt;So taking this, along with the fact that $Z(s)$ is entire except for simple
poles at 0 and 1, we get from $$\zeta(s) =
\frac{Z(s)}{\pi^{-\frac{s}{2}}\Gamma\left(\frac{s}{2}\right)}$$&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;$Z(s)$ has a simple pole at 1, which means that $\zeta(s)$ does as well.
This is not surprising, since we already know the summation formula from
above diverges as $s$ approaches 1.&lt;/li&gt;
&lt;li&gt;$Z(s)$ has a simple pole at 0. Since $\Gamma\left(\frac{s}{2}\right)$ also
has a simple pole at 0, they must cancel and $\zeta(s)$ must have neither a
zero nor a pole at 0 (in fact, $\zeta(0) = -1/2$).&lt;/li&gt;
&lt;li&gt;Since $\Gamma\left(\frac{s}{2}\right)$ has no zeros, there are no further
poles of $\zeta(s)$. Thus, $\zeta(s)$ is entire everywhere except for a
simple pole at $s=1$.&lt;/li&gt;
&lt;li&gt;$\Gamma\left(\frac{s}{2}\right)$ has poles at the remaining negative even
integers. Since $Z(s)$ has no poles there, these must correspond to zeros
of $\zeta(s)$. These are the so-called "trivial" zeros of the zeta
function, at $s=-2, -4, -6, \ldots$. The term "trivial" here is a relative
one. They are trivial to see from the above formula, whereas other zeros of
$\zeta(s)$ are much harder to find.&lt;/li&gt;
&lt;li&gt;$\zeta(s) \neq 0$ if $\mathrm{Re}(s) &amp;gt; 1$. One way to see this is from the
Euler product formula. Since each term in the product is not zero, the
function itself cannot be zero (this is a bit hand-wavy, but it can be made
rigorous). This implies that $Z(s) \neq 0$ in this region as well. We can
reflect $\mathrm{Re}(s) &amp;gt; 1$ over the line at $\frac{1}{2}$ by considering
$\zeta(1 - s)$. Using the above formula and the fact that $Z(s) = Z(1 -
s)$, we see that $\zeta(s)$ cannot be zero for $\mathrm{Re}(s) &amp;lt; 0$ either,
with the exception of the aforementioned trivial zeros at $s=-2, -4, -6,
\ldots$.&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;Thus, any non-trivial zeros of $\zeta(s)$ must have real part between 0 and 1.
This is the so-called "critical strip". Riemann hypothesized that these zeros
are not only between 0 and 1, but are in fact on the line dividing the strip
at real part equal to $1/2$. This line is called the "critical line". This is
Riemann's famous hypothesis: that all the non-trivial zeros of $\zeta(s)$ have
real part equal to $1/2$.&lt;/p&gt;
&lt;h3&gt;Computational Verification&lt;/h3&gt;
&lt;p&gt;Whenever you have a mathematical hypothesis, it is good to check if it is true
numerically. Riemann himself used some methods (not the same ones we use here)
to numerically estimate the first few non-trivial zeros of $\zeta(s)$, and
found that they lied on the critical line, hence the motivation for his
hypothesis. Here is an &lt;a href="https://www.maths.tcd.ie/pub/HistMath/People/Riemann/Zeta/EZeta.pdf"&gt;English
translation&lt;/a&gt;
of his original paper if you are interested.&lt;/p&gt;
&lt;p&gt;If we verified that all the zeros in the critical strip from, say,
$\mathrm{Im}(s) = 0$ to $\mathrm{Im}(s) = N$ are in fact on the critical line
for some large $N$, then it would give evidence that the Riemann Hypothesis is
true. However, to be sure, this would not constitute a proof.
&lt;a href="https://en.wikipedia.org/wiki/G._H._Hardy"&gt;Hardy&lt;/a&gt; showed in 1914 that
$\zeta(s)$ has infinitely many zeros on the critical strip, so only finding
finitely many of them would not suffice as a proof. (Although if we were to
find a counter-example, a zero &lt;em&gt;not&lt;/em&gt; on the critical line, that WOULD
constitute a proof that the Hypothesis is false. However, there are strong
reasons to believe that the hypothesis is not false, so this would be unlikely
to happen.)&lt;/p&gt;
&lt;p&gt;How would we verify that the zeros are all on the line $1/2$. We can find
zeros of $\zeta(s)$ numerically, but how would we know if the real part is
really exactly 0.5 and not 0.500000000000000000000000000000000001? And more
importantly, just because we find some zeros, it doesn't mean that we have all
of them. Maybe we can find a bunch of zeros on the critical line, but how
would we be sure that there aren't other zeros lurking around elsewhere on the
critical strip?&lt;/p&gt;
&lt;p&gt;We want to find rigorous answers to these two questions:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;How can we count the number of zeros between $\mathrm{Im}(s) = 0$ and
$\mathrm{Im}(s) = N$ of $\zeta(s)$?&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;How can we verify that all those zeros lie on the critical line, that is,
they have real part equal to exactly $1/2$?&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h4&gt;Counting Zeros Part 1&lt;/h4&gt;
&lt;p&gt;To answer the first question, we can make use of a powerful theorem from
complex analysis called the &lt;a href="https://en.wikipedia.org/wiki/Argument_principle#Generalized_argument_principle"&gt;argument
principle&lt;/a&gt;.
The argument principle says that if $f$ is a meromorphic function on some
closed contour $C$, and does not have any zeros or poles on $C$ itself, then&lt;/p&gt;
&lt;p&gt;$$\frac{1}{2\pi i}\oint_C \frac{f'(z)}{f(z)}\,dz = \#\left\{\text{zeros of $f$
inside of C}\right\} - \#\left\{\text{poles of $f$
inside of C}\right\},$$ where all zeros and poles are counted with
multiplicity.&lt;/p&gt;
&lt;p&gt;In other words, the integral on the left-hand side counts the number of zeros
of $f$ minus the number of poles of $f$ in a region. The argument principle is
quite easy to show given the Cauchy residue theorem (see the above linked
Wikipedia article for a proof). The expression $f'(z)/f(z)$ is called the
"&lt;a href="https://en.wikipedia.org/wiki/Logarithmic_derivative"&gt;logarithmic
derivative&lt;/a&gt; of $f$",
because it equals $\frac{d}{dz} \log(f(z))$ (although it makes sense even without
defining what "$\log$" means).&lt;/p&gt;
&lt;p&gt;One should take a moment to appreciate the beauty of this result. The
left-hand side is an integral, something we generally think of as being a
continuous quantity. But it is always exactly equal to an integer. Results
such as these give us a further glimpse at how analytic functions and complex
analysis can produce theorems about number theory, a field which one would
naively think can only be studied via discrete means. In fact, these methods
are far more powerful than discrete methods. For many results in number
theory, we only know how to prove them using complex analytic means. So-called
&lt;a href="https://en.wikipedia.org/wiki/Elementary_proof"&gt;"elementary" proofs&lt;/a&gt; for
these results, or proofs that only use discrete methods and do not use complex
analysis, have not yet been found.&lt;/p&gt;
&lt;p&gt;Practically speaking, the fact that the above integral is exactly an integer
means that if we compute it numerically and it comes out to something like
0.9999999, we know that it must in fact equal exactly 1. So as long as we get
a result that is near an integer, we can round it to the exact answer.&lt;/p&gt;
&lt;p&gt;We can integrate a contour along the critical strip up to some $\mathrm{Im}(s)
= N$ to count the number of zeros up to $N$ (we have to make sure to account
for the poles. I go into more details about this when I actually compute the
integral below).&lt;/p&gt;
&lt;h4&gt;Counting Zeros Part 2&lt;/h4&gt;
&lt;p&gt;So using the argument principle, we can count the number of zeros in a region.
Now how can we verify that they all lie on the critical line? The answer lies
in the $Z(s)$ function defined above. By the points outlined in the previous
section, we can see that $Z(s)$ is zero exactly where $\zeta(s)$ is zero on
the critical strip, and it is not zero anywhere else. In other words,&lt;/p&gt;
&lt;div style="text-align: center;"&gt; &lt;b&gt;the zeros of $Z(s)$ are exactly the non-trivial zeros of $\zeta(s)$.&lt;/b&gt;&lt;/div&gt;
&lt;p&gt;This helps us because $Z(s)$ has a nice property on the critical line. First
we note that $Z(s)$ commutes with conjugation, that is $\overline{Z(s)} =
Z(\overline{s})$ (this isn't obvious from what I have shown, but it is true).
On the critical line $\frac{1}{2} + it$, we have&lt;/p&gt;
&lt;p&gt;$$\overline{Z\left(\frac{1}{2} + it\right)} = Z\left(\overline{\frac{1}{2} +
it}\right) = Z\left(\frac{1}{2} - it\right).$$&lt;/p&gt;
&lt;p&gt;However, $Z(s) = Z(1 - s)$, and $1 - \left(\frac{1}{2} - it\right) =
\frac{1}{2} + it$, so&lt;/p&gt;
&lt;p&gt;$$\overline{Z\left(\frac{1}{2} + it\right)} = Z\left(\frac{1}{2} +
it\right),$$&lt;/p&gt;
&lt;p&gt;which means that $Z\left(\frac{1}{2} + it\right)$ is real valued for real $t$.&lt;/p&gt;
&lt;p&gt;This simplifies things a lot, because it is much easier to find zeros of a real
function. In fact, we don't even care about finding the zeros, only counting
them. Since $Z(s)$ is continuous, we can use a simple method: counting sign
changes. If a continuous real function changes signs from negative to positive or from
positive to negative n times in an interval, then it must have at least n
zeros in that interval. It may have more, for instance, if some zeros are
clustered close together, or if a zero has a multiplicity greater than 1, but
we know that there must be at least n.&lt;/p&gt;
&lt;p&gt;So our approach to verifying the Riemann Hypothesis is as such:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;Integrate $\frac{1}{2\pi i}\oint_C Z'(s)/Z(s)\,ds$ along a contour $C$
that runs along the critical strip up to some $\mathrm{Im}(s) = N$. The
integral will tell us there are exactly $n$ zeros in the contour, counting
multiplicity.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Try to find $n$ sign changes of $Z(1/2 + it)$ for $t\in [0, N]$. If we can
find $n$ of them, we are done. We have confirmed all the zeros are on the
critical line.&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;Step 2 would fail if the Riemann Hypothesis is false, in which case a zero
wouldn't be on the critical line. But it would also fail if a zero has a
multiplicity greater than 1, since the integral would count it more times than
the sign changes. Fortunately, as it turns out, the Riemann Hypothesis has
been verified up to N = 10000000000000, and no one has yet found a zero of the
zeta function yet that has a multiplicity greater than 1, so we should not
expect that to happen (no one has yet found a counterexample to the Riemann
Hypothesis either).&lt;/p&gt;
&lt;h2&gt;Verification with SymPy and mpmath&lt;/h2&gt;
&lt;p&gt;We now use SymPy and mpmath to compute the above quantities. We use
&lt;a href="https://www.sympy.org/"&gt;SymPy&lt;/a&gt; to do symbolic manipulation for us, but the
heavy work is done by &lt;a href="http://mpmath.org/doc/current/index.html"&gt;mpmath&lt;/a&gt;.
mpmath is a pure Python library for arbitrary precision numerics. It is used
by SymPy under the hood, but it will be easier for us to use it directly. It
can do, among other things, numeric integration. When I first tried to do
this, I tried using the &lt;a href="https://docs.scipy.org/doc/scipy/reference/generated/scipy.special.zeta.html"&gt;&lt;code&gt;scipy.special&lt;/code&gt; zeta
function&lt;/a&gt;,
but unfortunately, it does not support complex arguments.&lt;/p&gt;
&lt;p&gt;First we do some basic imports&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-py"&gt;&amp;gt;&amp;gt;&amp;gt; from sympy import *
&amp;gt;&amp;gt;&amp;gt; import mpmath
&amp;gt;&amp;gt;&amp;gt; import numpy as np
&amp;gt;&amp;gt;&amp;gt; import matplotlib.pyplot as plt
&amp;gt;&amp;gt;&amp;gt; s = symbols('s')
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Define the completed zeta function $Z = \pi^{-s/2}\Gamma(s/2)\zeta(s)$.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; Z = pi**(-s/2)*gamma(s/2)*zeta(s)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;We can verify that Z is indeed real for $s = \frac{1}{2} + it.$&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-py"&gt;&amp;gt;&amp;gt;&amp;gt; Z.subs(s, 1/2 + 0.5j).evalf()
-1.97702795164031 + 5.49690501450151e-17*I
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;We get a small imaginary part due to the way floating point arithmetic works.
Since it is below &lt;code&gt;1e-15&lt;/code&gt;, we can safely ignore it.&lt;/p&gt;
&lt;p&gt;&lt;code&gt;D&lt;/code&gt; will be the logarithmic derivative of &lt;code&gt;Z&lt;/code&gt;.&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-py"&gt;&amp;gt;&amp;gt;&amp;gt; D = simplify(Z.diff(s)/Z)
&amp;gt;&amp;gt;&amp;gt; D
polygamma(0, s/2)/2 - log(pi)/2 + Derivative(zeta(s), s)/zeta(s)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;This is $$\frac{\operatorname{polygamma}{\left(0,\frac{s}{2} \right)}}{2} -
\frac{\log{\left(\pi \right)}}{2} + \frac{
\zeta'\left(s\right)}{\zeta\left(s\right)}.$$&lt;/p&gt;
&lt;p&gt;Note that logarithmic derivatives behave similar to logarithms. The
logarithmic derivative of a product is the sum of logarithmic derivatives (the
$\operatorname{polygamma}$ function is the derivative of $\Gamma$).&lt;/p&gt;
&lt;p&gt;We now use
&lt;a href="https://docs.sympy.org/latest/modules/utilities/lambdify.html#sympy.utilities.lambdify.lambdify"&gt;&lt;code&gt;lambdify&lt;/code&gt;&lt;/a&gt;
to convert the SymPy expressions &lt;code&gt;Z&lt;/code&gt; and &lt;code&gt;D&lt;/code&gt; into functions that are evaluated
using mpmath. A technical difficulty here is that the derivative of the zeta
function $\zeta'(s)$ does not have a closed-form expression. &lt;a href="http://mpmath.org/doc/current/functions/zeta.html?highlight=zeta#mpmath.zeta"&gt;mpmath's &lt;code&gt;zeta&lt;/code&gt;
can evaluate
$\zeta'$&lt;/a&gt;
but it doesn't yet work with &lt;code&gt;sympy.lambdify&lt;/code&gt; (see &lt;a href="https://github.com/sympy/sympy/issues/11802"&gt;SymPy issue
11802&lt;/a&gt;). So we have to manually
define &lt;code&gt;"Derivative"&lt;/code&gt; in lambdify, knowing that it will be the derivative of
&lt;code&gt;zeta&lt;/code&gt; when it is called. Beware that this is only correct for this specific
expression where we know that &lt;code&gt;Derivative&lt;/code&gt; will be &lt;code&gt;Derivative(zeta(s), s)&lt;/code&gt;.&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-py"&gt;&amp;gt;&amp;gt;&amp;gt; Z_func = lambdify(s, Z, 'mpmath')
&amp;gt;&amp;gt;&amp;gt; D_func = lambdify(s, D, modules=['mpmath',
...     {'Derivative': lambda expr, z: mpmath.zeta(z, derivative=1)}])
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Now define a function to use the argument principle to count the number of
zeros up to $Ni$. Due to the symmetry $Z(s) = Z(1 - s)$, it is only necessary
to count zeros in the top half-plane.&lt;/p&gt;
&lt;p&gt;We have to be careful about the poles of $Z(s)$ at 0 and 1. We can either
integrate right above them, or expand the contour to include them. I chose to
do the former, starting at $0.1i$. It is known that there $\zeta(s)$ has no
zeros near the real axis on the critical strip. I could have also expanded the
contour to go around 0 and 1, and offset the result by 2 to account for the
integral counting those points as poles.&lt;/p&gt;
&lt;p&gt;It has also been shown that there are no zeros on the lines $\mathrm{Re}(s) =
0$ or $\mathrm{Re}(s) = 1$, so we do not need to worry about that. If the
upper point of our contour happens to have zeros exactly on it, we would be
very unlucky, but even if this were to happen we could just adjust it up a
little bit.&lt;/p&gt;
&lt;img alt="Our contour" src="https://asmeurer.com/blog/contour-c.svg" width="608" /&gt;
&lt;p&gt;(Our contour with $N=10$. Created with &lt;a href="https://www.geogebra.org/graphing/nmnsaywd"&gt;Geogebra&lt;/a&gt;)&lt;/p&gt;
&lt;p&gt;&lt;a href="http://mpmath.org/doc/current/calculus/integration.html#mpmath.quad"&gt;&lt;code&gt;mpmath.quad&lt;/code&gt;&lt;/a&gt;
can take a list of points to compute a contour. The &lt;code&gt;maxdegree&lt;/code&gt; parameter
allows us to increase the degree of the quadrature if it becomes necessary to
get an accurate result.&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-py"&gt;&amp;gt;&amp;gt;&amp;gt; def argument_count(func, N, maxdegree=6):
...     return 1/(2*mpmath.pi*1j)*(mpmath.quad(func,
...         [1 + 0.1j, 1 + N*1j, 0 + N*1j, 0 + 0.1j,  1 + 0.1j],
...         maxdegree=maxdegree))
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Now let's test it. Lets count the zeros of $$s^2 - s + 1/2$$ in the box
bounded by the above rectangle ($N = 10$).&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-py"&gt;&amp;gt;&amp;gt;&amp;gt; expr = s**2 - s + S(1)/2
&amp;gt;&amp;gt;&amp;gt; argument_count(lambdify(s, expr.diff(s)/expr), 10)
mpc(real='1.0', imag='3.4287545414000525e-24')
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The integral is 1. We can confirm there is indeed one
zero in this box, at $\frac{1}{2} + \frac{i}{2}$.&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-py"&gt;&amp;gt;&amp;gt;&amp;gt; solve(s**2 - s + S(1)/2)
[1/2 - I/2, 1/2 + I/2]
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Now compute points of $Z$ along the critical line so we can count the sign
changes. We also make provisions in case we have to increase the precision of
mpmath to get correct results here. &lt;code&gt;dps&lt;/code&gt; is the number of digits of precision
the values are computed to. The default is 15, but mpmath can compute values
to any number of digits.
&lt;a href="http://mpmath.org/doc/current/general.html#chop"&gt;&lt;code&gt;mpmath.chop&lt;/code&gt;&lt;/a&gt; zeros out
values that are close to &lt;code&gt;0&lt;/code&gt;, which removes any numerically insignificant
imaginary parts that arise from the floating point evaluation.&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-py"&gt;&amp;gt;&amp;gt;&amp;gt; def compute_points(Z_func, N, npoints=10000, dps=15):
...     import warnings
...     old_dps = mpmath.mp.dps
...     points = np.linspace(0, N, npoints)
...     try:
...         mpmath.mp.dps = dps
...         L = [mpmath.chop(Z_func(i)) for i in 1/2 + points*1j]
...     finally:
...         mpmath.mp.dps = old_dps
...     if L[-1] == 0:
...         # mpmath will give 0 if the precision is not high enough, since Z
...         # decays rapidly on the critical line.
...         warnings.warn("You may need to increase the precision")
...     return L
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Next define a function to count the number of sign changes in a list of real
values.&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-py"&gt;&amp;gt;&amp;gt;&amp;gt; def sign_changes(L):
...     """
...     Count the number of sign changes in L
...
...     Values of L should all be real.
...     """
...     changes = 0
...     assert im(L[0]) == 0, L[0]
...     s = sign(L[0])
...     for i in L[1:]:
...         assert im(i) == 0, i
...         s_ = sign(i)
...         if s_ == 0:
...             # Assume these got chopped to 0
...             continue
...         if s_ != s:
...             changes += 1
...         s = s_
...     return changes
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;For example, for $\sin(s)$ from -10 to 10, there are 7 zeros ($3\pi\approx
9.42$).&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-py"&gt;&amp;gt;&amp;gt;&amp;gt; sign_changes(lambdify(s, sin(s))(np.linspace(-10, 10)))
7
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Now we can check how many zeros of $Z(s)$ (and hence non-trivial zeros of
$\zeta(s)$) we can find. According to
&lt;a href="https://en.wikipedia.org/wiki/Riemann_hypothesis"&gt;Wikipedia&lt;/a&gt;, the first few
non-trivial zeros of $\zeta(s)$ in the upper half-plane are 14.135, 21.022,
and 25.011.&lt;/p&gt;
&lt;p&gt;First try up to $N=20$.&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-py"&gt;&amp;gt;&amp;gt;&amp;gt; argument_count(D_func, 20)
mpc(real='0.99999931531867581', imag='-3.2332902529067346e-24')
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Mathematically, the above value &lt;em&gt;must&lt;/em&gt; be an integer, so we know it is 1.&lt;/p&gt;
&lt;p&gt;Now check the number of sign changes of $Z(s)$ from $\frac{1}{2} + 0i$ to
$\frac{1}{2} + 20i$.&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-py"&gt;&amp;gt;&amp;gt;&amp;gt; L = compute_points(Z_func, 20)
&amp;gt;&amp;gt;&amp;gt; sign_changes(L)
1
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;So it checks out. There is one zero between $0$ and $20i$ on the critical
strip, and it is in fact on the critical line, as expected!&lt;/p&gt;
&lt;p&gt;Now let's verify the other two zeros from Wikipedia.&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-py"&gt;&amp;gt;&amp;gt;&amp;gt; argument_count(D_func, 25)
mpc(real='1.9961479945577916', imag='-3.2332902529067346e-24')
&amp;gt;&amp;gt;&amp;gt; L = compute_points(Z_func, 25)
&amp;gt;&amp;gt;&amp;gt; sign_changes(L)
2
&amp;gt;&amp;gt;&amp;gt; argument_count(D_func, 30)
mpc(real='2.9997317058520916', imag='-3.2332902529067346e-24')
&amp;gt;&amp;gt;&amp;gt; L = compute_points(Z_func, 30)
&amp;gt;&amp;gt;&amp;gt; sign_changes(L)
3
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Both check out as well.&lt;/p&gt;
&lt;p&gt;Since we are computing the points, we can go ahead and make a plot as well.
However, there is a technical difficulty. If you naively try to plot $Z(1/2 +
it)$, you will find that it decays rapidly, so fast that you cannot really
tell where it crosses 0:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-py"&gt;&amp;gt;&amp;gt;&amp;gt; def plot_points_bad(L, N):
...     npoints = len(L)
...     points = np.linspace(0, N, npoints)
...     plt.figure()
...     plt.plot(points, L)
...     plt.plot(points, [0]*npoints, linestyle=':')
&amp;gt;&amp;gt;&amp;gt; plot_points_bad(L, 30)
&lt;/code&gt;&lt;/pre&gt;
&lt;img src="https://asmeurer.com/blog/riemann-bad.svg" width="608" /&gt;
&lt;p&gt;So instead of plotting $Z(1/2 + it)$, we plot $\log(|Z(1/2 + it)|)$. The
logarithm will make the zeros go to $-\infty$, but these will be easy to see.&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-py"&gt;&amp;gt;&amp;gt;&amp;gt; def plot_points(L, N):
...     npoints = len(L)
...     points = np.linspace(0, N, npoints)
...     p = [mpmath.log(abs(i)) for i in L]
...     plt.figure()
...     plt.plot(points, p)
...     plt.plot(points, [0]*npoints, linestyle=':')
&amp;gt;&amp;gt;&amp;gt; plot_points(L, 30)
&lt;/code&gt;&lt;/pre&gt;
&lt;img src="https://asmeurer.com/blog/riemann-30.svg" width="608" /&gt;
&lt;p&gt;The spikes downward are the zeros.&lt;/p&gt;
&lt;p&gt;Finally, let's check up to N=100. &lt;a href="https://oeis.org/A072080"&gt;OEIS A072080&lt;/a&gt;
gives the number of zeros of $\zeta(s)$ in upper half-plane up to $10^ni$.
According to it, we should get 29 zeros between $0$ and $100i$.&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-py"&gt;&amp;gt;&amp;gt;&amp;gt; argument_count(D_func, 100)
mpc(real='28.248036536895913', imag='-3.2332902529067346e-24')
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;This is not near an integer. This means we need to increase the precision of
the quadrature (the &lt;code&gt;maxdegree&lt;/code&gt; argument).&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-py"&gt;&amp;gt;&amp;gt;&amp;gt; argument_count(D_func, 100, maxdegree=9)
mpc(real='29.000000005970151', imag='-3.2332902529067346e-24')
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;And the sign changes...&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-py"&gt;&amp;gt;&amp;gt;&amp;gt; L = compute_points(Z_func, 100)
__main__:11: UserWarning: You may need to increase the precision
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Our guard against the precision being too low was triggered. Try raising it
(the default dps is 15).&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-py"&gt;&amp;gt;&amp;gt;&amp;gt; L = compute_points(Z_func, 100, dps=50)
&amp;gt;&amp;gt;&amp;gt; sign_changes(L)
29
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;They both give 29. So we have verified the Riemann Hypothesis up to $100i$!&lt;/p&gt;
&lt;p&gt;Here is a plot of these 29 zeros.&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-py"&gt;&amp;gt;&amp;gt;&amp;gt; plot_points(L, 100)
&lt;/code&gt;&lt;/pre&gt;
&lt;img src="https://asmeurer.com/blog/riemann-100.svg" width="608" /&gt;
&lt;p&gt;(remember that the spikes downward are the zeros)&lt;/p&gt;
&lt;h2&gt;Conclusion&lt;/h2&gt;
&lt;p&gt;$N=100$ takes a few minutes to compute, and I imagine larger and larger values
would require increasing the precision more, slowing it down even further, so
I didn't go higher than this. But it is clear that this method works.&lt;/p&gt;
&lt;p&gt;This was just me playing around with SymPy and mpmath, but if I wanted to
actually verify the Riemann Hypothesis, I would try to find a more efficient
method of computing the above quantities. For the sake of simplicity, I used
$Z(s)$ for both the argument principle and sign changes computations, but it
would have been more efficient to use $\zeta(s)$ for the argument principle
integral, since it has a simpler formula. It would also be useful if there
were a formula with similar properties to $Z(s)$ (real on the critical line
with the same zeros as $\zeta(s)$), but that did not decay as rapidly.&lt;/p&gt;
&lt;p&gt;Furthermore, for the argument principle integral, I would like to see precise
error estimates for the integral. We saw above with $N=100$ with the default
quadrature that we got a value of 28.248, which is not close to an integer.
This tipped us off that we should increase the quadrature, which ended up
giving us the right answer, but if the original number happened to be close to
an integer, we might have been fooled. Ideally, one would like know the exact
quadrature degree needed. If you can get error estimates guaranteeing the
error for the integral will be less than 0.5, you can always round the answer
to the nearest integer. For the sign changes, you don't need to be as
rigorous, because simply seeing as many sign changes as you have zeros is
sufficient. However, one could certainly be more efficient in computing the
values along the interval, rather than just naively computing 10000 points and
raising the precision until it works, as I have done.&lt;/p&gt;
&lt;p&gt;One would also probably want to use a faster integrator than mpmath (like one
written in C), and perhaps also find a faster to evaluate expression than the
one I used for $Z(s)$. It is also possible that one could special-case the
quadrature algorithm knowing that it will be computed on $\zeta'(s)/\zeta(s)$.&lt;/p&gt;
&lt;p&gt;In this post I described the Riemann zeta function and the Riemann Hypothesis,
and showed how to computationally verify it. But I didn't really go over the
details of why the Riemann Hypothesis matters. I encourage you to watch the
videos in my &lt;a href="https://www.youtube.com/playlist?list=PLrFrByaoJbcqKjzgJvLs2-spSmzP7jolT"&gt;YouTube
playlist&lt;/a&gt;
if you want to know this. Among other things, the truth of the Riemann
Hypothesis would give a very precise bound on the distribution of prime
numbers. Also, the non-trivial zeros of $\zeta(s)$ are, in some sense, the
"spectrum" of the prime numbers, meaning they exactly encode the position of
every prime on the number line.&lt;/p&gt;&lt;/div&gt;</description>
    </item>
  </channel>
</rss>
