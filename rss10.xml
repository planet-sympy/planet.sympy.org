<?xml version="1.0"?>
<rss version="2.0" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Planet SymPy</title>
    <link>http://planet.sympy.org/</link>
    <language>en</language>
    <description>Planet SymPy - http://planet.sympy.org/</description>
    <atom:link href="http://planet.sympy.org/rss10.xml" rel="self" type="application/rss+xml"/>
    <item>
      <guid isPermaLink="false">http://ishanaj.wordpress.com/?p=56</guid>
      <author>Ishan Joshi (ishanaj)</author>
      <title>Ishan Joshi (ishanaj): GSoC&#x2019;19: Week-6-Completing the Column class.</title>
      <pubDate>Mon, 08 Jul 2019 04:44:15 GMT</pubDate>
      <link>https://ishanaj.wordpress.com/2019/07/08/gsoc19-week-6-completing-the-column-class/</link>
      <description>&lt;p&gt;The sixth week has ended with a lot of work to be done ahead.&lt;/p&gt;
&lt;p&gt;Last week the work was majorly focused on the work in progress &lt;a href="https://github.com/sympy/sympy/pull/17122"&gt;PR #17122&lt;/a&gt;. I have included the critical load function which makes the Column class capable of determining the critical load. Some problems still came up in solving some equations. I have made an &lt;a href="https://github.com/sympy/sympy/issues/17162"&gt;issue&lt;/a&gt; related to those.&lt;/p&gt;
&lt;p&gt;An equation similar to &lt;strong&gt;tan(x) &amp;#8211; x&lt;/strong&gt; comes up while determining the critical load for the&amp;#160;&lt;strong&gt;pinned-fixed&lt;/strong&gt;&amp;#160;end-condition. SymPy&amp;#8217;s &lt;strong&gt;solve() &lt;/strong&gt;won&amp;#8217;t be able to solve such an equation, and as per the solution given in the &lt;a href="https://github.com/sympy/sympy/issues/17162"&gt;issue&lt;/a&gt;, I think that &lt;strong&gt;nsolve()&lt;/strong&gt; would surely help in this case. So I will be going ahead to solve it using the approximation returned by &lt;strong&gt;nsolve()&lt;/strong&gt; to handle this condition.&lt;/p&gt;
&lt;p&gt;Another problem that I faced was determining deflection and critical load for the&amp;#160;&lt;strong&gt;pinned-pinned&lt;/strong&gt;&amp;#160;end-condition. Here, the deflection comes out to be:&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;C1*sin(sqrt(P)*x/(sqrt(E)*sqrt(I)))&lt;/strong&gt; +&lt;strong&gt; C2*cos(sqrt(P)*x/(sqrt(E)*sqrt(I)))&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Now on solving it for constants &lt;strong&gt;C1&lt;/strong&gt; and &lt;strong&gt;C2, &lt;/strong&gt;using initial boundary conditions,&amp;#160;both come out to be &lt;strong&gt;0&lt;/strong&gt;, making the deflection &lt;strong&gt;zero&lt;/strong&gt;. This implies that no buckling occurs, which is not the case.&lt;/p&gt;
&lt;p&gt;Even when solving it manually, this situation occurs, we deal with it by putting &lt;strong&gt;C2 = 0 &lt;/strong&gt;and instead of putting &lt;strong&gt;C1 = 0,&lt;/strong&gt; we consider the &lt;strong&gt;sin &lt;/strong&gt;term equal to zero and then solve for &lt;strong&gt;P (critical load).&amp;#160;&lt;/strong&gt;So, I will be adding a few more lines of code to deal with this situation.&lt;/p&gt;
&lt;p&gt;Apart from working on this module, I have also opened another &lt;a href="https://github.com/sympy/sympy/pull/17153"&gt;PR #17153&lt;/a&gt; which implement methods&amp;#160;to determine &lt;strong&gt;section modulus&lt;/strong&gt; and &lt;strong&gt;polar modulus&lt;/strong&gt; of any polygon (more precisely a cross-section). Initially it was a draft PR, but now the work has been completed on it. Once I get the approval, I will also be adding the same for the Ellipses module. Also, if &lt;strong&gt;&lt;a href="https://github.com/sympy/sympy/pull/17001"&gt;cut_section()&lt;/a&gt; &lt;/strong&gt;gets successfully implemented I will be adding another method to determine the first moment.&lt;/p&gt;
&lt;p&gt;I am pretty sure the work on &lt;strong&gt;Column class&lt;/strong&gt; will be successfully completed before the end of the next week. Also, we will be heading towards the next stage which intends to plot beam diagrams using matplotlib. Till then we can have an initial discussion regarding the same.&lt;/p&gt;
&lt;h2&gt;&lt;strong&gt;Next Week:&lt;/strong&gt;&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;Improving the &lt;strong&gt;critical_load()&lt;/strong&gt; to handle the above problems&lt;/li&gt;
&lt;li&gt;Completing the Column class (documentation and tests)&lt;/li&gt;
&lt;li&gt;Starting with the next phase&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Will keep you updated!&lt;/p&gt;
&lt;p&gt;Thanks!&lt;/p&gt;</description>
    </item>
    <item>
      <guid isPermaLink="false">https://czgdp1807.github.io/week_6</guid>
      <author>Gagandeep Singh (czgdp1807)</author>
      <title>Gagandeep Singh (czgdp1807): Week 6 - Some extensions</title>
      <pubDate>Mon, 08 Jul 2019 00:00:00 GMT</pubDate>
      <link>https://czgdp1807.github.io/week_6/</link>
      <description>&lt;p&gt;This week was a mix of discussion on design and extending previous work. I also got to know about some new cool features of &lt;code class="highlighter-rouge"&gt;SymPy&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;According to the plan proposed in &lt;a href="https://czgdp1807.github.io/week_4/"&gt;Week 4&lt;/a&gt;, I have completed my work on &lt;code class="highlighter-rouge"&gt;DiscreteMarkovChain&lt;/code&gt; via &lt;a href="https://github.com/sympy/sympy/pull/17083"&gt;PR #17083&lt;/a&gt;. I used the &lt;code class="highlighter-rouge"&gt;as_set&lt;/code&gt; and &lt;code class="highlighter-rouge"&gt;as_relational&lt;/code&gt; methods which helped me to cover many miscellaneous cases and probably, now &lt;code class="highlighter-rouge"&gt;DiscreteMarkovChain&lt;/code&gt; is quite dynamic and can handle various generic &lt;code class="highlighter-rouge"&gt;probability&lt;/code&gt; and &lt;code class="highlighter-rouge"&gt;expectation&lt;/code&gt; queries. I have also started the &lt;a href="https://github.com/sympy/sympy/pull/17163"&gt;PR #17163&lt;/a&gt; for adding &lt;code class="highlighter-rouge"&gt;ContinuousMarkovChain&lt;/code&gt; and I am observing that it&amp;#8217;s a bit tricky to maintain both the performance and result quality while working on it. Now, moving on to symbolic &lt;code class="highlighter-rouge"&gt;Range&lt;/code&gt;,well, the work has been started in the &lt;a href="https://github.com/sympy/sympy/pull/17146"&gt;PR #17146&lt;/a&gt; and I have figured out one disparity between &lt;code class="highlighter-rouge"&gt;Range&lt;/code&gt; and python&amp;#8217;s &lt;code class="highlighter-rouge"&gt;range&lt;/code&gt;(details available at &lt;a href="https://github.com/sympy/sympy/pull/17146#discussion_r300162219"&gt;this thread&lt;/a&gt;). I will try to fix it by making minimal changes to the code. The tensorflow related &lt;a href="https://github.com/sympy/sympy/pull/17103"&gt;PR #17103&lt;/a&gt; which I started in the previous week is also almost complete and is waiting for &lt;code class="highlighter-rouge"&gt;Tensorflow 2.0&lt;/code&gt; release. I am also studying a bit about the architecture of the above framework to make changes to &lt;code class="highlighter-rouge"&gt;lambdify&lt;/code&gt;. Regarding random matrices, I believe that discussion has reached its final stages and I am waiting for the comments from Francesco for improvements at the issue &lt;a href="https://github.com/sympy/sympy/issues/17039"&gt;#17039&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Let me share with you about my discoveries and learnings in this week. Well, thanks to Francesco for telling me about, &lt;code class="highlighter-rouge"&gt;sympy.multipledispatch&lt;/code&gt;. It helps in implementing operator overloading like in C/C++. I liked it very much. I also read about continuous Markov chain and discovered about generator matrix, forward and backward equations. Adding one interesting fact, that Poisson process and continuous Markov chain are very closely related via generator matrices it will make the implementation of the former much easier :D.&lt;/p&gt;

&lt;p&gt;Leaving you for now, Bye!!&lt;/p&gt;</description>
    </item>
    <item>
      <guid isPermaLink="false">https://divyanshu132.github.io//gsoc-week-6</guid>
      <author>Divyanshu Thakur (divyanshu132)</author>
      <title>Divyanshu Thakur (divyanshu132): GSoC 2019 - Week 6 - Computation of Polycyclic presentation</title>
      <pubDate>Mon, 08 Jul 2019 00:00:00 GMT</pubDate>
      <link>https://divyanshu132.github.io//gsoc-week-6</link>
      <description>&lt;p&gt;The sixth week of coding period has ended and a good amount of work has been done on polycyclic groups. Polycyclic presentation, Polycyclic generating sequence(pcgs) and it&amp;#8217;s series is implemented which for sure need some improvement &lt;a href="https://github.com/sympy/sympy/pull/16991"&gt;sympy/sympy#16991&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;The polycyclic series is computed starting from the bottom of the derived series of a group by adding the missing generators in the subgroups, and collecting these missing generators provide us the polycyclic generating sequence.&lt;/p&gt;

&lt;p&gt;As we discussed last week &lt;a href="https://divyanshu132.github.io/gsoc-week-5"&gt;here&lt;/a&gt; that to compute conjugate relators of a polycyclic group we were missing the &lt;code class="highlighter-rouge"&gt;RHS&lt;/code&gt; term, which was of the form &lt;code class="highlighter-rouge"&gt;x[i]**-1*x[i+1]*x[i] == RHS&lt;/code&gt;. So, starting from the bottom of the polycyclic generating sequence forming the subgroup and finding all the generators of the RHS using &lt;code class="highlighter-rouge"&gt;generator_product&lt;/code&gt;, mapping these generators with the free group elements and forming a word, finally collect the above formed word which will give us the collected RHS.&lt;/p&gt;

&lt;p&gt;Below is an example to compute polycyclic presentation for S(9).sylow_subgroup(3)&lt;/p&gt;

&lt;div class="highlighter-rouge"&gt;&lt;div class="highlight"&gt;&lt;pre class="highlight"&gt;&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; from sympy.combinatorics import *
&amp;gt;&amp;gt;&amp;gt; from sympy.combinatorics.free_groups import free_group
&amp;gt;&amp;gt;&amp;gt; F, x0, x1, x2, x3 = free_group("x0, x1, x2, x3")
&amp;gt;&amp;gt;&amp;gt; S = SymmetricGroup(9)
&amp;gt;&amp;gt;&amp;gt; G = S.sylow_subgroup(3)
&amp;gt;&amp;gt;&amp;gt; pc_group = G.polycyclic_group()
&amp;gt;&amp;gt;&amp;gt; group = F
&amp;gt;&amp;gt;&amp;gt; pc_group.pc_presentation(group)
{x3**3: (), x2**3: (), x1**3: (), x0**3: (), x2**-1*x3*x2: x3, x1**-1*x3*x1: x3, x1**-1*x2*x1: x2, x0**-1*x3*x0: x2**2*x3**2, x0**-1*x2*x0: x3, x0**-1*x1*x0: x1*x3}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;One problem that we&amp;#8217;ve encountered is that the generators in pcgs may change for the same group on executing it several times which makes it difficult to test pc_presentation but, Kalevi advised me to initalize &lt;code class="highlighter-rouge"&gt;random.seed&lt;/code&gt; with some chosen value and then it will result in the same repeatable result, will try it by today!&lt;/p&gt;

&lt;p&gt;The tasks that I&amp;#8217;m hopping to accomplish next week are&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Add tests for plycyclic presentation and be sure that it works properly.&lt;/li&gt;
  &lt;li&gt;Include more functionalities to pc groups like &lt;code class="highlighter-rouge"&gt;exponent_vector&lt;/code&gt;, &lt;code class="highlighter-rouge"&gt;element_depth&lt;/code&gt;, &lt;code class="highlighter-rouge"&gt;leading_coefficient&lt;/code&gt;.&lt;/li&gt;
  &lt;li&gt;Add documentation for all the functions.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Till then, good byee..&lt;/p&gt;</description>
    </item>
    <item>
      <guid isPermaLink="false">https://arighnaiitg.github.io/2019-07-07-gsoc-week6/</guid>
      <author>Arighna Chakrabarty (arighnaiitg)</author>
      <title>Arighna Chakrabarty (arighnaiitg): GSoC Week 6 !!</title>
      <pubDate>Sun, 07 Jul 2019 07:00:00 GMT</pubDate>
      <link>https://arighnaiitg.github.io/2019-07-07-gsoc-week6/</link>
      <description>&lt;p&gt;Week 6 ends.. - 
          Phase 2 of the coding period is smoothly being traversed. I recently had a meeting with Sartaj on 4th of July, Thursday. Here were the minutes of the meeting, along with the deliverables completed over the week. The meeting commenced with the discussion that we need to wrap up the...</description>
    </item>
    <item>
      <guid isPermaLink="false">https://anpandey.github.io/posts/sympy/2019-07-07-week-6.html</guid>
      <author>Ankit Pandey (anpandey)</author>
      <title>Ankit Pandey (anpandey): Google Summer of Code Week 6: Unification and Tensors Continued</title>
      <pubDate>Sun, 07 Jul 2019 00:00:00 GMT</pubDate>
      <link>https://anpandey.github.io/posts/sympy/2019-07-07-week-6.html</link>
      <description>&lt;p&gt;&lt;em&gt;See the &lt;a href="https://anpandey.github.io/2019-06-28-week-5.html"&gt;previous post&lt;/a&gt; for Week 5&lt;/em&gt;.&lt;/p&gt;
&lt;p&gt;This week I&amp;#8217;ve made some progress on matching and tensors, though I haven&amp;#8217;t filed any pull requests.&lt;/p&gt;
&lt;h2 id="unification"&gt;Unification&lt;/h2&gt;
&lt;p&gt;I have a working implementation of rewriting non-commutative expressions using SymPy&amp;#8217;s unify. It works by generating a &lt;code&gt;ReplaceOptim&lt;/code&gt; object that applies the rewriting rules to any term it&amp;#8217;s called with. Here&amp;#8217;s how we specify the rewriting rules:&lt;/p&gt;
&lt;div class="sourceCode" id="cb1"&gt;&lt;pre class="sourceCode python"&gt;&lt;code class="sourceCode python"&gt;&lt;a class="sourceLine" id="cb1-1" title="1"&gt;&lt;span class="op"&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class="im"&gt;from&lt;/span&gt; sympy &lt;span class="im"&gt;import&lt;/span&gt; Symbol, MatrixSymbol&lt;/a&gt;
&lt;a class="sourceLine" id="cb1-2" title="2"&gt;&lt;span class="op"&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt; n &lt;span class="op"&gt;=&lt;/span&gt; Symbol(&lt;span class="st"&gt;'N_matcher'&lt;/span&gt;, integer&lt;span class="op"&gt;=&lt;/span&gt;&lt;span class="va"&gt;True&lt;/span&gt;)&lt;/a&gt;
&lt;a class="sourceLine" id="cb1-3" title="3"&gt;&lt;span class="op"&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt; X &lt;span class="op"&gt;=&lt;/span&gt; MatrixSymbol(&lt;span class="st"&gt;'X_matcher'&lt;/span&gt;, n, n)&lt;/a&gt;
&lt;a class="sourceLine" id="cb1-4" title="4"&gt;&lt;span class="op"&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt; Y &lt;span class="op"&gt;=&lt;/span&gt; MatrixSymbol(&lt;span class="st"&gt;'Y_matcher'&lt;/span&gt;, n, &lt;span class="dv"&gt;1&lt;/span&gt;)&lt;/a&gt;
&lt;a class="sourceLine" id="cb1-5" title="5"&gt;&lt;span class="op"&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt; variables &lt;span class="op"&gt;=&lt;/span&gt; [n, X, Y]&lt;/a&gt;
&lt;a class="sourceLine" id="cb1-6" title="6"&gt;&lt;span class="op"&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt; matcher &lt;span class="op"&gt;=&lt;/span&gt; X&lt;span class="op"&gt;**&lt;/span&gt;(&lt;span class="op"&gt;-&lt;/span&gt;&lt;span class="dv"&gt;1&lt;/span&gt;) &lt;span class="op"&gt;*&lt;/span&gt; Y&lt;/a&gt;
&lt;a class="sourceLine" id="cb1-7" title="7"&gt;&lt;span class="op"&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt; goal &lt;span class="op"&gt;=&lt;/span&gt; MatrixSolve(X, Y)&lt;/a&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Here, the combination of &lt;code&gt;matcher&lt;/code&gt; and &lt;code&gt;variables&lt;/code&gt; specifies that we&amp;#8217;re looking for any expression of the form &lt;span class="math inline"&gt;&lt;em&gt;X&lt;/em&gt;&lt;sup&gt;&amp;#8197;&amp;#8722;&amp;#8197;1&lt;/sup&gt;&lt;em&gt;Y&lt;/em&gt;&lt;/span&gt;, where both &lt;span class="math inline"&gt;&lt;em&gt;X&lt;/em&gt;&lt;/span&gt; and &lt;span class="math inline"&gt;&lt;em&gt;Y&lt;/em&gt;&lt;/span&gt; can be any compound matrix expression. The inclusion of &lt;code&gt;n&lt;/code&gt; in &lt;code&gt;variables&lt;/code&gt; imposes the additional restriction that the matrix expression matched by &lt;span class="math inline"&gt;&lt;em&gt;X&lt;/em&gt;&lt;/span&gt; must be square (i.e. &lt;span class="math inline"&gt;&lt;em&gt;n&lt;/em&gt;&amp;#8197;&amp;#215;&amp;#8197;&lt;em&gt;n&lt;/em&gt;&lt;/span&gt;) while the expression matched by &lt;span class="math inline"&gt;&lt;em&gt;Y&lt;/em&gt;&lt;/span&gt; must be a vector (i.e. &lt;span class="math inline"&gt;&lt;em&gt;n&lt;/em&gt;&amp;#8197;&amp;#215;&amp;#8197;1&lt;/span&gt;). &lt;code&gt;goal&lt;/code&gt; specifies what the matched expression should be replaced with, where &lt;code&gt;X&lt;/code&gt; and &lt;code&gt;Y&lt;/code&gt; serve as stand-ins for the matched terms.&lt;/p&gt;
&lt;p&gt;After specifying our goals, we can construct the object and apply the replacement to some expressions:&lt;/p&gt;
&lt;div class="sourceCode" id="cb2"&gt;&lt;pre class="sourceCode python"&gt;&lt;code class="sourceCode python"&gt;&lt;a class="sourceLine" id="cb2-1" title="1"&gt;&lt;span class="op"&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt; replacer &lt;span class="op"&gt;=&lt;/span&gt; gen_replacement_operator(matcher, goal, variables)&lt;/a&gt;
&lt;a class="sourceLine" id="cb2-2" title="2"&gt;&lt;span class="op"&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt; A, B, x &lt;span class="op"&gt;=&lt;/span&gt; MatrixSymbol(&lt;span class="st"&gt;'A'&lt;/span&gt;, &lt;span class="dv"&gt;3&lt;/span&gt;, &lt;span class="dv"&gt;3&lt;/span&gt;), MatrixSymbol(&lt;span class="st"&gt;'B'&lt;/span&gt;, &lt;span class="dv"&gt;3&lt;/span&gt;, &lt;span class="dv"&gt;3&lt;/span&gt;), MatrixSymbol(&lt;span class="st"&gt;'x'&lt;/span&gt;, &lt;span class="dv"&gt;3&lt;/span&gt;, &lt;span class="dv"&gt;1&lt;/span&gt;)&lt;/a&gt;
&lt;a class="sourceLine" id="cb2-3" title="3"&gt;&lt;span class="op"&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt; replacer(A &lt;span class="op"&gt;**&lt;/span&gt; (&lt;span class="op"&gt;-&lt;/span&gt;&lt;span class="dv"&gt;1&lt;/span&gt;) &lt;span class="op"&gt;*&lt;/span&gt; x)&lt;/a&gt;
&lt;a class="sourceLine" id="cb2-4" title="4"&gt;(MatrixSolve(A, vector&lt;span class="op"&gt;=&lt;/span&gt;x))&lt;/a&gt;
&lt;a class="sourceLine" id="cb2-5" title="5"&gt;&lt;span class="op"&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt; replacer(A &lt;span class="op"&gt;**&lt;/span&gt; (&lt;span class="op"&gt;-&lt;/span&gt;&lt;span class="dv"&gt;1&lt;/span&gt;) &lt;span class="op"&gt;*&lt;/span&gt; B)&lt;/a&gt;
&lt;a class="sourceLine" id="cb2-6" title="6"&gt;A &lt;span class="op"&gt;**&lt;/span&gt; (&lt;span class="op"&gt;-&lt;/span&gt;&lt;span class="dv"&gt;1&lt;/span&gt;) &lt;span class="op"&gt;*&lt;/span&gt; B&lt;/a&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;The first term was replaced since the dimensions of &lt;code&gt;A&lt;/code&gt; and &lt;code&gt;x&lt;/code&gt; agreed with what was specified in matcher, while the second expression was left untouched since &lt;code&gt;B&lt;/code&gt; is not a vector.&lt;/p&gt;
&lt;p&gt;While the matcher does work, I haven&amp;#8217;t filed a pull request because of some problems which don&amp;#8217;t seem like they could be easily addressed:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;I had to give add the suffix &lt;code&gt;_matcher&lt;/code&gt; to the variable names to avoid variable capture, since SymPy symbols are considered equal if they have the same name. &lt;code&gt;unify&lt;/code&gt; does not support &lt;code&gt;Dummy&lt;/code&gt; symbols as variables.&lt;/li&gt;
&lt;li&gt;Some compound expressions are not matched. I&amp;#8217;ve narrowed this down to the way the variables are being passed to &lt;code&gt;unify&lt;/code&gt;, since they need to be converted to symbols. It seems like this conversion sometimes causes expressions to no longer be unifiable.&lt;/li&gt;
&lt;li&gt;Unification doesn&amp;#8217;t seem to work for a mixture of commutative and non-commutative expressions. I&amp;#8217;m not sure if this is a problem with &lt;code&gt;unify&lt;/code&gt; itself or the way that I&amp;#8217;m using it, since the only test of &lt;code&gt;unify&lt;/code&gt; in the SymPy codebase involving matrix expressions is on matrix multiplication.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;As I mentioned in my last blog post, SymPy already supports this sort of pattern matching through &lt;code&gt;Wild&lt;/code&gt;, though it currently does not support expressions involving matrices. Before trying to address these issues, I think it would be worthwhile to look into extending the functionality of &lt;code&gt;Wild&lt;/code&gt; as an alternative.&lt;/p&gt;
&lt;h2 id="tensors"&gt;Tensors&lt;/h2&gt;
&lt;p&gt;I&amp;#8217;ve made some progress in low-level code generation of matrix expressions. I tried seeing if instances of classes in the &lt;code&gt;array_utils&lt;/code&gt; module could be converted to SymPy&amp;#8217;s AST representation before being passed off to the code generators. This doesn&amp;#8217;t seem possible at the moment, since the AST has a number of limitations (such as not supporting variables in &lt;code&gt;for&lt;/code&gt; loop ranges). The &lt;code&gt;IndexedBase&lt;/code&gt; printer already has some of the functionality that I&amp;#8217;m trying to implement, so I&amp;#8217;ve settled on extending the printer to support arbitrary contractions. This same functionality can probably be reused for the &lt;code&gt;array_utils&lt;/code&gt; printers. The implementation will hopefully be straightforward.&lt;/p&gt;
&lt;h2 id="next-steps"&gt;Next steps&lt;/h2&gt;
&lt;p&gt;My goal for this week is to have a pull request for the tensor code generation ready, along with a plan for what to do with matching.&lt;/p&gt;</description>
    </item>
    <item>
      <guid isPermaLink="false">https://jmig5776.github.io//gsoc-week-6</guid>
      <author>Jogi Miglani (jmig5776)</author>
      <title>Jogi Miglani (jmig5776): GSoC 2019 - Week 6</title>
      <pubDate>Sun, 07 Jul 2019 00:00:00 GMT</pubDate>
      <link>https://jmig5776.github.io//gsoc-week-6</link>
      <description>&lt;p&gt;This was the sixth week meeting with the GSoC mentors which was scheduled on
Sunday 7th July, 2019 between 1:45 - 2:45 PM (IST). Me, Yathartha and Amit
were the attendees of the meeting. This meeting was short.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Discussing previous week&amp;#8217;s progress&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;In this meeting both the mentors were convinced by the code for Lambert&amp;#8217;s.
And few modifications in documentation and code clean up were suggested by them.
In this week the whole idea of power_list was droppped because @smichr suggested
code for replacing the symbol more targetted as we wanted by which the whole code
was improved. And it was decided to work upon on &lt;code class="highlighter-rouge"&gt;_solve_modular&lt;/code&gt; mainly now
onwards.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;Next week goals&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Getting merge existing PR for Lambert&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Work upon &lt;code class="highlighter-rouge"&gt;_solve_modular&lt;/code&gt; PR&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;If time left then find plan for Imageset Union.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Code improvement takes time!!&lt;/p&gt;</description>
    </item>
    <item>
      <guid isPermaLink="false">https://sc0rpi0n101.github.io/2019/07/week-6-the-most-chaotic-week-ever/</guid>
      <author>Nikhil Maan (Sc0rpi0n101)</author>
      <title>Nikhil Maan (Sc0rpi0n101): Week 6: The Most Chaotic Week Ever!!</title>
      <pubDate>Sat, 06 Jul 2019 00:00:00 GMT</pubDate>
      <link>https://sc0rpi0n101.github.io/2019/07/week-6-the-most-chaotic-week-ever/</link>
      <description>&lt;p&gt;&amp;#8220;A language that doesn&amp;rsquo;t affect the way you think about programming is not worth knowing.&amp;#8221;  &amp;#8213; Alan J. Perlis
 Welcome everyone, this is your host Nikhil Maan aka Sc0rpi0n101 and this week was one of the most chaotic weeks till now if not the most chaotic. I had to move places as the Uni opens next week, had the summer classes exams and had to convert the C parser to use SymPy&amp;rsquo;s Codegen AST from Python AST all in one week.</description>
    </item>
    <item>
      <guid isPermaLink="false">https://shubhamkjha.github.io/2019/07/03/GSoC-2019-Week-5</guid>
      <author>Shubham Kumar Jha (ShubhamKJha)</author>
      <title>Shubham Kumar Jha (ShubhamKJha): GSoC 2019: Week 5</title>
      <pubDate>Wed, 03 Jul 2019 00:00:00 GMT</pubDate>
      <link>https://shubhamkjha.github.io/2019/07/03/GSoC-2019-Week-5.html</link>
      <description>&lt;p&gt;With this the fifth week and the first phase of the official coding period has ended. I will try to give a brief summary of my work during this week.&lt;/p&gt;

&lt;p&gt;I spent most of this week learning the inner working of &lt;strong&gt;satask&lt;/strong&gt; module. It took a lot of debugging to understand the on-going processes efficiently &amp;#128517; . My major job was to reduce the unwanted slowing portions in the code. I had  &lt;a href="https://github.com/sympy/sympy/pull/11789"&gt;#11789&lt;/a&gt; for reference. Some of such performance reducing portions of code were:&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;A major segment of code was creating &lt;strong&gt;And&lt;/strong&gt; objects unnecessarily. As suggested in &lt;a href="https://github.com/sympy/sympy/issues/17087"&gt;#17087&lt;/a&gt; the sorting in the &lt;strong&gt;And&lt;/strong&gt; constructor takes up a significant amount of time. These have to be reduced.&lt;/li&gt;
  &lt;li&gt;Using SymPy objects is itself a bottleneck for performance. Having a system built over SymPy objects slows things down. Python&amp;#8217;s built-in types should be used as much as possible.&lt;/li&gt;
  &lt;li&gt;A specific segment (used many times in the code) calls &lt;code class="highlighter-rouge"&gt;rcall&lt;/code&gt; over propositions. The &lt;code class="highlighter-rouge"&gt;rcall&lt;/code&gt; which is a recursive process also takes a significant of time.&lt;/li&gt;
  &lt;li&gt;Also, I have tried to pre-compile results as much as possible.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;With the above and some other changes, the overall performance of &lt;code class="highlighter-rouge"&gt;satask&lt;/code&gt; has improved much. I have made a PR over this &lt;a href="https://github.com/sympy/sympy/pull/17144"&gt;#17144&lt;/a&gt;. For an instance,&lt;/p&gt;
&lt;table style="padding: 15px;"&gt;
    &lt;thead&gt;
        &lt;th&gt;Tests&lt;/th&gt;
        &lt;th&gt;After this PR&lt;/th&gt;
        &lt;th&gt;In master&lt;/th&gt;
    &lt;/thead&gt;
    &lt;tbody&gt;
        &lt;tr&gt;
            &lt;td&gt;test_satask&lt;/td&gt;
            &lt;td&gt;2.39 s&lt;/td&gt;
            &lt;td&gt;36.26 s&lt;/td&gt;
        &lt;/tr&gt;
        &lt;tr&gt;
            &lt;td&gt;assumptions/tests&lt;/td&gt;
            &lt;td&gt;16.74 s&lt;/td&gt;
            &lt;td&gt;127.21 s&lt;/td&gt;
        &lt;/tr&gt;
    &lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;&lt;br /&gt;
There is still scope for improvement in performance. In the coming week, I will try to work these out. I will also try to improve the performance of &lt;strong&gt;ask&lt;/strong&gt; module.&lt;/p&gt;

&lt;p&gt;Also, the first evaluations are over now and I feel happy to announce that I passed it. During the first phase I learnt a lot. In last few weeks I got to explore profiling and got to understand how small segments can influence performance. Before this I felt that I already know the codebase, but in reality I had much to explore. My mentors always gave me a good starting point and a direction over the course of this phase. With the hope to work much better in the coming phases, I take your leave now &amp;#128516; .&lt;/p&gt;</description>
    </item>
    <item>
      <guid isPermaLink="false">https://czgdp1807.github.io/week_5</guid>
      <author>Gagandeep Singh (czgdp1807)</author>
      <title>Gagandeep Singh (czgdp1807): Week 5 - Transition towards Phase 2</title>
      <pubDate>Tue, 02 Jul 2019 00:00:00 GMT</pubDate>
      <link>https://czgdp1807.github.io/week_5/</link>
      <description>&lt;p&gt;The evaluation results for phase 1 are out, and I am very glad to share with you that I have passed with flying colors. I received, &amp;#8220;Well done so far.&amp;#8221; as the feedback for my work till now.&lt;/p&gt;

&lt;p&gt;So now let us move to the work done in the gap between phase 1 and phase 2. Firstly, both of my open PRs of the previous phase, i.e., &lt;a href="https://github.com/sympy/sympy/pull/16962"&gt;#16962&lt;/a&gt; and &lt;a href="https://github.com/sympy/sympy/pull/16934"&gt;#16934&lt;/a&gt; have been merged. Though for symbolic dimensions some more work has to be done to make &lt;code class="highlighter-rouge"&gt;sympy.stats.frv&lt;/code&gt; more efficient and maintainable. I have also started my work, PR &lt;a href="https://github.com/sympy/sympy/pull/17083"&gt;#17083&lt;/a&gt;, to extend the scope of queries for &lt;code class="highlighter-rouge"&gt;DiscreteMarkovChain&lt;/code&gt; and the system has become a bit smarter. In fact, during this week, while working on the PR, &lt;a href="https://github.com/sympy/sympy/pull/17103"&gt;#17103&lt;/a&gt;, I came across the news that Tensorflow has changed a lot of APIs  while migrating from 1.x to 2.x. AFAIK, they are moving towards &lt;code class="highlighter-rouge"&gt;Function&lt;/code&gt; approach from the previous &lt;code class="highlighter-rouge"&gt;Session&lt;/code&gt; approach, and due to that, SymPy&amp;#8217;s &lt;code class="highlighter-rouge"&gt;lambdify&lt;/code&gt; faced some issues which I will be fixing soon with the help of other members. The Tensorflow details can be seen &lt;a href="https://github.com/tensorflow/community/blob/b1d83bf2ee3fc72650140b89656e29932db36226/rfcs/20180918-functions-not-sessions-20.md"&gt;here&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Now, let&amp;#8217;s move to the learning part. During the transition period I learnt about the dependencies of &lt;code class="highlighter-rouge"&gt;SymPy&lt;/code&gt;. Moreover, I came across, how, some bugs can be unnoticed when left untested. Thanks again to &lt;a href="https://github.com/oscarbenjamin"&gt;oscarbenjamin&lt;/a&gt; for letting me know about the bugs related to variance of finite random variables. I also got to know that, how bare &lt;code class="highlighter-rouge"&gt;except&lt;/code&gt; can even catch keyboard interrupt and that&amp;#8217;s what makes it quite vulnerable. Thanks to &lt;a href="https://github.com/sidhantnagpal"&gt;sidhantnagpal&lt;/a&gt; for helping me with this.&lt;/p&gt;

&lt;p&gt;So, that&amp;#8217;s all for this, see you next week. Bye!!&lt;/p&gt;</description>
    </item>
    <item>
      <guid isPermaLink="false">https://divyanshu132.github.io//gsoc-week-5</guid>
      <author>Divyanshu Thakur (divyanshu132)</author>
      <title>Divyanshu Thakur (divyanshu132): GSoC 2019 - Week 5 - Hand-made tests for Collector</title>
      <pubDate>Mon, 01 Jul 2019 00:00:00 GMT</pubDate>
      <link>https://divyanshu132.github.io//gsoc-week-5</link>
      <description>&lt;p&gt;This week was mostly about testing the collection of a word and fixing small bugs in the implementation pointed out by Kalevi. The major challenge was to construct the polycyclic presentation of a group to test the Collector since we don&amp;#8217;t have the implementation of polycyclic presentation and it&amp;#8217;s generating sequence yet. So, we decided to form some hand made tests and we started with SymmetricGroup(4) and further we also tried with S(3) the details can be found in the test file of the PR(&lt;a href="https://github.com/sympy/sympy/pull/16991"&gt;here&lt;/a&gt;).&lt;/p&gt;

&lt;p&gt;Now, the next step is to implement polycyclic presentation and polycyclic sequence. In the presentation we&amp;#8217;ll need generators which we can easily get and the relators. There are two types of relators needed for the presentation:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Power relations (ex. &lt;code class="highlighter-rouge"&gt;x^re = x'&lt;/code&gt;)&lt;/li&gt;
  &lt;li&gt;Conjugate relations (ex. &lt;code class="highlighter-rouge"&gt;x[i]**-1*x[i+1]*x[i] = RHS and x[i]*x[i+1]*x[i]**-1 = RHS&lt;/code&gt;)&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;For every pair of generators we&amp;#8217;ll form above conjugate relations but the tough part is computing that &lt;code class="highlighter-rouge"&gt;RHS&lt;/code&gt; which should be collected and for now we don&amp;#8217;t have that much idea about how to get that RHS.&lt;/p&gt;

&lt;p&gt;But, let&amp;#8217;s hope that in upcoming days we&amp;#8217;ll be able to figure it out, till then Good byeee&amp;#8230;&lt;/p&gt;</description>
    </item>
    <item>
      <guid isPermaLink="false">http://ishanaj.wordpress.com/?p=54</guid>
      <author>Ishan Joshi (ishanaj)</author>
      <title>Ishan Joshi (ishanaj): GSoC&#x2019;19: Week-5 &#x2013; Moving on with a Non-mutable Column class</title>
      <pubDate>Sun, 30 Jun 2019 18:52:29 GMT</pubDate>
      <link>https://ishanaj.wordpress.com/2019/07/01/gsoc19-week-5-moving-on-with-a-non-mutable-column-class/</link>
      <description>&lt;p&gt;A lot of things happened this week and I am happy to inform you that &lt;a href="https://github.com/sympy/sympy/pull/17055"&gt;PR #17055&lt;/a&gt; has been successfully merged. The beam module now supports the cross-sectional shape of the beam as an alternative parameter to the second moment. With this, the aim of the stage-I to integrate the geometry module with beam module has been accomplished.&lt;/p&gt;
&lt;p&gt;Although we need to add some examples in the docs, to make it easier for the user to understand how to use this new feature.&lt;/p&gt;
&lt;p&gt;Coming on to stage-II, I had already, initiated a &lt;a href="https://github.com/sympy/sympy/issues/17072"&gt;discussion&lt;/a&gt; to finalize the API of the new Column class that is to be implemented as a part of the continuum mechanics module in this stage.&lt;/p&gt;
&lt;p&gt;We concluded that it would be much better if the Column class remains non-mutable i.e. unlike the beam class where a beam is formed in a piecewise form, the new Column class would take all its required input data during the declaration and then one can call different methods to calculate different things.&lt;/p&gt;
&lt;p&gt;I have made a &lt;a href="https://github.com/sympy/sympy/pull/17122"&gt;work-in-progress PR #17122&lt;/a&gt; implementing the Column class which performs the required buckling calculations. Currently, I have not included a method to calculate the critical load as there was a bit of problem with the form of the equation which the &lt;strong&gt;dsolve() &lt;/strong&gt;returns after solving the differential equation of buckling. &lt;a href="https://docs.sympy.org/latest/modules/solvers/ode.html" rel="noopener" target="_blank"&gt;&lt;strong&gt;dsolve(&lt;/strong&gt;)&lt;/a&gt; is SymPy&amp;#8217;s differential equation solver.&lt;/p&gt;
&lt;p&gt;In general, if we solve the general equation of buckling manually, we might apply the &lt;strong&gt;method of undetermined coefficients&lt;/strong&gt;, which of course even &lt;strong&gt;dsolve() &lt;/strong&gt;&amp;#160;is capable to apply, but it gives the answer in an exponent form, while we need it in a trigonometric form (for ease of further calculations). So after seeking different methods trying to convert this equation in terms of &lt;strong&gt;sin(x)&lt;/strong&gt; and &lt;strong&gt;cos(x), &lt;/strong&gt;I finally had to put that problem in the discussion, where Oscar Benjamin, gave an idea to declare the variables as positive in order to get it in terms of &lt;strong&gt;sin &lt;/strong&gt;and&lt;strong&gt; cos.&amp;#160;&lt;/strong&gt;I tried that it works well for our case. I will have to figure out the further calculation of the critical load.&lt;/p&gt;
&lt;p&gt;Hopefully will be updating the code with a new method to calculate critical load, soon.&lt;/p&gt;
&lt;p&gt;Also, I have planned to have a method to solve the &lt;strong&gt;unknown reactions&lt;/strong&gt; and &lt;strong&gt;reaction moments&lt;/strong&gt;, which would use the &lt;strong&gt;boundary conditions&lt;/strong&gt; to get their values.&lt;/p&gt;
&lt;p&gt;With all these things going on, this week we also had our first evaluations, and I am very happy to say that I have passed it. &lt;strong&gt;Thanks to the mentors!&lt;/strong&gt;&lt;/p&gt;
&lt;h2&gt;&lt;strong&gt;&amp;#160;&lt;/strong&gt;&lt;strong&gt;Next Week:&lt;/strong&gt;&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;Completing Column class with all its methods&lt;/li&gt;
&lt;li&gt;Adding tests and documentation.&lt;/li&gt;
&lt;li&gt;Starting discussions for the next stage.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;I will try to finish working on the Column class this weekend.&lt;/p&gt;
&lt;p&gt;Will keep you updated!&lt;/p&gt;
&lt;p&gt;Thanks!&lt;/p&gt;
&lt;p&gt;&amp;nbsp;&lt;/p&gt;</description>
    </item>
    <item>
      <guid isPermaLink="false">https://arighnaiitg.github.io/2019-06-30-gsoc-week5/</guid>
      <author>Arighna Chakrabarty (arighnaiitg)</author>
      <title>Arighna Chakrabarty (arighnaiitg): GSoC Week 5 !!</title>
      <pubDate>Sun, 30 Jun 2019 07:00:00 GMT</pubDate>
      <link>https://arighnaiitg.github.io/2019-06-30-gsoc-week5/</link>
      <description>&lt;p&gt;Week 5 ends.. - 
          Phase 2 of the coding period has started. This week has gone in wrapping up the left-over work of FormalPowerSeries. I had a meeting with Sartaj on Tuesday 25th of June, about the work left to be done on FormalPowerSeries module. We agreed that some minor changes need to be...</description>
    </item>
    <item>
      <guid isPermaLink="false">https://www.kangzhiq.com/?p=24</guid>
      <author>Zhiqi KANG (kangzhiq)</author>
      <title>Zhiqi KANG (kangzhiq): [GSoC 2019] WEEK 4 and 5!</title>
      <pubDate>Sat, 29 Jun 2019 02:40:07 GMT</pubDate>
      <link>https://www.kangzhiq.com/2019/06/29/gsoc-2019-week-4-and-5/</link>
      <description>&lt;p&gt;Hello, the first phase is ended and I am happy to pass the first evaluation. I was struggling with my academic projects and final exams during the last two weeks. After talking about my difficulty of spending time contributing on my project with my mentors, Francesco allowed me to have a one-week break in condition that I should make up one week in the next phases. The goal is to have 40 hours work per week on average by the end of this program.&lt;/p&gt;



&lt;p&gt;Thanks to the comprehension of my mentor, I could successfully pass the exams. I am going to work more over the second phase in order to have more contributions to the community. &lt;img alt="&amp;#128578;" class="wp-smiley" src="https://s.w.org/images/core/emoji/12.0.0-1/72x72/1f642.png" style="height: 1em;" /&gt;&lt;/p&gt;</description>
    </item>
    <item>
      <guid isPermaLink="false">https://jmig5776.github.io//gsoc-week-5</guid>
      <author>Jogi Miglani (jmig5776)</author>
      <title>Jogi Miglani (jmig5776): GSoC 2019 - Week 5</title>
      <pubDate>Sat, 29 Jun 2019 00:00:00 GMT</pubDate>
      <link>https://jmig5776.github.io//gsoc-week-5</link>
      <description>&lt;p&gt;This was the fifth week meeting with the GSoC mentors which was scheduled on
Saturday 29th June, 2019 between 11:30 - 12:30 PM (IST). Me, Yathartha and Amit
were the attendees of the meeting. I passed my first evaluation, Amit gave his
feedback and told me some very important points to take notes on. I do personally
believe that his suggestions are the best a mentor could gave to his student after
practicing his suggestions in my real life.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Discussing previous week&amp;#8217;s progress&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;In this meeting both mentors suggested me to work upon the code improvements and
documentation improvement. And make it more readable to user. ALthough somehow
@smichr had some doubts on the logic that we were implementing. Although a lot
of progress has been there. So I decided to create and discussion for thinking
new logic for implementing Lambert all solutions and work on the current PR as
goes on.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;Next week goals&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Improving existing PR for Lambert&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Improving &lt;code class="highlighter-rouge"&gt;_solve_modular&lt;/code&gt; PR also&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;If time left then find plan for Imageset Union.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Code improvement takes time!!&lt;/p&gt;</description>
    </item>
    <item>
      <guid isPermaLink="false">https://sc0rpi0n101.github.io/2019/06/week-5-the-evaluation-is-here-end-of-phase-1/</guid>
      <author>Nikhil Maan (Sc0rpi0n101)</author>
      <title>Nikhil Maan (Sc0rpi0n101): Week 5: The Evaluation is here: End of Phase 1</title>
      <pubDate>Sat, 29 Jun 2019 00:00:00 GMT</pubDate>
      <link>https://sc0rpi0n101.github.io/2019/06/week-5-the-evaluation-is-here-end-of-phase-1/</link>
      <description>&lt;p&gt;&amp;ldquo;On two occasions I have been asked [by members of Parliament!]: &amp;lsquo;Pray, Mr. Babbage, if you put into the machine wrong figures, will the right answers come out ?&amp;rsquo; I am not able rightly to apprehend the kind of confusion of ideas that could provoke such a question.&amp;rdquo; &amp;#8212; Charles Babbage
 Welcome everyone, this is your host Nikhil Maan aka Sc0rpi0n101 and this week was the last week of Phase-1 and the evaluations for the first phase.</description>
    </item>
    <item>
      <guid isPermaLink="false">https://anpandey.github.io/posts/sympy/2019-06-28-week-5.html</guid>
      <author>Ankit Pandey (anpandey)</author>
      <title>Ankit Pandey (anpandey): Google Summer of Code Week 5: Unification and Tensors</title>
      <pubDate>Fri, 28 Jun 2019 00:00:00 GMT</pubDate>
      <link>https://anpandey.github.io/posts/sympy/2019-06-28-week-5.html</link>
      <description>&lt;p&gt;&lt;em&gt;See the &lt;a href="https://anpandey.github.io/2019-06-21-weeks-3-and-4.html"&gt;previous post&lt;/a&gt; for Weeks 3 and 4&lt;/em&gt;.&lt;/p&gt;
&lt;p&gt;This week I&amp;#8217;ve been mostly doing background reading. This post is mostly a summary of what I learned.&lt;/p&gt;
&lt;h2 id="unification"&gt;Unification&lt;/h2&gt;
&lt;p&gt;In short, unification is the process of finding substitutions of variables within two terms two terms to make them identical. For example, if we have the expressions &lt;span class="math inline"&gt;&lt;em&gt;x&lt;/em&gt;&amp;#8197;+&amp;#8197;2&lt;em&gt;y&lt;/em&gt;&lt;/span&gt; and &lt;span class="math inline"&gt;&lt;em&gt;a&lt;/em&gt;&amp;#8197;+&amp;#8197;3&lt;em&gt;b&lt;/em&gt;&lt;/span&gt;, the substitution &lt;span class="math inline"&gt;{&lt;em&gt;x&lt;/em&gt;&amp;#8196;&amp;#8614;&amp;#8196;&lt;em&gt;a&lt;/em&gt;,&amp;#8198;&lt;em&gt;y&lt;/em&gt;&amp;#8196;&amp;#8614;&amp;#8196;3,&amp;#8198;&lt;em&gt;b&lt;/em&gt;&amp;#8196;&amp;#8614;&amp;#8196;2}&lt;/span&gt; is a unifier, since applying the substitution to both expressions makes gives us the identical expression of &lt;span class="math inline"&gt;&lt;em&gt;a&lt;/em&gt;&amp;#8197;+&amp;#8197;3&amp;#8197;&amp;#8901;&amp;#8197;2&lt;/span&gt;. While this particular substitution includes variables from both expressions, we&amp;#8217;re mostly interested in rules involving substitutions of variables from just one expression (a case of unification known as matching). Several well-known algorithms for unification already exist.&lt;/p&gt;
&lt;h3 id="unification-in-sympy"&gt;Unification in SymPy&lt;/h3&gt;
&lt;p&gt;SymPy also has an implementation of a unification algorithm that is able to take the commutativity of operations into account. Suppose we wanted to unify the matrix expressions &lt;span class="math inline"&gt;&lt;em&gt;A&lt;/em&gt;&lt;sup&gt;&lt;em&gt;T&lt;/em&gt;&lt;/sup&gt;&lt;em&gt;B&lt;/em&gt;&lt;sup&gt;2&lt;/sup&gt;&lt;em&gt;C&lt;/em&gt;&lt;sup&gt;&amp;#8197;&amp;#8722;&amp;#8197;1&lt;/sup&gt;&lt;/span&gt; and &lt;span class="math inline"&gt;&lt;em&gt;X&lt;/em&gt;&lt;em&gt;Y&lt;/em&gt;&lt;sup&gt;&amp;#8197;&amp;#8722;&amp;#8197;1&lt;/sup&gt;&lt;/span&gt;. This is essentially the problem of finding a substitution that makes these two expressions equal. Using the &lt;code&gt;sympy.unify.usympy&lt;/code&gt; module, we can discover what this substitution is:&lt;/p&gt;
&lt;div class="sourceCode" id="cb1"&gt;&lt;pre class="sourceCode python"&gt;&lt;code class="sourceCode python"&gt;&lt;a class="sourceLine" id="cb1-1" title="1"&gt;&lt;span class="op"&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class="im"&gt;from&lt;/span&gt; sympy.unify.usympy &lt;span class="im"&gt;import&lt;/span&gt; &lt;span class="op"&gt;*&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb1-2" title="2"&gt;&lt;span class="op"&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class="im"&gt;from&lt;/span&gt; sympy.abc &lt;span class="im"&gt;import&lt;/span&gt; N&lt;/a&gt;
&lt;a class="sourceLine" id="cb1-3" title="3"&gt;&lt;span class="op"&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt; m &lt;span class="op"&gt;=&lt;/span&gt; &lt;span class="kw"&gt;lambda&lt;/span&gt; x: MatrixSymbol(x, N, N)&lt;/a&gt;
&lt;a class="sourceLine" id="cb1-4" title="4"&gt;&lt;span class="op"&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt; A, B, C, X, Y &lt;span class="op"&gt;=&lt;/span&gt; &lt;span class="bu"&gt;map&lt;/span&gt;(m, [&lt;span class="st"&gt;'A'&lt;/span&gt;, &lt;span class="st"&gt;'B'&lt;/span&gt;, &lt;span class="st"&gt;'X'&lt;/span&gt;, &lt;span class="st"&gt;'Y'&lt;/span&gt;])&lt;/a&gt;
&lt;a class="sourceLine" id="cb1-5" title="5"&gt;&lt;span class="op"&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt; e1 &lt;span class="op"&gt;=&lt;/span&gt; A.T &lt;span class="op"&gt;*&lt;/span&gt; B&lt;span class="op"&gt;**&lt;/span&gt;&lt;span class="dv"&gt;2&lt;/span&gt; &lt;span class="op"&gt;*&lt;/span&gt; C.I&lt;/a&gt;
&lt;a class="sourceLine" id="cb1-6" title="6"&gt;&lt;span class="op"&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt; e2 &lt;span class="op"&gt;=&lt;/span&gt; X &lt;span class="op"&gt;*&lt;/span&gt; Y &lt;span class="op"&gt;**&lt;/span&gt;(&lt;span class="op"&gt;-&lt;/span&gt;&lt;span class="dv"&gt;1&lt;/span&gt;)&lt;/a&gt;
&lt;a class="sourceLine" id="cb1-7" title="7"&gt;&lt;span class="op"&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class="bu"&gt;next&lt;/span&gt;(unify(e1, e2, variables&lt;span class="op"&gt;=&lt;/span&gt;[X, Y]))&lt;/a&gt;
&lt;a class="sourceLine" id="cb1-8" title="8"&gt;{X: A.T&lt;span class="op"&gt;*&lt;/span&gt;B&lt;span class="op"&gt;**&lt;/span&gt;&lt;span class="dv"&gt;2&lt;/span&gt;, Y: C}&lt;/a&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;We&amp;#8217;ve reduced this to a matching problem in which the variables are specified only in &lt;code&gt;e2&lt;/code&gt;. What&amp;#8217;s important to note here is that the matching rule within &lt;code&gt;e2&lt;/code&gt; we specified (&lt;span class="math inline"&gt;&lt;em&gt;X&lt;/em&gt;&lt;em&gt;Y&lt;/em&gt;&lt;sup&gt;&amp;#8197;&amp;#8722;&amp;#8197;1&lt;/sup&gt;&lt;/span&gt;) was a compound expression. This is something that is currently not possible for non-commutative expressions (such as matrix multiplication) using SymPy&amp;#8217;s &lt;code&gt;Wild&lt;/code&gt; interface. &lt;code&gt;unify&lt;/code&gt; allows use to express substitution rules that are able to match across sub-expressions in matrix multiplication.&lt;/p&gt;
&lt;p&gt;Through unification, we can express substitution rules for optimization as a simple term-rewriting rule. In my previous blog post, I mentioned rewriting the matrix multiplication &lt;span class="math inline"&gt;&lt;em&gt;A&lt;/em&gt;&lt;em&gt;x&lt;/em&gt;&lt;/span&gt; as a solving operation of &lt;code&gt;MatSolve(A, x)&lt;/code&gt; under certain assumptions. The actual implementation is restricted to cases where both the &lt;code&gt;A&lt;/code&gt; and the &lt;code&gt;x&lt;/code&gt; are matrix symbols, and the optimization can&amp;#8217;t identify cases where either the &lt;code&gt;A&lt;/code&gt; or the &lt;code&gt;x&lt;/code&gt; is a compound expression. With unification, we can identify the same pattern in more complex subexpressions. If we&amp;#8217;re given the matrix expression &lt;span class="math inline"&gt;&lt;em&gt;A&lt;/em&gt;&lt;sup&gt;&lt;em&gt;T&lt;/em&gt;&lt;/sup&gt;(&lt;em&gt;A&lt;/em&gt;&lt;em&gt;B&lt;/em&gt;)&lt;sup&gt;&amp;#8197;&amp;#8722;&amp;#8197;1&lt;/sup&gt;&lt;em&gt;x&lt;/em&gt;&lt;em&gt;y&lt;/em&gt;&lt;/span&gt;, a unification based transformer can produce &lt;code&gt;MatSolve(AB, x)&lt;/code&gt;, provided that the shapes of the matrices match the given rule.&lt;/p&gt;
&lt;h2 id="codegen-tensors"&gt;Codegen Tensors&lt;/h2&gt;
&lt;p&gt;I also looked into generating C and Fortran code from SymPy matrix expressions. For the purposes of code generation, SymPy has a relatively new &lt;code&gt;array_utils&lt;/code&gt; module. The AST nodes in this module express generalizations of operations on matrices, which require a bit of background in tensors.&lt;/p&gt;
&lt;p&gt;Many array operations (including matrix multiplication) involve &lt;em&gt;contraction&lt;/em&gt; along an axis. Contractions are a combination of multiplication and summation along certain axis of a tensor&lt;a class="footnote-ref" href="https://anpandey.github.io/atom-sympy.xml#fn1" id="fnref1"&gt;&lt;sup&gt;1&lt;/sup&gt;&lt;/a&gt;. In assigning the matrix multiplication &lt;span class="math inline"&gt;&lt;em&gt;A&lt;/em&gt;&lt;em&gt;B&lt;/em&gt;&lt;/span&gt; to the &lt;span class="math inline"&gt;&lt;em&gt;n&lt;/em&gt;&amp;#8197;&amp;#215;&amp;#8197;&lt;em&gt;n&lt;/em&gt;&lt;/span&gt; matrix &lt;span class="math inline"&gt;&lt;em&gt;C&lt;/em&gt;&lt;/span&gt;, we can explicitly write the summations (using subscripts for indexing matrix elements) as&lt;/p&gt;
&lt;p&gt;&lt;br /&gt;&lt;span class="math display"&gt;$$C_{ik} = \sum_{j = 1}^{n} A_{ij} B_{jk}$$&lt;/span&gt;&lt;br /&gt;&lt;/p&gt;
&lt;p&gt;The index &lt;span class="math inline"&gt;&lt;em&gt;j&lt;/em&gt;&lt;/span&gt; is contracted, as it is shared between both &lt;span class="math inline"&gt;&lt;em&gt;A&lt;/em&gt;&lt;/span&gt; and &lt;span class="math inline"&gt;&lt;em&gt;B&lt;/em&gt;&lt;/span&gt;, and describing this summation operation as a whole boils down to which indices are shared between the matrices. This is essentially what the &lt;code&gt;array_utils&lt;/code&gt; classes do. This is what happens when we use &lt;code&gt;array_utils&lt;/code&gt; to convert the matrix multiplication to an equivalent contraction operation:&lt;/p&gt;
&lt;div class="sourceCode" id="cb2"&gt;&lt;pre class="sourceCode python"&gt;&lt;code class="sourceCode python"&gt;&lt;a class="sourceLine" id="cb2-1" title="1"&gt;&lt;span class="op"&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class="im"&gt;from&lt;/span&gt; sympy.codegen.array_utils &lt;span class="im"&gt;import&lt;/span&gt; CodegenArrayContraction&lt;/a&gt;
&lt;a class="sourceLine" id="cb2-2" title="2"&gt;&lt;span class="op"&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class="im"&gt;from&lt;/span&gt; sympy.abc &lt;span class="im"&gt;import&lt;/span&gt; N&lt;/a&gt;
&lt;a class="sourceLine" id="cb2-3" title="3"&gt;&lt;span class="op"&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt; A &lt;span class="op"&gt;=&lt;/span&gt; MatrixSymbol(&lt;span class="st"&gt;'A'&lt;/span&gt;, N, N)&lt;/a&gt;
&lt;a class="sourceLine" id="cb2-4" title="4"&gt;&lt;span class="op"&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt; B &lt;span class="op"&gt;=&lt;/span&gt; MatrixSymbol(&lt;span class="st"&gt;'B'&lt;/span&gt;, N, N)&lt;/a&gt;
&lt;a class="sourceLine" id="cb2-5" title="5"&gt;&lt;span class="op"&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt; CodegenArrayContraction.from_MatMul(A &lt;span class="op"&gt;*&lt;/span&gt; B)&lt;/a&gt;
&lt;a class="sourceLine" id="cb2-6" title="6"&gt;CodegenArrayContraction(CodegenArrayTensorProduct(A, B), (&lt;span class="dv"&gt;1&lt;/span&gt;, &lt;span class="dv"&gt;2&lt;/span&gt;))&lt;/a&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;We&amp;#8217;re given a new&lt;code&gt;CodegenArrayContraction&lt;/code&gt; object that stores, along with the variables &lt;code&gt;A&lt;/code&gt; and &lt;code&gt;B&lt;/code&gt;, tuples of integers representing contractions along certain indices. Here, the &lt;code&gt;(1, 2)&lt;/code&gt; means that the variable at index 1 and index 2 (indices start at 0) are shared. We can confirm this by looking at the above summation, since both the second and third indices out of all indices that appear in the expression are &lt;span class="math inline"&gt;&lt;em&gt;j&lt;/em&gt;&lt;/span&gt;.&lt;/p&gt;
&lt;h2 id="next-steps"&gt;Next Steps&lt;/h2&gt;
&lt;p&gt;For next week, I&amp;#8217;ll try to re-implement the rewriting optimization in terms of &lt;code&gt;unify&lt;/code&gt;. This will both make it easier to express rules and extend to sub-expressions as well. I&amp;#8217;ll also start with implementing additional printers for the C and Fortran printers. The printer will probably just print naive &lt;code&gt;for&lt;/code&gt; loops to keep things simple (and it would probaly be better to use something like Theano for highly optimized code).&lt;/p&gt;
&lt;section class="footnotes"&gt;
&lt;hr /&gt;
&lt;ol&gt;
&lt;li id="fn1"&gt;&lt;p&gt;For our purposes, we can think of tensors as just &lt;span class="math inline"&gt;&lt;em&gt;n&lt;/em&gt;&lt;/span&gt;-dimensional arrays. Most of my reading on tensors was Justin C. Feng&amp;#8217;s &lt;a href="https://justincfeng.github.io/Tensors_Poor_Man.pdf"&gt;The Poor Man&amp;#8217;s Introduction to Tensors&lt;/a&gt;.&lt;a class="footnote-back" href="https://anpandey.github.io/atom-sympy.xml#fnref1"&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;/section&gt;</description>
    </item>
    <item>
      <guid isPermaLink="false">https://divyanshu132.github.io//gsoc-week-4</guid>
      <author>Divyanshu Thakur (divyanshu132)</author>
      <title>Divyanshu Thakur (divyanshu132): GSoC 2019 - Week 4 - Phase-I Completion</title>
      <pubDate>Mon, 24 Jun 2019 00:00:00 GMT</pubDate>
      <link>https://divyanshu132.github.io//gsoc-week-4</link>
      <description>&lt;p&gt;The fourth week of coding period has ended and now it&amp;#8217;s time for phase-I evaluations. Below, is a brief progress report of the project.&lt;/p&gt;

&lt;p&gt;The tasks that were proposed in the proposal for phase-I consists of:&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;Implementation of Abelian Invariants&lt;/li&gt;
  &lt;li&gt;Implementation of Composition Series&lt;/li&gt;
  &lt;li&gt;Computation with Polycyclic groups&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;Abelian Invariants&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;Implemented a function to compute the abelian invariants for a given permutation or free group. These are given as a list of prime-powers and describe the stucture of &lt;code class="highlighter-rouge"&gt;G/G'&lt;/code&gt; as a direct product of cyclic groups of prime power order.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;PR link &lt;a href="https://github.com/sympy/sympy/pull/16670"&gt;Added method to calculate Abelian Invariants&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;Composition Series&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;Implemented a function to compute the composition series. It provides a way to break up a group into simple pieces. Composition series of a group &lt;code class="highlighter-rouge"&gt;G&lt;/code&gt; is defined as the maximal subnormal series &lt;code class="highlighter-rouge"&gt;G = H_0 &amp;gt; H_1 &amp;gt; H_2 ... &amp;gt; H_k = 1&lt;/code&gt; where every factor group &lt;code class="highlighter-rouge"&gt;H(i+1)/H(i)&lt;/code&gt; is simple.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;PR link &lt;a href="https://github.com/sympy/sympy/pull/16881"&gt;Added method for Composition Series computation&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;Polycyclic Groups&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;The work on polycyclic group is in progress. For now, collection algorithm has been implemented which needs to be tested and a lot of discussions were made on the polycyclic generating sequence and its presentation and may be in a week we&amp;#8217;ll be ready with the stucture of polycyclic groups and collection of words.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;PR link &lt;a href="https://github.com/sympy/sympy/pull/16991"&gt;Added Polycyclic Group Class&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;Documentation&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;Some documentation is done to increase the sphinx coverage of SymPy.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;PR link &lt;a href="https://github.com/sympy/sympy/pull/16809"&gt;Increase Accessibility of docstrings from Sphinx&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;To follow the discussion on above topics and the further progress of the project one can check Gitter room &lt;a href="https://gitter.im/sympy/GroupTheory"&gt;sympy/GroupTheory&lt;/a&gt;&lt;/p&gt;</description>
    </item>
    <item>
      <guid isPermaLink="false">https://shubhamkjha.github.io/2019/06/24/GSoC-2019-Week-4</guid>
      <author>Shubham Kumar Jha (ShubhamKJha)</author>
      <title>Shubham Kumar Jha (ShubhamKJha): GSoC 2019: Week 4</title>
      <pubDate>Mon, 24 Jun 2019 00:00:00 GMT</pubDate>
      <link>https://shubhamkjha.github.io/2019/06/24/GSoC-2019-Week-4.html</link>
      <description>&lt;p&gt;With this the fourth week and the first phase of GSoC 2019 is over. Here I will give you a brief summary of my progress this week.&lt;/p&gt;

&lt;p&gt;I started this week by setting up my workspace for profiling the code related to new assumptions. I am using &lt;code class="highlighter-rouge"&gt;pyinstrument&lt;/code&gt; for that. The results of profiler suggests that a significant amount of time is spent in the &lt;code class="highlighter-rouge"&gt;to_cnf()&lt;/code&gt; function which converts the logical expression into their CNF counterparts, to be used by the SAT solver. Also, since this system is built over the SymPy core, a large amount of this time is spent in the core itself (See the graph &lt;a href="https://github.com/sympy/sympy/issues/17066#issuecomment-504774120"&gt;here&lt;/a&gt;). A possible solution to this is to use constructs at a level lower than the SymPy objects, hence removing the overheads.&lt;/p&gt;

&lt;p&gt;Also, as suggested in the last blog, there are various ideas proposed for improving the new assumptions mechanism. Some of them have been implemented to some extent in some PRs. Before proceeding for any new strategies, I need to look into these ideas first. I have started an &lt;a href="https://github.com/sympy/sympy/issues/17066"&gt;issue-tree&lt;/a&gt; to gather them.&lt;/p&gt;

&lt;p&gt;Over the end of the week, I also pushed my work on &lt;code class="highlighter-rouge"&gt;First Order Logic&lt;/code&gt; module at &lt;a href="https://github.com/sympy/sympy/pull/17069"&gt;#17069&lt;/a&gt;. This work is based on &lt;a href="https://github.com/sympy/sympy/pull/7608"&gt;#7608&lt;/a&gt; and extends it by adding &lt;code class="highlighter-rouge"&gt;Equality&lt;/code&gt; to it. Currently, there are test failures and some points to decide. I will try to get it done within this week.&lt;/p&gt;

&lt;p&gt;I spent most of this week exploring the profiling and benchmarking of code, and I learnt a lot during this. For the coming week, I will focus on speeding up the code in &lt;code class="highlighter-rouge"&gt;to_cnf&lt;/code&gt;. As suggested by Aaron, &lt;a href="https://github.com/sympy/sympy/pull/11789"&gt;this&lt;/a&gt; seems a good point to start with. Also, I will be working on the &lt;code class="highlighter-rouge"&gt;FOL&lt;/code&gt; module.&lt;/p&gt;</description>
    </item>
    <item>
      <guid isPermaLink="false">http://ishanaj.wordpress.com/?p=52</guid>
      <author>Ishan Joshi (ishanaj)</author>
      <title>Ishan Joshi (ishanaj): GSoC&#x2019;19: Week-4-Starting with Column Buckling implementation</title>
      <pubDate>Sun, 23 Jun 2019 18:41:36 GMT</pubDate>
      <link>https://ishanaj.wordpress.com/2019/06/24/gsoc19-week-4-starting-with-column-buckling-implementation/</link>
      <description>&lt;p&gt;Finalizing what had been discussed in &lt;a href="https://github.com/sympy/sympy/pull/16964"&gt;PR #16964&lt;/a&gt; for integrating geometry module with the beam module,&lt;a href="https://github.com/sympy/sympy/pull/17055"&gt; PR #17055&lt;/a&gt; was opened which is now ready to go!&lt;/p&gt;
&lt;p&gt;There is no special function for defining the cross-section of a Beam object. A user can simply pass the geometry object as a parameter instead of the &lt;strong&gt;second_moment, &lt;/strong&gt;and the corresponding second moment would be calculated internally. The example below might explain this better:&lt;/p&gt;
&lt;pre class="brush: python; collapse: false; title: ; wrap-lines: false; notranslate"&gt;

&amp;gt;&amp;gt;&amp;gt; b = Beam(l, E, Circle((0, 0), r))

&amp;gt;&amp;gt;&amp;gt; b.second_moment

pi*r*Abs(r)**3/4

&amp;gt;&amp;gt;&amp;gt; b.cross_section

Circle(Point2D(0, 0), r)

&lt;/pre&gt;
&lt;p&gt;Further, the &lt;strong&gt;cross_section&lt;/strong&gt; attribute can be changed even after the beam is created. Every time the &lt;strong&gt;cross_section&lt;/strong&gt; is assigned a new value, the &lt;strong&gt;second_moment&lt;/strong&gt; gets automatically updated.&lt;/p&gt;
&lt;p&gt;Similarly, every time the user changes the &lt;strong&gt;second_moment&lt;/strong&gt; explicitly after the creation of the beam, the previous &lt;strong&gt;cross_section&lt;/strong&gt; gets destroyed, or in other words, the &lt;strong&gt;cross_section&lt;/strong&gt; is set to None.&lt;/p&gt;
&lt;pre class="brush: python; collapse: false; title: ; wrap-lines: false; notranslate"&gt;

&amp;gt;&amp;gt;&amp;gt; b = Beam(l, E, Circle((0, 0), r))

&amp;gt;&amp;gt;&amp;gt; I&amp;#160; = Symbol(&amp;#8216;I&amp;#8217;)

&amp;gt;&amp;gt;&amp;gt; b.second_moment = I

&amp;gt;&amp;gt;&amp;gt; b.cross_section

None

&amp;gt;&amp;gt;&amp;gt; b.second_moment = Polygon((0, 0), (a, 0), (a, b), (0, b))

ValueError: To update cross-section geometry use `cross_section` attribute

&lt;/pre&gt;
&lt;p&gt;The PR is complete and just needs the final approval from the mentors.&lt;/p&gt;
&lt;p&gt;Simultaneously, I had worked on the column buckling calculations which is a part of the stage &amp;#8211;II.&lt;/p&gt;
&lt;p&gt;I have opened an &lt;a href="https://github.com/sympy/sympy/issues/17072"&gt;issue-cum-discussion&lt;/a&gt; for discussing its API and further implementations.&lt;/p&gt;
&lt;p&gt;Since the calculations of the Column Buckling are very much different from those of beam bending, we will have to make a separate class Column. The basic API and the way the calculations are supposed to go can be seen from the stage &amp;#8211;II in the &lt;a href="https://docs.google.com/document/d/1LOtMTr9cCrzQ8_OnKrgkZs8wFS9N9PxlR10h3aKG0jg/edit?usp=sharing"&gt;proposal&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;I would be making a PR for column buckling calculations within a day or two, once some initial questions (as mentioned in the issue-cum-discussion) gets clarified.&lt;/p&gt;
&lt;h2&gt;Next Week:&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;Finalizing the basic API and implementations of Column class&lt;/li&gt;
&lt;li&gt;Making a PR for the above implementations&lt;/li&gt;
&lt;li&gt;Documentation and testing&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Will keep you updated!&lt;/p&gt;
&lt;p&gt;Thanks!&lt;/p&gt;</description>
    </item>
    <item>
      <guid isPermaLink="false">https://arighnaiitg.github.io/2019-06-23-gsoc-week4/</guid>
      <author>Arighna Chakrabarty (arighnaiitg)</author>
      <title>Arighna Chakrabarty (arighnaiitg): GSoC Week 4 !!</title>
      <pubDate>Sun, 23 Jun 2019 07:00:00 GMT</pubDate>
      <link>https://arighnaiitg.github.io/2019-06-23-gsoc-week4/</link>
      <description>&lt;p&gt;Week 4 ends.. - 
          Week 4 and the final week of the first phase of the Coding Period is coming to an end. The work, which was initially proposed to be done in FormalPowerSeries has been done on a term-by-term level, i.e. the operations which have been implemented return truncated terms of the resultant...</description>
    </item>
    <item>
      <guid isPermaLink="false">https://czgdp1807.github.io/week_4</guid>
      <author>Gagandeep Singh (czgdp1807)</author>
      <title>Gagandeep Singh (czgdp1807): Week 4 - Phase 1 Ends</title>
      <pubDate>Sun, 23 Jun 2019 00:00:00 GMT</pubDate>
      <link>https://czgdp1807.github.io/week_4/</link>
      <description>&lt;p&gt;So, with the fourth week, the first phase of my journey with &lt;code class="highlighter-rouge"&gt;SymPy&lt;/code&gt; has come to an end. This blog post summarises the work done till now, in terms of PRs. Moreover, I will share with you the plans for phase 2.&lt;/p&gt;

&lt;p&gt;I worked on the following PRs(listed in chronological order) during the first phase, many of them got merged and few are open.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Merged&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href="https://github.com/sympy/sympy/pull/16528"&gt;#16528&lt;/a&gt; : I worked on extending the &lt;code class="highlighter-rouge"&gt;GumbelDistribution&lt;/code&gt; to  support both minimum and maximum versions of it.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href="https://github.com/sympy/sympy/pull/16576"&gt;#16576&lt;/a&gt;: This PR added &lt;code class="highlighter-rouge"&gt;Dirichlet&lt;/code&gt; and &lt;code class="highlighter-rouge"&gt;MultivariteEwens&lt;/code&gt; distributions.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href="https://github.com/sympy/sympy/pull/16808"&gt;#16808&lt;/a&gt; : This PR added &lt;code class="highlighter-rouge"&gt;Multinomial&lt;/code&gt; and &lt;code class="highlighter-rouge"&gt;NegativeMultinomial&lt;/code&gt; distribution.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href="https://github.com/sympy/sympy/pull/16810"&gt;#16810&lt;/a&gt; : This PR improved the API of &lt;code class="highlighter-rouge"&gt;Sum&lt;/code&gt; by allowing &lt;code class="highlighter-rouge"&gt;Range&lt;/code&gt; as the limits.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href="https://github.com/sympy/sympy/pull/16825"&gt;#16825&lt;/a&gt; : This PR in continuation, added &lt;code class="highlighter-rouge"&gt;GeneralizedMultivariateLogGamma&lt;/code&gt; distribution. This was an interesting one due to the complexity involved in its PDF.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href="https://github.com/sympy/sympy/pull/16834"&gt;#16834&lt;/a&gt; : This PR enhanced the &lt;code class="highlighter-rouge"&gt;Multinomial&lt;/code&gt; and &lt;code class="highlighter-rouge"&gt;NegativeMultinomial&lt;/code&gt; distributions by allowing symbolic dimensions for them.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href="https://github.com/sympy/sympy/pull/16897"&gt;#16897&lt;/a&gt; : This was related to &lt;code class="highlighter-rouge"&gt;sympy.core&lt;/code&gt; and it helped in removing disparity in the results of special function &lt;code class="highlighter-rouge"&gt;gamma&lt;/code&gt;.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href="https://github.com/sympy/sympy/pull/16899"&gt;#16899&lt;/a&gt; : This was a workflow related to PR to ignore the &lt;code class="highlighter-rouge"&gt;.vscode&lt;/code&gt; folder.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href="https://github.com/sympy/sympy/pull/16908"&gt;#16908&lt;/a&gt; : This PR improved &lt;code class="highlighter-rouge"&gt;sympy.stats.frv&lt;/code&gt; by allowing conditions with foriegn symbols.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href="https://github.com/sympy/sympy/pull/16913"&gt;#16913&lt;/a&gt; : This removed the unreachable code from &lt;code class="highlighter-rouge"&gt;sympy.stats.frv&lt;/code&gt;.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href="https://github.com/sympy/sympy/pull/16914"&gt;#16914&lt;/a&gt; : This PR allowed symbolic dimensions to &lt;code class="highlighter-rouge"&gt;MultivariateEwens&lt;/code&gt; distribution.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href="https://github.com/sympy/sympy/pull/16929"&gt;#16929&lt;/a&gt; : This one was for the &lt;code class="highlighter-rouge"&gt;sympy.tensor&lt;/code&gt; module. It optimized the &lt;code class="highlighter-rouge"&gt;ArrayComprehension&lt;/code&gt; and covered some corner cases.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href="https://github.com/sympy/sympy/pull/16981"&gt;#16981&lt;/a&gt; : This PR added the architecture of stochastic processes. It also added discrete Markov chain to &lt;code class="highlighter-rouge"&gt;sympy.stats&lt;/code&gt;.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href="https://github.com/sympy/sympy/pull/17003"&gt;#17003&lt;/a&gt; : This PR ignored the &lt;code class="highlighter-rouge"&gt;__pycahce__&lt;/code&gt; folder by adding it &lt;code class="highlighter-rouge"&gt;.gitignore&lt;/code&gt; file.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href="https://github.com/sympy/sympy/pull/17030"&gt;#17030&lt;/a&gt; : Some features like, &lt;code class="highlighter-rouge"&gt;joint_dsitribution&lt;/code&gt; were added in this PR.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href="https://github.com/sympy/sympy/pull/17046"&gt;#17046&lt;/a&gt; : Some common properties of discrete Markov chains, like fundamental matrix, fixed row vector were added.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;Open&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href="https://github.com/sympy/sympy/pull/16962"&gt;#16962&lt;/a&gt; : The aim of this PR is to allow symbolic dimensions to single finite distributions, like &lt;code class="highlighter-rouge"&gt;Die&lt;/code&gt;, &lt;code class="highlighter-rouge"&gt;Binomial&lt;/code&gt;. The work from my side is complete on this.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href="https://github.com/sympy/sympy/pull/16934"&gt;#16934&lt;/a&gt; : This PR aims to fix the bugs and test the code introduced in &lt;code class="highlighter-rouge"&gt;GSoC&lt;/code&gt; 2018.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Apart from the above PRs I also reviewed code written by other contributors.
Overall, according to me phase 1 was a great learning and working experience.&lt;/p&gt;

&lt;p&gt;Let me share with you my plan for phase 2. Since, I will be working on random matrices during the upcoming phase, I have started the discussions for design with my mentors and things are taking shape. However, apart from random matrices, I will also work on few more general improvements for my phase 1 work.&lt;/p&gt;

&lt;p&gt;The outline is given below,&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;I will work on extending the scope of queries handeled by discrete Markov chains by covering some uncommon cases.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Some work will be done to extend the &lt;code class="highlighter-rouge"&gt;DiscreteMarkovChain&lt;/code&gt; by adding &lt;code class="highlighter-rouge"&gt;ContinuousMarkovChain&lt;/code&gt; as the latter is almost same but with some extra parameters.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;I will implement random matrices and its various Gaussian ensembles according to the conclusion of the design discussions.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Last but not the least, I will try to merge my open PRs.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;Thanks for reading and see you soon in phase 2. Bye!!&lt;/p&gt;</description>
    </item>
    <item>
      <guid isPermaLink="false">https://ritesh99rakesh.github.io/Sympy_post6</guid>
      <author>Ritesh Kumar (ritesh99rakesh)</author>
      <title>Ritesh Kumar (ritesh99rakesh): Week 4</title>
      <pubDate>Sun, 23 Jun 2019 00:00:00 GMT</pubDate>
      <link>https://ritesh99rakesh.github.io/Sympy_post6/</link>
      <description>&lt;p&gt;Phase I has ended and here are the details of the PRs I have raised: #16935 #16843 #16848 #16858 #16886 #16888 #16970 #17004 #17033 #17036 #17068 #17070 #17076 #17077 Many of the above PRs are merged and some are open. I will work to get other merged. My plan for second phase: Complete the sampling method and finish the exporting of random variables to external libraries. I will work on Compound distributions and will finish it in the phase 2. I will add Wishart and Inverse Wishart distributions after multigamma function is merged. I will also discuss the implementation of Random Walks and will start working on the PR. This phase was a great learning experience. That&amp;#8217;s all from my side. Namaste!</description>
    </item>
    <item>
      <guid isPermaLink="false">https://jmig5776.github.io//gsoc-week-4</guid>
      <author>Jogi Miglani (jmig5776)</author>
      <title>Jogi Miglani (jmig5776): GSoC 2019 - Week 4</title>
      <pubDate>Sat, 22 Jun 2019 00:00:00 GMT</pubDate>
      <link>https://jmig5776.github.io//gsoc-week-4</link>
      <description>&lt;p&gt;This was the fourth week meeting with the GSoC mentors which was scheduled on
Sunday 22th June, 2019 between 12:30 - 01:30 PM (IST). Me and Yathartha
were the attendees of the meeting.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Discussing previous week&amp;#8217;s progress&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;In the previous week many things happened very suddenly. In the starting of the
week it was decided that we had to create a function &lt;code class="highlighter-rouge"&gt;power_list&lt;/code&gt; which could
return powers. So I thought to create this type of function as a new feature in
this PR &lt;a href="https://github.com/sympy/sympy/pull/17043"&gt;#17043&lt;/a&gt;.
But as @jksoum and @smichr advised that this function can act as
helper function in &lt;code class="highlighter-rouge"&gt;bivariate&lt;/code&gt; itself so it was decided to make it as helper
function there. And we discussed the code for handling modular equations also.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;Next week goals&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Implementing and get plan for defining imageset union&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;As per the timeline we decided that Imageset Union should be defined first rather
than code for handling nested trigonometric equation solver. So according to
timeline this week goes for discussion and getting plan for implementing imageset
union. A PR &lt;a href="https://github.com/sympy/sympy/pull/17079"&gt;#17079&lt;/a&gt; is also started
based on fundamental approach to solve the problem.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Getting merge Lambert Solver&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Most of the work had been done only a little improvement is to be done in &lt;code class="highlighter-rouge"&gt;power_list&lt;/code&gt;
function. Hope it gets merged by this week.&lt;/p&gt;

&lt;p&gt;Code improvement takes time!!&lt;/p&gt;</description>
    </item>
    <item>
      <guid isPermaLink="false">https://sc0rpi0n101.github.io/2019/06/week-4-the-fortran-parser-is-finally-here/</guid>
      <author>Nikhil Maan (Sc0rpi0n101)</author>
      <title>Nikhil Maan (Sc0rpi0n101): Week 4: The Fortran Parser is finally here</title>
      <pubDate>Sat, 22 Jun 2019 00:00:00 GMT</pubDate>
      <link>https://sc0rpi0n101.github.io/2019/06/week-4-the-fortran-parser-is-finally-here/</link>
      <description>&lt;p&gt;&amp;ldquo;When someone says: &amp;lsquo;I want a programming language in which I need only say what I wish done&amp;rsquo;, give him a lollipop.&amp;rdquo;  &amp;#8212; Alan J. Perlis in Software Metrics
 Welcome everyone, this is your host Nikhil Maan aka Sc0rpi0n101 and this week has been relatively a little odd. The week started a little slow but slowly it turned out to be a good and productive week.</description>
    </item>
    <item>
      <guid isPermaLink="false">https://anpandey.github.io/posts/sympy/2019-06-21-weeks-3-and-4.html</guid>
      <author>Ankit Pandey (anpandey)</author>
      <title>Ankit Pandey (anpandey): Google Summer of Code Weeks 3 and 4: Matrix Optimizations</title>
      <pubDate>Fri, 21 Jun 2019 00:00:00 GMT</pubDate>
      <link>https://anpandey.github.io/posts/sympy/2019-06-21-weeks-3-and-4.html</link>
      <description>&lt;p&gt;&lt;em&gt;See the &lt;a href="https://anpandey.github.io/2019-06-07-week-2.html"&gt;previous post&lt;/a&gt; for Week 2&lt;/em&gt;.&lt;/p&gt;
&lt;p&gt;I spent a large part of last week travelling, so I&amp;#8217;m combining the blog posts for the last two weeks.&lt;/p&gt;
&lt;h2 id="finishing-up-with-lfortran"&gt;Finishing up with LFortran&lt;/h2&gt;
&lt;p&gt;I&amp;#8217;m finished with the &lt;a href="https://github.com/sympy/sympy/pull/16931"&gt;pull request&lt;/a&gt; for the LFortran code printer for now, though it&amp;#8217;s definitely way too incomplete to be merged. The code passes &lt;em&gt;most&lt;/em&gt; of the rudimentary tests I&amp;#8217;ve added.&lt;/p&gt;
&lt;p&gt;Here&amp;#8217;s a simple example of one of the failing LFortran tests: Suppose we want to generate Fortran (using LFortran) code from the mathematical expression &lt;span class="math inline"&gt;&amp;#8197;&amp;#8722;&amp;#8197;&lt;em&gt;x&lt;/em&gt;&lt;/span&gt;. SymPy sees this expression as multiplication with -1, as it implements only addition and multiplication in its arithmetic operations:&lt;/p&gt;
&lt;div class="sourceCode" id="cb1"&gt;&lt;pre class="sourceCode python"&gt;&lt;code class="sourceCode python"&gt;&lt;a class="sourceLine" id="cb1-1" title="1"&gt;&lt;span class="op"&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class="im"&gt;from&lt;/span&gt; sympy &lt;span class="im"&gt;import&lt;/span&gt; &lt;span class="op"&gt;*&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb1-2" title="2"&gt;&lt;span class="op"&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt; x &lt;span class="op"&gt;=&lt;/span&gt; Symbol(&lt;span class="st"&gt;'x'&lt;/span&gt;)&lt;/a&gt;
&lt;a class="sourceLine" id="cb1-3" title="3"&gt;&lt;span class="op"&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt; srepr(&lt;span class="op"&gt;-&lt;/span&gt;x)&lt;/a&gt;
&lt;a class="sourceLine" id="cb1-4" title="4"&gt;&lt;span class="co"&gt;&amp;quot;Mul(Integer(-1), Symbol('x'))&amp;quot;&lt;/span&gt;&lt;/a&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Directly converting same mathematical expression in Fortran as &lt;code&gt;-x&lt;/code&gt; we can see that LFortran instead sees it as unary subtraction:&lt;/p&gt;
&lt;div class="sourceCode" id="cb2"&gt;&lt;pre class="sourceCode python"&gt;&lt;code class="sourceCode python"&gt;&lt;a class="sourceLine" id="cb2-1" title="1"&gt;&lt;span class="op"&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class="im"&gt;from&lt;/span&gt; lfortran &lt;span class="im"&gt;import&lt;/span&gt; &lt;span class="op"&gt;*&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb2-2" title="2"&gt;&lt;span class="op"&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt; src_to_ast(&lt;span class="st"&gt;&amp;quot;-x&amp;quot;&lt;/span&gt;, &lt;span class="va"&gt;False&lt;/span&gt;)&lt;/a&gt;
&lt;a class="sourceLine" id="cb2-3" title="3"&gt;&lt;span class="op"&gt;&amp;lt;&lt;/span&gt;lfortran.ast.ast.UnaryOp &lt;span class="bu"&gt;object&lt;/span&gt; at &lt;span class="bn"&gt;0x7f9027f1aba8&lt;/span&gt;&lt;span class="op"&gt;&amp;gt;&lt;/span&gt;&lt;/a&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;This is a major problem for the tests, which right now look to see if the Lfortran-parsed output of &lt;code&gt;fcode&lt;/code&gt; (SymPy&amp;#8217;s current Fortran code generator) on an expression matches the same directly translated AST. This won&amp;#8217;t be true for &lt;span class="math inline"&gt;&amp;#8197;&amp;#8722;&amp;#8197;&lt;em&gt;x&lt;/em&gt;&lt;/span&gt;, since the translated expression is a multiplication &lt;code&gt;BinOp&lt;/code&gt; while the parsed expression in an &lt;code&gt;UnaryOp&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;One solution might be to not parse &lt;code&gt;fcode&lt;/code&gt;&amp;#8217;s output and instead just check for equivalence between strings. This would mean dealing with the quirks of the code printers (such as their tendency to produce excessive parenthesis), and take away some of the advantages of direct translation. The more probable solution would be to introduce substitution rules within the LFortran AST.&lt;/p&gt;
&lt;h2 id="missing-matrix-nodes"&gt;Missing matrix nodes&lt;/h2&gt;
&lt;p&gt;I filed issue &lt;a href="https://github.com/sympy/sympy/issues/17006"&gt;#17006&lt;/a&gt;, in which &lt;code&gt;lambdify&lt;/code&gt; misinterpreted identity matrices as the imaginary unit. The fix in &lt;a href="https://github.com/sympy/sympy/pull/17022"&gt;#17022&lt;/a&gt; is pretty simple: just generate identity matrices with &lt;code&gt;np.eye&lt;/code&gt; when we can.&lt;/p&gt;
&lt;p&gt;I also went through the matrix expression classes to see which ones weren&amp;#8217;t supported by the NumPy code printer and filed issue &lt;a href="https://github.com/sympy/sympy/issues/17013"&gt;#17013&lt;/a&gt;. These are addressed by another contributor in &lt;a href="https://github.com/sympy/sympy/pull/17029%5D"&gt;#17029&lt;/a&gt;.&lt;/p&gt;
&lt;h2 id="rewriting-matrix-inversion"&gt;Rewriting matrix inversion&lt;/h2&gt;
&lt;p&gt;Most of this week was spent on implementing an optimization for the NumPy generator suggested by Aaron: given the expression &lt;span class="math inline"&gt;&lt;em&gt;A&lt;/em&gt;&lt;sup&gt;&amp;#8197;&amp;#8722;&amp;#8197;1&lt;/sup&gt;&lt;em&gt;b&lt;/em&gt;&lt;/span&gt; where &lt;span class="math inline"&gt;&lt;em&gt;A&lt;/em&gt;&lt;/span&gt; is a square matrix and &lt;span class="math inline"&gt;&lt;em&gt;b&lt;/em&gt;&lt;/span&gt; a vector, generate the expression &lt;code&gt;np.linalg.solve(A, b)&lt;/code&gt; instead of &lt;code&gt;np.linalg.inv(A) * b&lt;/code&gt;. While both &lt;code&gt;solve&lt;/code&gt; and &lt;code&gt;inv&lt;/code&gt; use the same LU-decomposition based LAPACK &lt;a href="http://www.netlib.org/lapack95/DOC/la_gesv.txt"&gt;&lt;code&gt;?gesv&lt;/code&gt;&lt;/a&gt; functions &lt;a class="footnote-ref" href="https://anpandey.github.io/atom-sympy.xml#fn1" id="fnref1"&gt;&lt;sup&gt;1&lt;/sup&gt;&lt;/a&gt;, &lt;code&gt;solve&lt;/code&gt; is called on a vector while the &lt;code&gt;inv&lt;/code&gt; on a (much larger) matrix. In addition to cutting down on the number of operations, this optimization might also remove any errors introduced in calculating the inverse.&lt;/p&gt;
&lt;p&gt;My pull request for this optimization is available at &lt;a href="https://github.com/sympy/sympy/pull/17041"&gt;#17041&lt;/a&gt;, which uses SymPy&amp;#8217;s assumption system to make sure that &lt;span class="math inline"&gt;&lt;em&gt;A&lt;/em&gt;&lt;/span&gt; is full-rank (a constraint imposed by &lt;code&gt;solve&lt;/code&gt;). My initial approach was to embed these optimizations directly in the code printing base classes. After some discussion with Bj&amp;#246;rn, we decided it would be better to separate optimization from printing as much as possible, leading to the representation of the solving operation as its own distinct AST node. This approach is much better than the original, since it was fairly easy to the optimization to the Octave/Matlab code printer.&lt;/p&gt;
&lt;h2 id="next-steps"&gt;Next Steps&lt;/h2&gt;
&lt;p&gt;For this week, I&amp;#8217;ll be continuing with the matrix optimization PR. I&amp;#8217;ll try to find other optimizations that can be applied (such as the evaluation order of complicated matrix expressions) and look into using Sympy&amp;#8217;s unification capabilities in simplifying the expression of optimization rules.&lt;/p&gt;
&lt;section class="footnotes"&gt;
&lt;hr /&gt;
&lt;ol&gt;
&lt;li id="fn1"&gt;&lt;p&gt;You can find the C definitions for the functions eventually called by &lt;a href="https://github.com/numpy/numpy/blob/b80d360e/numpy/linalg/umath_linalg.c.src#L1694"&gt;&lt;code&gt;inv&lt;/code&gt;&lt;/a&gt; and &lt;a href="https://github.com/numpy/numpy/blob/b80d360e/numpy/linalg/umath_linalg.c.src#L1622"&gt;&lt;code&gt;solve&lt;/code&gt;&lt;/a&gt;. These are written in a special templated version of C, but you can find the &lt;a href="https://github.com/numpy/numpy/blob/b80d360e/numpy/linalg/umath_linalg.c.src#L1560"&gt;template variable definitions&lt;/a&gt; a bit higher up in the source.&lt;a class="footnote-back" href="https://anpandey.github.io/atom-sympy.xml#fnref1"&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;/section&gt;</description>
    </item>
    <item>
      <guid isPermaLink="false">https://arighnaiitg.github.io/2019-06-19-gsoc-week3/</guid>
      <author>Arighna Chakrabarty (arighnaiitg)</author>
      <title>Arighna Chakrabarty (arighnaiitg): GSoC Week 3 !!</title>
      <pubDate>Wed, 19 Jun 2019 07:00:00 GMT</pubDate>
      <link>https://arighnaiitg.github.io/2019-06-19-gsoc-week3/</link>
      <description>&lt;p&gt;Week 3 ends.. - 
          Week 3 of the first phase of this coding period is coming to an end. The week started with a bad note, given that I had fallen sick due to travelling. But the work in Week 2, and the meeting with Sartaj on 11th of June helped me to progress...</description>
    </item>
    <item>
      <guid isPermaLink="false">https://divyanshu132.github.io//gsoc-week-3</guid>
      <author>Divyanshu Thakur (divyanshu132)</author>
      <title>Divyanshu Thakur (divyanshu132): GSoC 2019 - Week 3 - Polycyclic Groups</title>
      <pubDate>Mon, 17 Jun 2019 00:00:00 GMT</pubDate>
      <link>https://divyanshu132.github.io//gsoc-week-3</link>
      <description>&lt;p&gt;The third week has ended and a good amount of work has been done on polycyclic groups PR &lt;a href="https://github.com/sympy/sympy/pull/16991"&gt;here&lt;/a&gt;. The collection algorithm has been implemented, from the beginning of the week, I started with understanding the algorithm which took some time and then finally it was implemented, still we are facing a problem in type conversion(&lt;a href="https://github.com/sympy/sympy/pull/16991#discussion_r294054681"&gt;here&lt;/a&gt;) but that will be sorted out soon!&lt;/p&gt;

&lt;p&gt;Even though only two weeks were alloted for polycyclic group implementation but it seems we need one more week or maybe more than a week to implement more functionalities for pc groups. But it&amp;#8217;s completely fine because we started work early and according to the proposed timeline we still have one week.&lt;/p&gt;

&lt;p&gt;Few of the issues with the current implementation which needs to be sorted out are:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;firstly to &lt;code class="highlighter-rouge"&gt;compute uncollected subwords&lt;/code&gt; the word is manipulated using its &lt;code class="highlighter-rouge"&gt;array_form&lt;/code&gt; which eventually leads to change in the type of the subwords computed and it creates a problem in processing these subwords further.&lt;/li&gt;
  &lt;li&gt;Some more issues were pointed out by Kalevi and can be seen in the comments of the PR.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;The complete week was spent implementing collection of words so a lot of tasks targeted last week were not completed, I&amp;#8217;ll try to cover those tasks in the upcomming week.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Solve the issues with collection of words.&lt;/li&gt;
  &lt;li&gt;Get ready with the pc presentation.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Till then, Good byee..!&lt;/p&gt;</description>
    </item>
    <item>
      <guid isPermaLink="false">https://shubhamkjha.github.io/2019/06/17/GSoC-2019-Week-3</guid>
      <author>Shubham Kumar Jha (ShubhamKJha)</author>
      <title>Shubham Kumar Jha (ShubhamKJha): GSoC 2019: Week 3</title>
      <pubDate>Mon, 17 Jun 2019 00:00:00 GMT</pubDate>
      <link>https://shubhamkjha.github.io/2019/06/17/GSoC-2019-Week-3.html</link>
      <description>&lt;p&gt;The third week of coding period has ended and as I already stated in the last blog, I couldn&amp;#8217;t be much productive this week. Nevertheless, I tried to wrap-up some unfinished works. PR &lt;a href="https://github.com/sympy/sympy/pull/16956"&gt;#16956&lt;/a&gt; is ready to merge, just waiting for some last reviews. This PR needs to be supplemented with some fixes in the code of &lt;code class="highlighter-rouge"&gt;Add&lt;/code&gt; class to handle all the issues over &lt;code class="highlighter-rouge"&gt;Relationals&lt;/code&gt;. PR &lt;a href="https://github.com/sympy/sympy/pull/16978"&gt;#16978&lt;/a&gt; had one major failing test from the &lt;code class="highlighter-rouge"&gt;stats&lt;/code&gt; module. I tried to debug it ,but due to my unfamiliarity with that part of code I took help from &lt;a href="https://github.com/czgdp1807"&gt;Gagandeep&lt;/a&gt; and as his &lt;a href="https://github.com/sympy/sympy/pull/16978#discussion_r294039337"&gt;comment&lt;/a&gt; suggests, the result this PR is giving is correct and more intuitive. At least, one less issue to handle &amp;#128524;.&lt;/p&gt;

&lt;p&gt;Over the end of the week, I shifted my focus towards &lt;em&gt;New Assumptions&lt;/em&gt;. One of my major tasks for this summer is to speed up the &lt;em&gt;satask&lt;/em&gt; module. As suggested by Aaron, I searched the repository for issues and PRs over this, and I found a number of such unfinished work. I would need to study these ideas and profile the results before working ahead. I would create a issue-tree over it connecting all such PRs and there respective benchmarks.&lt;/p&gt;

&lt;p&gt;For this week, I would focus on the above mentioned task only. Since the first phase is about to end, I would have to speed things up.&lt;/p&gt;</description>
    </item>
    <item>
      <guid isPermaLink="false">https://www.kangzhiq.com/?p=20</guid>
      <author>Zhiqi KANG (kangzhiq)</author>
      <title>Zhiqi KANG (kangzhiq): [GSoC 2019] WEEK 3!</title>
      <pubDate>Sun, 16 Jun 2019 22:11:07 GMT</pubDate>
      <link>https://www.kangzhiq.com/2019/06/17/gsoc-2019-week-3/</link>
      <description>&lt;p&gt;Hello, the third week ends! I am a little bit too busy to keep contributing on my GSoC project as the first two weeks. Fortunately, thank to the work of the past 2 weeks and the help of my mentors, I become more productive which compensates, more or less,  the lack of time.&lt;/p&gt;



&lt;ul&gt;&lt;li&gt;Overview&lt;/li&gt;&lt;/ul&gt;



&lt;p&gt;The task about sparse arrays nearly comes to an end which is the main goal for the first phase. I still have one case to be fixed but most of them are merged in to Sympy&amp;#8217;s master and are ready to be used. I started as well preparing for the next task: implementing more data structure for sparse arrays. This would be started in the next week and is supposed to be ended by the begining of phase 2.&lt;/p&gt;



&lt;ul&gt;&lt;li&gt;PRs&lt;/li&gt;&lt;/ul&gt;



&lt;p&gt;Several PR are merged this week for sparse arrays operations.  &lt;a href="https://github.com/sympy/sympy/pull/16937"&gt;#16937&lt;/a&gt;  is finally merged with a code style much simpler than its first version.  &lt;a href="https://github.com/sympy/sympy/pull/16994"&gt;#16994&lt;/a&gt;  about __mul__ and __rmul__ is closed and replaced by &lt;a href="https://github.com/sympy/sympy/pull/17014"&gt;#17014&lt;/a&gt; due to a mistake about rebase. &lt;a href="https://github.com/sympy/sympy/pull/17026"&gt;#17026&lt;/a&gt;  about __div__ and __neg__ operators for sparse arrays is opened and merged.  &lt;a href="https://github.com/sympy/sympy/pull/17035"&gt;#17035&lt;/a&gt; about permutedims and transpose for sparse arrays is opened and reviewed by my mentor.&lt;/p&gt;



&lt;ul&gt;&lt;li&gt;Issues&lt;/li&gt;&lt;/ul&gt;



&lt;p&gt;No specific issue opened. The list in &lt;a href="https://github.com/sympy/sympy/issues/16941"&gt;#16941&lt;/a&gt; is continously being updated.&lt;/p&gt;



&lt;ul&gt;&lt;li&gt;Reviews&lt;/li&gt;&lt;/ul&gt;



&lt;p&gt;No review due to the lack of time.&lt;/p&gt;



&lt;ul&gt;&lt;li&gt;Related works&lt;/li&gt;&lt;/ul&gt;



&lt;p&gt;Pratice of rebasing and merging for a specific case: updated local repository from the upstream master after opening a PR. Even though I have broken the PR  &lt;a href="https://github.com/sympy/sympy/pull/16994"&gt;#16994&lt;/a&gt;, I am still happy to learn some new tricks that I didn&amp;#8217;t know before.&lt;/p&gt;



&lt;p&gt;Preparing a blog about presenting sparse array associated with my work in SymPy so that my contribution can indeed help people when they need to use this class but don&amp;#8217;t really know how to do it and what the advantage would be .&lt;/p&gt;</description>
    </item>
    <item>
      <guid isPermaLink="false">http://ishanaj.wordpress.com/?p=48</guid>
      <author>Ishan Joshi (ishanaj)</author>
      <title>Ishan Joshi (ishanaj): GSoC&#x2019;19: Week 3 &#x2013; Wrapping up Stage-I</title>
      <pubDate>Sun, 16 Jun 2019 19:20:32 GMT</pubDate>
      <link>https://ishanaj.wordpress.com/2019/06/17/gsoc19-week-3-wrapping-up-stage-i/</link>
      <description>&lt;p&gt;This week started with working on &lt;a href="https://github.com/sympy/sympy/pull/17001"&gt;PR #17001&lt;/a&gt;. The algorithm was extended to handle concave polygons as well. I came up with a new method which I have explained in the &lt;a href="https://github.com/sympy/sympy/wiki/A-method-to-return-a-cut-section-of-any-polygon-geometry"&gt;wiki page&lt;/a&gt; that I have created. It has to be tested against some symbolic coordinates to make it a complete method.&lt;/p&gt;
&lt;p&gt;The API of the CrossSection class has been changed as discussed in the last week. The documentation of the class has been completed.&lt;/p&gt;
&lt;p&gt;There were some discussions being done on the necessity and the importance of the CrossSection class. Despite the CrossSection class providing some very useful functionalities of calculating the section modulus, the first moment of area and polar modulus, is there really a need for such a class? After getting some pros and cons listed out we got to a conclusion, that it would probably be better to add these functionalities directly to the geometry module.&lt;/p&gt;
&lt;p&gt;But the question of complex geometries like T-shape and I-shape still remains. The alternative to this that we came up with in the discussion was Boolean operations on simple polygons. There are some clipping algorithms like Vatti algorithm and Greiner Hormann algorithm which might be helpful in implementing these.&lt;/p&gt;
&lt;p&gt;In short, this is what is left to be done:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Transferring the cross-sectional properties defined in the CrossSection class to the geometry module&lt;/li&gt;
&lt;li&gt;Making the beam class to accept any geometry instead of the second moment that is currently accepted from the user.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;In later stages, I might try to work on the Boolean operations as currently there is a limitation of time and the implementation of the stage -II awaits.&lt;/p&gt;
&lt;p&gt;After this, the stage-I would end and I will have to start with the next implementation i.e. the column buckling calculations&lt;/p&gt;
&lt;h2&gt;Next Week:&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;Completing leftovers of the previous week&lt;/li&gt;
&lt;li&gt;Starting off with stage-II&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;The work and the progress during the stage-I were full of ups and downs. Will try to make it smoother this time. Will try to discuss the implementations with the mentors and the members in even more detail. Hope to have a good coding week.&lt;/p&gt;
&lt;p&gt;Will keep you updated!&lt;/p&gt;
&lt;p&gt;Thanks!&lt;/p&gt;</description>
    </item>
  </channel>
</rss>
