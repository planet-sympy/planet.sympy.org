<?xml version="1.0"?>
<rss version="2.0" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Planet SymPy</title>
    <link>http://planet.sympy.org/</link>
    <language>en</language>
    <description>Planet SymPy - http://planet.sympy.org/</description>
    <atom:link href="http://planet.sympy.org/rss10.xml" rel="self" type="application/rss+xml"/>
    <item>
      <guid isPermaLink="false">https://czgdp1807.github.io/week_5</guid>
      <author>Gagandeep Singh (czgdp1807)</author>
      <title>Gagandeep Singh (czgdp1807): Week 5 - Transition towards Phase 2</title>
      <pubDate>Tue, 02 Jul 2019 00:00:00 GMT</pubDate>
      <link>https://czgdp1807.github.io/week_5/</link>
      <description>&lt;p&gt;The evaluation results for phase 1 are out, and I am very glad to share with you that I have passed with flying colors. I received, &amp;#8220;Well done so far.&amp;#8221; as the feedback for my work till now.&lt;/p&gt;

&lt;p&gt;So now let us move to the work done in the gap between phase 1 and phase 2. Firstly, both of my open PRs of the previous phase, i.e., &lt;a href="https://github.com/sympy/sympy/pull/16962"&gt;#16962&lt;/a&gt; and &lt;a href="https://github.com/sympy/sympy/pull/16934"&gt;#16934&lt;/a&gt; have been merged. Though for symbolic dimensions some more work has to be done to make &lt;code class="highlighter-rouge"&gt;sympy.stats.frv&lt;/code&gt; more efficient and maintainable. I have also started my work, PR &lt;a href="https://github.com/sympy/sympy/pull/17083"&gt;#17083&lt;/a&gt;, to extend the scope of queries for &lt;code class="highlighter-rouge"&gt;DiscreteMarkovChain&lt;/code&gt; and the system has become a bit smarter. In fact, during this week, while working on the PR, &lt;a href="https://github.com/sympy/sympy/pull/17103"&gt;#17103&lt;/a&gt;, I came across the news that Tensorflow has changed a lot of APIs  while migrating from 1.x to 2.x. AFAIK, they are moving towards &lt;code class="highlighter-rouge"&gt;Function&lt;/code&gt; approach from the previous &lt;code class="highlighter-rouge"&gt;Session&lt;/code&gt; approach, and due to that, SymPy&amp;#8217;s &lt;code class="highlighter-rouge"&gt;lambdify&lt;/code&gt; faced some issues which I will be fixing soon with the help of other members. The Tensorflow details can be seen &lt;a href="https://github.com/tensorflow/community/blob/b1d83bf2ee3fc72650140b89656e29932db36226/rfcs/20180918-functions-not-sessions-20.md"&gt;here&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Now, let&amp;#8217;s move to the learning part. During the transition period I learnt about the dependencies of &lt;code class="highlighter-rouge"&gt;SymPy&lt;/code&gt;. Moreover, I came across, how, some bugs can be unnoticed when left untested. Thanks again to &lt;a href="https://github.com/oscarbenjamin"&gt;oscarbenjamin&lt;/a&gt; for letting me know about the bugs related to variance of finite random variables. I also got to know that, how bare &lt;code class="highlighter-rouge"&gt;except&lt;/code&gt; can even catch keyboard interrupt and that&amp;#8217;s what makes it quite vulnerable. Thanks to &lt;a href="https://github.com/sidhantnagpal"&gt;sidhantnagpal&lt;/a&gt; for helping me with this.&lt;/p&gt;

&lt;p&gt;So, that&amp;#8217;s all for this, see you next week. Bye!!&lt;/p&gt;</description>
    </item>
    <item>
      <guid isPermaLink="false">https://divyanshu132.github.io//gsoc-week-5</guid>
      <author>Divyanshu Thakur (divyanshu132)</author>
      <title>Divyanshu Thakur (divyanshu132): GSoC 2019 - Week 5 - Hand-made tests for Collector</title>
      <pubDate>Mon, 01 Jul 2019 00:00:00 GMT</pubDate>
      <link>https://divyanshu132.github.io//gsoc-week-5</link>
      <description>&lt;p&gt;This week was mostly about testing the collection of a word and fixing small bugs in the implementation pointed out by Kalevi. The major challenge was to construct the polycyclic presentation of a group to test the Collector since we don&amp;#8217;t have the implementation of polycyclic presentation and it&amp;#8217;s generating sequence yet. So, we decided to form some hand made tests and we started with SymmetricGroup(4) and further we also tried with S(3) the details can be found in the test file of the PR(&lt;a href="https://github.com/sympy/sympy/pull/16991"&gt;here&lt;/a&gt;).&lt;/p&gt;

&lt;p&gt;Now, the next step is to implement polycyclic presentation and polycyclic sequence. In the presentation we&amp;#8217;ll need generators which we can easily get and the relators. There are two types of relators needed for the presentation:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Power relations (ex. &lt;code class="highlighter-rouge"&gt;x^re = x'&lt;/code&gt;)&lt;/li&gt;
  &lt;li&gt;Conjugate relations (ex. &lt;code class="highlighter-rouge"&gt;x[i]**-1*x[i+1]*x[i] = RHS and x[i]*x[i+1]*x[i]**-1 = RHS&lt;/code&gt;)&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;For every pair of generators we&amp;#8217;ll form above conjugate relations but the tough part is computing that &lt;code class="highlighter-rouge"&gt;RHS&lt;/code&gt; which should be collected and for now we don&amp;#8217;t have that much idea about how to get that RHS.&lt;/p&gt;

&lt;p&gt;But, let&amp;#8217;s hope that in upcoming days we&amp;#8217;ll be able to figure it out, till then Good byeee&amp;#8230;&lt;/p&gt;</description>
    </item>
    <item>
      <guid isPermaLink="false">http://ishanaj.wordpress.com/?p=54</guid>
      <author>Ishan Joshi (ishanaj)</author>
      <title>Ishan Joshi (ishanaj): GSoC&#x2019;19: Week-5 &#x2013; Moving on with a Non-mutable Column class</title>
      <pubDate>Sun, 30 Jun 2019 18:52:29 GMT</pubDate>
      <link>https://ishanaj.wordpress.com/2019/07/01/gsoc19-week-5-moving-on-with-a-non-mutable-column-class/</link>
      <description>&lt;p&gt;A lot of things happened this week and I am happy to inform you that &lt;a href="https://github.com/sympy/sympy/pull/17055"&gt;PR #17055&lt;/a&gt; has been successfully merged. The beam module now supports the cross-sectional shape of the beam as an alternative parameter to the second moment. With this, the aim of the stage-I to integrate the geometry module with beam module has been accomplished.&lt;/p&gt;
&lt;p&gt;Although we need to add some examples in the docs, to make it easier for the user to understand how to use this new feature.&lt;/p&gt;
&lt;p&gt;Coming on to stage-II, I had already, initiated a &lt;a href="https://github.com/sympy/sympy/issues/17072"&gt;discussion&lt;/a&gt; to finalize the API of the new Column class that is to be implemented as a part of the continuum mechanics module in this stage.&lt;/p&gt;
&lt;p&gt;We concluded that it would be much better if the Column class remains non-mutable i.e. unlike the beam class where a beam is formed in a piecewise form, the new Column class would take all its required input data during the declaration and then one can call different methods to calculate different things.&lt;/p&gt;
&lt;p&gt;I have made a &lt;a href="https://github.com/sympy/sympy/pull/17122"&gt;work-in-progress PR #17122&lt;/a&gt; implementing the Column class which performs the required buckling calculations. Currently, I have not included a method to calculate the critical load as there was a bit of problem with the form of the equation which the &lt;strong&gt;dsolve() &lt;/strong&gt;returns after solving the differential equation of buckling. &lt;a href="https://docs.sympy.org/latest/modules/solvers/ode.html" rel="noopener" target="_blank"&gt;&lt;strong&gt;dsolve(&lt;/strong&gt;)&lt;/a&gt; is SymPy&amp;#8217;s differential equation solver.&lt;/p&gt;
&lt;p&gt;In general, if we solve the general equation of buckling manually, we might apply the &lt;strong&gt;method of undetermined coefficients&lt;/strong&gt;, which of course even &lt;strong&gt;dsolve() &lt;/strong&gt;&amp;#160;is capable to apply, but it gives the answer in an exponent form, while we need it in a trigonometric form (for ease of further calculations). So after seeking different methods trying to convert this equation in terms of &lt;strong&gt;sin(x)&lt;/strong&gt; and &lt;strong&gt;cos(x), &lt;/strong&gt;I finally had to put that problem in the discussion, where Oscar Benjamin, gave an idea to declare the variables as positive in order to get it in terms of &lt;strong&gt;sin &lt;/strong&gt;and&lt;strong&gt; cos.&amp;#160;&lt;/strong&gt;I tried that it works well for our case. I will have to figure out the further calculation of the critical load.&lt;/p&gt;
&lt;p&gt;Hopefully will be updating the code with a new method to calculate critical load, soon.&lt;/p&gt;
&lt;p&gt;Also, I have planned to have a method to solve the &lt;strong&gt;unknown reactions&lt;/strong&gt; and &lt;strong&gt;reaction moments&lt;/strong&gt;, which would use the &lt;strong&gt;boundary conditions&lt;/strong&gt; to get their values.&lt;/p&gt;
&lt;p&gt;With all these things going on, this week we also had our first evaluations, and I am very happy to say that I have passed it. &lt;strong&gt;Thanks to the mentors!&lt;/strong&gt;&lt;/p&gt;
&lt;h2&gt;&lt;strong&gt;&amp;#160;&lt;/strong&gt;&lt;strong&gt;Next Week:&lt;/strong&gt;&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;Completing Column class with all its methods&lt;/li&gt;
&lt;li&gt;Adding tests and documentation.&lt;/li&gt;
&lt;li&gt;Starting discussions for the next stage.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;I will try to finish working on the Column class this weekend.&lt;/p&gt;
&lt;p&gt;Will keep you updated!&lt;/p&gt;
&lt;p&gt;Thanks!&lt;/p&gt;
&lt;p&gt;&amp;nbsp;&lt;/p&gt;</description>
    </item>
    <item>
      <guid isPermaLink="false">https://arighnaiitg.github.io/2019-06-30-gsoc-week5/</guid>
      <author>Arighna Chakrabarty (arighnaiitg)</author>
      <title>Arighna Chakrabarty (arighnaiitg): GSoC Week 5 !!</title>
      <pubDate>Sun, 30 Jun 2019 07:00:00 GMT</pubDate>
      <link>https://arighnaiitg.github.io/2019-06-30-gsoc-week5/</link>
      <description>&lt;p&gt;Week 5 ends.. - 
          Phase 2 of the coding period has started. This week has gone in wrapping up the left-over work of FormalPowerSeries. I had a meeting with Sartaj on Tuesday 25th of June, about the work left to be done on FormalPowerSeries module. We agreed that some minor changes need to be...</description>
    </item>
    <item>
      <guid isPermaLink="false">https://www.kangzhiq.com/?p=24</guid>
      <author>Zhiqi KANG (kangzhiq)</author>
      <title>Zhiqi KANG (kangzhiq): [GSoC 2019] WEEK 4 and 5!</title>
      <pubDate>Sat, 29 Jun 2019 02:40:07 GMT</pubDate>
      <link>https://www.kangzhiq.com/2019/06/29/gsoc-2019-week-4-and-5/</link>
      <description>&lt;p&gt;Hello, the first phase is ended and I am happy to pass the first evaluation. I was struggling with my academic projects and final exams during the last two weeks. After talking about my difficulty of spending time contributing on my project with my mentors, Francesco allowed me to have a one-week break in condition that I should make up one week in the next phases. The goal is to have 40 hours work per week on average by the end of this program.&lt;/p&gt;



&lt;p&gt;Thanks to the comprehension of my mentor, I could successfully pass the exams. I am going to work more over the second phase in order to have more contributions to the community. &lt;img alt="&amp;#128578;" class="wp-smiley" src="https://s.w.org/images/core/emoji/12.0.0-1/72x72/1f642.png" style="height: 1em;" /&gt;&lt;/p&gt;</description>
    </item>
    <item>
      <guid isPermaLink="false">https://jmig5776.github.io//gsoc-week-5</guid>
      <author>Jogi Miglani (jmig5776)</author>
      <title>Jogi Miglani (jmig5776): GSoC 2019 - Week 5</title>
      <pubDate>Sat, 29 Jun 2019 00:00:00 GMT</pubDate>
      <link>https://jmig5776.github.io//gsoc-week-5</link>
      <description>&lt;p&gt;This was the fifth week meeting with the GSoC mentors which was scheduled on
Saturday 29th June, 2019 between 11:30 - 12:30 PM (IST). Me, Yathartha and Amit
were the attendees of the meeting. I passed my first evaluation, Amit gave his
feedback and told me some very important points to take notes on. I do personally
believe that his suggestions are the best a mentor could gave to his student after
practicing his suggestions in my real life.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Discussing previous week&amp;#8217;s progress&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;In this meeting both mentors suggested me to work upon the code improvements and
documentation improvement. And make it more readable to user. ALthough somehow
@smichr had some doubts on the logic that we were implementing. Although a lot
of progress has been there. So I decided to create and discussion for thinking
new logic for implementing Lambert all solutions and work on the current PR as
goes on.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;Next week goals&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Improving existing PR for Lambert&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Improving &lt;code class="highlighter-rouge"&gt;_solve_modular&lt;/code&gt; PR also&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;If time left then find plan for Imageset Union.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Code improvement takes time!!&lt;/p&gt;</description>
    </item>
    <item>
      <guid isPermaLink="false">https://sc0rpi0n101.github.io/2019/06/week-5-the-evaluation-is-here-end-of-phase-1/</guid>
      <author>Nikhil Maan (Sc0rpi0n101)</author>
      <title>Nikhil Maan (Sc0rpi0n101): Week 5: The Evaluation is here: End of Phase 1</title>
      <pubDate>Sat, 29 Jun 2019 00:00:00 GMT</pubDate>
      <link>https://sc0rpi0n101.github.io/2019/06/week-5-the-evaluation-is-here-end-of-phase-1/</link>
      <description>&lt;p&gt;&amp;ldquo;On two occasions I have been asked [by members of Parliament!]: &amp;lsquo;Pray, Mr. Babbage, if you put into the machine wrong figures, will the right answers come out ?&amp;rsquo; I am not able rightly to apprehend the kind of confusion of ideas that could provoke such a question.&amp;rdquo; &amp;#8212; Charles Babbage
 Welcome everyone, this is your host Nikhil Maan aka Sc0rpi0n101 and this week was the last week of Phase-1 and the evaluations for the first phase.</description>
    </item>
    <item>
      <guid isPermaLink="false">https://anpandey.github.io/posts/sympy/2019-06-28-week-5.html</guid>
      <author>Ankit Pandey (anpandey)</author>
      <title>Ankit Pandey (anpandey): Google Summer of Code Week 5: Unification and Tensors</title>
      <pubDate>Fri, 28 Jun 2019 00:00:00 GMT</pubDate>
      <link>https://anpandey.github.io/posts/sympy/2019-06-28-week-5.html</link>
      <description>&lt;p&gt;&lt;em&gt;See the &lt;a href="https://anpandey.github.io/2019-06-21-weeks-3-and-4.html"&gt;previous post&lt;/a&gt; for Weeks 3 and 4&lt;/em&gt;.&lt;/p&gt;
&lt;p&gt;This week I&amp;#8217;ve been mostly doing background reading. This post is mostly a summary of what I learned.&lt;/p&gt;
&lt;h2 id="unification"&gt;Unification&lt;/h2&gt;
&lt;p&gt;In short, unification is the process of finding substitutions of variables within two terms two terms to make them identical. For example, if we have the expressions &lt;span class="math inline"&gt;&lt;em&gt;x&lt;/em&gt;&amp;#8197;+&amp;#8197;2&lt;em&gt;y&lt;/em&gt;&lt;/span&gt; and &lt;span class="math inline"&gt;&lt;em&gt;a&lt;/em&gt;&amp;#8197;+&amp;#8197;3&lt;em&gt;b&lt;/em&gt;&lt;/span&gt;, the substitution &lt;span class="math inline"&gt;{&lt;em&gt;x&lt;/em&gt;&amp;#8196;&amp;#8614;&amp;#8196;&lt;em&gt;a&lt;/em&gt;,&amp;#8198;&lt;em&gt;y&lt;/em&gt;&amp;#8196;&amp;#8614;&amp;#8196;3,&amp;#8198;&lt;em&gt;b&lt;/em&gt;&amp;#8196;&amp;#8614;&amp;#8196;2}&lt;/span&gt; is a unifier, since applying the substitution to both expressions makes gives us the identical expression of &lt;span class="math inline"&gt;&lt;em&gt;a&lt;/em&gt;&amp;#8197;+&amp;#8197;3&amp;#8197;&amp;#8901;&amp;#8197;2&lt;/span&gt;. While this particular substitution includes variables from both expressions, we&amp;#8217;re mostly interested in rules involving substitutions of variables from just one expression (a case of unification known as matching). Several well-known algorithms for unification already exist.&lt;/p&gt;
&lt;h3 id="unification-in-sympy"&gt;Unification in SymPy&lt;/h3&gt;
&lt;p&gt;SymPy also has an implementation of a unification algorithm that is able to take the commutativity of operations into account. Suppose we wanted to unify the matrix expressions &lt;span class="math inline"&gt;&lt;em&gt;A&lt;/em&gt;&lt;sup&gt;&lt;em&gt;T&lt;/em&gt;&lt;/sup&gt;&lt;em&gt;B&lt;/em&gt;&lt;sup&gt;2&lt;/sup&gt;&lt;em&gt;C&lt;/em&gt;&lt;sup&gt;&amp;#8197;&amp;#8722;&amp;#8197;1&lt;/sup&gt;&lt;/span&gt; and &lt;span class="math inline"&gt;&lt;em&gt;X&lt;/em&gt;&lt;em&gt;Y&lt;/em&gt;&lt;sup&gt;&amp;#8197;&amp;#8722;&amp;#8197;1&lt;/sup&gt;&lt;/span&gt;. This is essentially the problem of finding a substitution that makes these two expressions equal. Using the &lt;code&gt;sympy.unify.usympy&lt;/code&gt; module, we can discover what this substitution is:&lt;/p&gt;
&lt;div class="sourceCode" id="cb1"&gt;&lt;pre class="sourceCode python"&gt;&lt;code class="sourceCode python"&gt;&lt;a class="sourceLine" id="cb1-1" title="1"&gt;&lt;span class="op"&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class="im"&gt;from&lt;/span&gt; sympy.unify.usympy &lt;span class="im"&gt;import&lt;/span&gt; &lt;span class="op"&gt;*&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb1-2" title="2"&gt;&lt;span class="op"&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class="im"&gt;from&lt;/span&gt; sympy.abc &lt;span class="im"&gt;import&lt;/span&gt; N&lt;/a&gt;
&lt;a class="sourceLine" id="cb1-3" title="3"&gt;&lt;span class="op"&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt; m &lt;span class="op"&gt;=&lt;/span&gt; &lt;span class="kw"&gt;lambda&lt;/span&gt; x: MatrixSymbol(x, N, N)&lt;/a&gt;
&lt;a class="sourceLine" id="cb1-4" title="4"&gt;&lt;span class="op"&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt; A, B, C, X, Y &lt;span class="op"&gt;=&lt;/span&gt; &lt;span class="bu"&gt;map&lt;/span&gt;(m, [&lt;span class="st"&gt;'A'&lt;/span&gt;, &lt;span class="st"&gt;'B'&lt;/span&gt;, &lt;span class="st"&gt;'X'&lt;/span&gt;, &lt;span class="st"&gt;'Y'&lt;/span&gt;])&lt;/a&gt;
&lt;a class="sourceLine" id="cb1-5" title="5"&gt;&lt;span class="op"&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt; e1 &lt;span class="op"&gt;=&lt;/span&gt; A.T &lt;span class="op"&gt;*&lt;/span&gt; B&lt;span class="op"&gt;**&lt;/span&gt;&lt;span class="dv"&gt;2&lt;/span&gt; &lt;span class="op"&gt;*&lt;/span&gt; C.I&lt;/a&gt;
&lt;a class="sourceLine" id="cb1-6" title="6"&gt;&lt;span class="op"&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt; e2 &lt;span class="op"&gt;=&lt;/span&gt; X &lt;span class="op"&gt;*&lt;/span&gt; Y &lt;span class="op"&gt;**&lt;/span&gt;(&lt;span class="op"&gt;-&lt;/span&gt;&lt;span class="dv"&gt;1&lt;/span&gt;)&lt;/a&gt;
&lt;a class="sourceLine" id="cb1-7" title="7"&gt;&lt;span class="op"&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class="bu"&gt;next&lt;/span&gt;(unify(e1, e2, variables&lt;span class="op"&gt;=&lt;/span&gt;[X, Y]))&lt;/a&gt;
&lt;a class="sourceLine" id="cb1-8" title="8"&gt;{X: A.T&lt;span class="op"&gt;*&lt;/span&gt;B&lt;span class="op"&gt;**&lt;/span&gt;&lt;span class="dv"&gt;2&lt;/span&gt;, Y: C}&lt;/a&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;We&amp;#8217;ve reduced this to a matching problem in which the variables are specified only in &lt;code&gt;e2&lt;/code&gt;. What&amp;#8217;s important to note here is that the matching rule within &lt;code&gt;e2&lt;/code&gt; we specified (&lt;span class="math inline"&gt;&lt;em&gt;X&lt;/em&gt;&lt;em&gt;Y&lt;/em&gt;&lt;sup&gt;&amp;#8197;&amp;#8722;&amp;#8197;1&lt;/sup&gt;&lt;/span&gt;) was a compound expression. This is something that is currently not possible for non-commutative expressions (such as matrix multiplication) using SymPy&amp;#8217;s &lt;code&gt;Wild&lt;/code&gt; interface. &lt;code&gt;unify&lt;/code&gt; allows use to express substitution rules that are able to match across sub-expressions in matrix multiplication.&lt;/p&gt;
&lt;p&gt;Through unification, we can express substitution rules for optimization as a simple term-rewriting rule. In my previous blog post, I mentioned rewriting the matrix multiplication &lt;span class="math inline"&gt;&lt;em&gt;A&lt;/em&gt;&lt;em&gt;x&lt;/em&gt;&lt;/span&gt; as a solving operation of &lt;code&gt;MatSolve(A, x)&lt;/code&gt; under certain assumptions. The actual implementation is restricted to cases where both the &lt;code&gt;A&lt;/code&gt; and the &lt;code&gt;x&lt;/code&gt; are matrix symbols, and the optimization can&amp;#8217;t identify cases where either the &lt;code&gt;A&lt;/code&gt; or the &lt;code&gt;x&lt;/code&gt; is a compound expression. With unification, we can identify the same pattern in more complex subexpressions. If we&amp;#8217;re given the matrix expression &lt;span class="math inline"&gt;&lt;em&gt;A&lt;/em&gt;&lt;sup&gt;&lt;em&gt;T&lt;/em&gt;&lt;/sup&gt;(&lt;em&gt;A&lt;/em&gt;&lt;em&gt;B&lt;/em&gt;)&lt;sup&gt;&amp;#8197;&amp;#8722;&amp;#8197;1&lt;/sup&gt;&lt;em&gt;x&lt;/em&gt;&lt;em&gt;y&lt;/em&gt;&lt;/span&gt;, a unification based transformer can produce &lt;code&gt;MatSolve(AB, x)&lt;/code&gt;, provided that the shapes of the matrices match the given rule.&lt;/p&gt;
&lt;h2 id="codegen-tensors"&gt;Codegen Tensors&lt;/h2&gt;
&lt;p&gt;I also looked into generating C and Fortran code from SymPy matrix expressions. For the purposes of code generation, SymPy has a relatively new &lt;code&gt;array_utils&lt;/code&gt; module. The AST nodes in this module express generalizations of operations on matrices, which require a bit of background in tensors.&lt;/p&gt;
&lt;p&gt;Many array operations (including matrix multiplication) involve &lt;em&gt;contraction&lt;/em&gt; along an axis. Contractions are a combination of multiplication and summation along certain axis of a tensor&lt;a class="footnote-ref" href="https://anpandey.github.io/atom-sympy.xml#fn1" id="fnref1"&gt;&lt;sup&gt;1&lt;/sup&gt;&lt;/a&gt;. In assigning the matrix multiplication &lt;span class="math inline"&gt;&lt;em&gt;A&lt;/em&gt;&lt;em&gt;B&lt;/em&gt;&lt;/span&gt; to the &lt;span class="math inline"&gt;&lt;em&gt;n&lt;/em&gt;&amp;#8197;&amp;#215;&amp;#8197;&lt;em&gt;n&lt;/em&gt;&lt;/span&gt; matrix &lt;span class="math inline"&gt;&lt;em&gt;C&lt;/em&gt;&lt;/span&gt;, we can explicitly write the summations (using subscripts for indexing matrix elements) as&lt;/p&gt;
&lt;p&gt;&lt;br /&gt;&lt;span class="math display"&gt;$$C_{ik} = \sum_{j = 1}^{n} A_{ij} B_{jk}$$&lt;/span&gt;&lt;br /&gt;&lt;/p&gt;
&lt;p&gt;The index &lt;span class="math inline"&gt;&lt;em&gt;j&lt;/em&gt;&lt;/span&gt; is contracted, as it is shared between both &lt;span class="math inline"&gt;&lt;em&gt;A&lt;/em&gt;&lt;/span&gt; and &lt;span class="math inline"&gt;&lt;em&gt;B&lt;/em&gt;&lt;/span&gt;, and describing this summation operation as a whole boils down to which indices are shared between the matrices. This is essentially what the &lt;code&gt;array_utils&lt;/code&gt; classes do. This is what happens when we use &lt;code&gt;array_utils&lt;/code&gt; to convert the matrix multiplication to an equivalent contraction operation:&lt;/p&gt;
&lt;div class="sourceCode" id="cb2"&gt;&lt;pre class="sourceCode python"&gt;&lt;code class="sourceCode python"&gt;&lt;a class="sourceLine" id="cb2-1" title="1"&gt;&lt;span class="op"&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class="im"&gt;from&lt;/span&gt; sympy.codegen.array_utils &lt;span class="im"&gt;import&lt;/span&gt; CodegenArrayContraction&lt;/a&gt;
&lt;a class="sourceLine" id="cb2-2" title="2"&gt;&lt;span class="op"&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class="im"&gt;from&lt;/span&gt; sympy.abc &lt;span class="im"&gt;import&lt;/span&gt; N&lt;/a&gt;
&lt;a class="sourceLine" id="cb2-3" title="3"&gt;&lt;span class="op"&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt; A &lt;span class="op"&gt;=&lt;/span&gt; MatrixSymbol(&lt;span class="st"&gt;'A'&lt;/span&gt;, N, N)&lt;/a&gt;
&lt;a class="sourceLine" id="cb2-4" title="4"&gt;&lt;span class="op"&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt; B &lt;span class="op"&gt;=&lt;/span&gt; MatrixSymbol(&lt;span class="st"&gt;'B'&lt;/span&gt;, N, N)&lt;/a&gt;
&lt;a class="sourceLine" id="cb2-5" title="5"&gt;&lt;span class="op"&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt; CodegenArrayContraction.from_MatMul(A &lt;span class="op"&gt;*&lt;/span&gt; B)&lt;/a&gt;
&lt;a class="sourceLine" id="cb2-6" title="6"&gt;CodegenArrayContraction(CodegenArrayTensorProduct(A, B), (&lt;span class="dv"&gt;1&lt;/span&gt;, &lt;span class="dv"&gt;2&lt;/span&gt;))&lt;/a&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;We&amp;#8217;re given a new&lt;code&gt;CodegenArrayContraction&lt;/code&gt; object that stores, along with the variables &lt;code&gt;A&lt;/code&gt; and &lt;code&gt;B&lt;/code&gt;, tuples of integers representing contractions along certain indices. Here, the &lt;code&gt;(1, 2)&lt;/code&gt; means that the variable at index 1 and index 2 (indices start at 0) are shared. We can confirm this by looking at the above summation, since both the second and third indices out of all indices that appear in the expression are &lt;span class="math inline"&gt;&lt;em&gt;j&lt;/em&gt;&lt;/span&gt;.&lt;/p&gt;
&lt;h2 id="next-steps"&gt;Next Steps&lt;/h2&gt;
&lt;p&gt;For next week, I&amp;#8217;ll try to re-implement the rewriting optimization in terms of &lt;code&gt;unify&lt;/code&gt;. This will both make it easier to express rules and extend to sub-expressions as well. I&amp;#8217;ll also start with implementing additional printers for the C and Fortran printers. The printer will probably just print naive &lt;code&gt;for&lt;/code&gt; loops to keep things simple (and it would probaly be better to use something like Theano for highly optimized code).&lt;/p&gt;
&lt;section class="footnotes"&gt;
&lt;hr /&gt;
&lt;ol&gt;
&lt;li id="fn1"&gt;&lt;p&gt;For our purposes, we can think of tensors as just &lt;span class="math inline"&gt;&lt;em&gt;n&lt;/em&gt;&lt;/span&gt;-dimensional arrays. Most of my reading on tensors was Justin C. Feng&amp;#8217;s &lt;a href="https://justincfeng.github.io/Tensors_Poor_Man.pdf"&gt;The Poor Man&amp;#8217;s Introduction to Tensors&lt;/a&gt;.&lt;a class="footnote-back" href="https://anpandey.github.io/atom-sympy.xml#fnref1"&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;/section&gt;</description>
    </item>
    <item>
      <guid isPermaLink="false">https://divyanshu132.github.io//gsoc-week-4</guid>
      <author>Divyanshu Thakur (divyanshu132)</author>
      <title>Divyanshu Thakur (divyanshu132): GSoC 2019 - Week 4 - Phase-I Completion</title>
      <pubDate>Mon, 24 Jun 2019 00:00:00 GMT</pubDate>
      <link>https://divyanshu132.github.io//gsoc-week-4</link>
      <description>&lt;p&gt;The fourth week of coding period has ended and now it&amp;#8217;s time for phase-I evaluations. Below, is a brief progress report of the project.&lt;/p&gt;

&lt;p&gt;The tasks that were proposed in the proposal for phase-I consists of:&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;Implementation of Abelian Invariants&lt;/li&gt;
  &lt;li&gt;Implementation of Composition Series&lt;/li&gt;
  &lt;li&gt;Computation with Polycyclic groups&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;Abelian Invariants&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;Implemented a function to compute the abelian invariants for a given permutation or free group. These are given as a list of prime-powers and describe the stucture of &lt;code class="highlighter-rouge"&gt;G/G'&lt;/code&gt; as a direct product of cyclic groups of prime power order.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;PR link &lt;a href="https://github.com/sympy/sympy/pull/16670"&gt;Added method to calculate Abelian Invariants&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;Composition Series&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;Implemented a function to compute the composition series. It provides a way to break up a group into simple pieces. Composition series of a group &lt;code class="highlighter-rouge"&gt;G&lt;/code&gt; is defined as the maximal subnormal series &lt;code class="highlighter-rouge"&gt;G = H_0 &amp;gt; H_1 &amp;gt; H_2 ... &amp;gt; H_k = 1&lt;/code&gt; where every factor group &lt;code class="highlighter-rouge"&gt;H(i+1)/H(i)&lt;/code&gt; is simple.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;PR link &lt;a href="https://github.com/sympy/sympy/pull/16881"&gt;Added method for Composition Series computation&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;Polycyclic Groups&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;The work on polycyclic group is in progress. For now, collection algorithm has been implemented which needs to be tested and a lot of discussions were made on the polycyclic generating sequence and its presentation and may be in a week we&amp;#8217;ll be ready with the stucture of polycyclic groups and collection of words.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;PR link &lt;a href="https://github.com/sympy/sympy/pull/16991"&gt;Added Polycyclic Group Class&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;Documentation&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;Some documentation is done to increase the sphinx coverage of SymPy.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;PR link &lt;a href="https://github.com/sympy/sympy/pull/16809"&gt;Increase Accessibility of docstrings from Sphinx&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;To follow the discussion on above topics and the further progress of the project one can check Gitter room &lt;a href="https://gitter.im/sympy/GroupTheory"&gt;sympy/GroupTheory&lt;/a&gt;&lt;/p&gt;</description>
    </item>
    <item>
      <guid isPermaLink="false">https://shubhamkjha.github.io/2019/06/24/GSoC-2019-Week-4</guid>
      <author>Shubham Kumar Jha (ShubhamKJha)</author>
      <title>Shubham Kumar Jha (ShubhamKJha): GSoC 2019: Week 4</title>
      <pubDate>Mon, 24 Jun 2019 00:00:00 GMT</pubDate>
      <link>https://shubhamkjha.github.io/2019/06/24/GSoC-2019-Week-4.html</link>
      <description>&lt;p&gt;With this the fourth week and the first phase of GSoC 2019 is over. Here I will give you a brief summary of my progress this week.&lt;/p&gt;

&lt;p&gt;I started this week by setting up my workspace for profiling the code related to new assumptions. I am using &lt;code class="highlighter-rouge"&gt;pyinstrument&lt;/code&gt; for that. The results of profiler suggests that a significant amount of time is spent in the &lt;code class="highlighter-rouge"&gt;to_cnf()&lt;/code&gt; function which converts the logical expression into their CNF counterparts, to be used by the SAT solver. Also, since this system is built over the SymPy core, a large amount of this time is spent in the core itself (See the graph &lt;a href="https://github.com/sympy/sympy/issues/17066#issuecomment-504774120"&gt;here&lt;/a&gt;). A possible solution to this is to use constructs at a level lower than the SymPy objects, hence removing the overheads.&lt;/p&gt;

&lt;p&gt;Also, as suggested in the last blog, there are various ideas proposed for improving the new assumptions mechanism. Some of them have been implemented to some extent in some PRs. Before proceeding for any new strategies, I need to look into these ideas first. I have started an &lt;a href="https://github.com/sympy/sympy/issues/17066"&gt;issue-tree&lt;/a&gt; to gather them.&lt;/p&gt;

&lt;p&gt;Over the end of the week, I also pushed my work on &lt;code class="highlighter-rouge"&gt;First Order Logic&lt;/code&gt; module at &lt;a href="https://github.com/sympy/sympy/pull/17069"&gt;#17069&lt;/a&gt;. This work is based on &lt;a href="https://github.com/sympy/sympy/pull/7608"&gt;#7608&lt;/a&gt; and extends it by adding &lt;code class="highlighter-rouge"&gt;Equality&lt;/code&gt; to it. Currently, there are test failures and some points to decide. I will try to get it done within this week.&lt;/p&gt;

&lt;p&gt;I spent most of this week exploring the profiling and benchmarking of code, and I learnt a lot during this. For the coming week, I will focus on speeding up the code in &lt;code class="highlighter-rouge"&gt;to_cnf&lt;/code&gt;. As suggested by Aaron, &lt;a href="https://github.com/sympy/sympy/pull/11789"&gt;this&lt;/a&gt; seems a good point to start with. Also, I will be working on the &lt;code class="highlighter-rouge"&gt;FOL&lt;/code&gt; module.&lt;/p&gt;</description>
    </item>
    <item>
      <guid isPermaLink="false">http://ishanaj.wordpress.com/?p=52</guid>
      <author>Ishan Joshi (ishanaj)</author>
      <title>Ishan Joshi (ishanaj): GSoC&#x2019;19: Week-4-Starting with Column Buckling implementation</title>
      <pubDate>Sun, 23 Jun 2019 18:41:36 GMT</pubDate>
      <link>https://ishanaj.wordpress.com/2019/06/24/gsoc19-week-4-starting-with-column-buckling-implementation/</link>
      <description>&lt;p&gt;Finalizing what had been discussed in &lt;a href="https://github.com/sympy/sympy/pull/16964"&gt;PR #16964&lt;/a&gt; for integrating geometry module with the beam module,&lt;a href="https://github.com/sympy/sympy/pull/17055"&gt; PR #17055&lt;/a&gt; was opened which is now ready to go!&lt;/p&gt;
&lt;p&gt;There is no special function for defining the cross-section of a Beam object. A user can simply pass the geometry object as a parameter instead of the &lt;strong&gt;second_moment, &lt;/strong&gt;and the corresponding second moment would be calculated internally. The example below might explain this better:&lt;/p&gt;
&lt;pre class="brush: python; collapse: false; title: ; wrap-lines: false; notranslate"&gt;

&amp;gt;&amp;gt;&amp;gt; b = Beam(l, E, Circle((0, 0), r))

&amp;gt;&amp;gt;&amp;gt; b.second_moment

pi*r*Abs(r)**3/4

&amp;gt;&amp;gt;&amp;gt; b.cross_section

Circle(Point2D(0, 0), r)

&lt;/pre&gt;
&lt;p&gt;Further, the &lt;strong&gt;cross_section&lt;/strong&gt; attribute can be changed even after the beam is created. Every time the &lt;strong&gt;cross_section&lt;/strong&gt; is assigned a new value, the &lt;strong&gt;second_moment&lt;/strong&gt; gets automatically updated.&lt;/p&gt;
&lt;p&gt;Similarly, every time the user changes the &lt;strong&gt;second_moment&lt;/strong&gt; explicitly after the creation of the beam, the previous &lt;strong&gt;cross_section&lt;/strong&gt; gets destroyed, or in other words, the &lt;strong&gt;cross_section&lt;/strong&gt; is set to None.&lt;/p&gt;
&lt;pre class="brush: python; collapse: false; title: ; wrap-lines: false; notranslate"&gt;

&amp;gt;&amp;gt;&amp;gt; b = Beam(l, E, Circle((0, 0), r))

&amp;gt;&amp;gt;&amp;gt; I&amp;#160; = Symbol(&amp;#8216;I&amp;#8217;)

&amp;gt;&amp;gt;&amp;gt; b.second_moment = I

&amp;gt;&amp;gt;&amp;gt; b.cross_section

None

&amp;gt;&amp;gt;&amp;gt; b.second_moment = Polygon((0, 0), (a, 0), (a, b), (0, b))

ValueError: To update cross-section geometry use `cross_section` attribute

&lt;/pre&gt;
&lt;p&gt;The PR is complete and just needs the final approval from the mentors.&lt;/p&gt;
&lt;p&gt;Simultaneously, I had worked on the column buckling calculations which is a part of the stage &amp;#8211;II.&lt;/p&gt;
&lt;p&gt;I have opened an &lt;a href="https://github.com/sympy/sympy/issues/17072"&gt;issue-cum-discussion&lt;/a&gt; for discussing its API and further implementations.&lt;/p&gt;
&lt;p&gt;Since the calculations of the Column Buckling are very much different from those of beam bending, we will have to make a separate class Column. The basic API and the way the calculations are supposed to go can be seen from the stage &amp;#8211;II in the &lt;a href="https://docs.google.com/document/d/1LOtMTr9cCrzQ8_OnKrgkZs8wFS9N9PxlR10h3aKG0jg/edit?usp=sharing"&gt;proposal&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;I would be making a PR for column buckling calculations within a day or two, once some initial questions (as mentioned in the issue-cum-discussion) gets clarified.&lt;/p&gt;
&lt;h2&gt;Next Week:&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;Finalizing the basic API and implementations of Column class&lt;/li&gt;
&lt;li&gt;Making a PR for the above implementations&lt;/li&gt;
&lt;li&gt;Documentation and testing&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Will keep you updated!&lt;/p&gt;
&lt;p&gt;Thanks!&lt;/p&gt;</description>
    </item>
    <item>
      <guid isPermaLink="false">https://arighnaiitg.github.io/2019-06-23-gsoc-week4/</guid>
      <author>Arighna Chakrabarty (arighnaiitg)</author>
      <title>Arighna Chakrabarty (arighnaiitg): GSoC Week 4 !!</title>
      <pubDate>Sun, 23 Jun 2019 07:00:00 GMT</pubDate>
      <link>https://arighnaiitg.github.io/2019-06-23-gsoc-week4/</link>
      <description>&lt;p&gt;Week 4 ends.. - 
          Week 4 and the final week of the first phase of the Coding Period is coming to an end. The work, which was initially proposed to be done in FormalPowerSeries has been done on a term-by-term level, i.e. the operations which have been implemented return truncated terms of the resultant...</description>
    </item>
    <item>
      <guid isPermaLink="false">https://czgdp1807.github.io/week_4</guid>
      <author>Gagandeep Singh (czgdp1807)</author>
      <title>Gagandeep Singh (czgdp1807): Week 4 - Phase 1 Ends</title>
      <pubDate>Sun, 23 Jun 2019 00:00:00 GMT</pubDate>
      <link>https://czgdp1807.github.io/week_4/</link>
      <description>&lt;p&gt;So, with the fourth week, the first phase of my journey with &lt;code class="highlighter-rouge"&gt;SymPy&lt;/code&gt; has come to an end. This blog post summarises the work done till now, in terms of PRs. Moreover, I will share with you the plans for phase 2.&lt;/p&gt;

&lt;p&gt;I worked on the following PRs(listed in chronological order) during the first phase, many of them got merged and few are open.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Merged&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href="https://github.com/sympy/sympy/pull/16528"&gt;#16528&lt;/a&gt; : I worked on extending the &lt;code class="highlighter-rouge"&gt;GumbelDistribution&lt;/code&gt; to  support both minimum and maximum versions of it.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href="https://github.com/sympy/sympy/pull/16576"&gt;#16576&lt;/a&gt;: This PR added &lt;code class="highlighter-rouge"&gt;Dirichlet&lt;/code&gt; and &lt;code class="highlighter-rouge"&gt;MultivariteEwens&lt;/code&gt; distributions.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href="https://github.com/sympy/sympy/pull/16808"&gt;#16808&lt;/a&gt; : This PR added &lt;code class="highlighter-rouge"&gt;Multinomial&lt;/code&gt; and &lt;code class="highlighter-rouge"&gt;NegativeMultinomial&lt;/code&gt; distribution.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href="https://github.com/sympy/sympy/pull/16810"&gt;#16810&lt;/a&gt; : This PR improved the API of &lt;code class="highlighter-rouge"&gt;Sum&lt;/code&gt; by allowing &lt;code class="highlighter-rouge"&gt;Range&lt;/code&gt; as the limits.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href="https://github.com/sympy/sympy/pull/16825"&gt;#16825&lt;/a&gt; : This PR in continuation, added &lt;code class="highlighter-rouge"&gt;GeneralizedMultivariateLogGamma&lt;/code&gt; distribution. This was an interesting one due to the complexity involved in its PDF.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href="https://github.com/sympy/sympy/pull/16834"&gt;#16834&lt;/a&gt; : This PR enhanced the &lt;code class="highlighter-rouge"&gt;Multinomial&lt;/code&gt; and &lt;code class="highlighter-rouge"&gt;NegativeMultinomial&lt;/code&gt; distributions by allowing symbolic dimensions for them.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href="https://github.com/sympy/sympy/pull/16897"&gt;#16897&lt;/a&gt; : This was related to &lt;code class="highlighter-rouge"&gt;sympy.core&lt;/code&gt; and it helped in removing disparity in the results of special function &lt;code class="highlighter-rouge"&gt;gamma&lt;/code&gt;.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href="https://github.com/sympy/sympy/pull/16899"&gt;#16899&lt;/a&gt; : This was a workflow related to PR to ignore the &lt;code class="highlighter-rouge"&gt;.vscode&lt;/code&gt; folder.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href="https://github.com/sympy/sympy/pull/16908"&gt;#16908&lt;/a&gt; : This PR improved &lt;code class="highlighter-rouge"&gt;sympy.stats.frv&lt;/code&gt; by allowing conditions with foriegn symbols.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href="https://github.com/sympy/sympy/pull/16913"&gt;#16913&lt;/a&gt; : This removed the unreachable code from &lt;code class="highlighter-rouge"&gt;sympy.stats.frv&lt;/code&gt;.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href="https://github.com/sympy/sympy/pull/16914"&gt;#16914&lt;/a&gt; : This PR allowed symbolic dimensions to &lt;code class="highlighter-rouge"&gt;MultivariateEwens&lt;/code&gt; distribution.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href="https://github.com/sympy/sympy/pull/16929"&gt;#16929&lt;/a&gt; : This one was for the &lt;code class="highlighter-rouge"&gt;sympy.tensor&lt;/code&gt; module. It optimized the &lt;code class="highlighter-rouge"&gt;ArrayComprehension&lt;/code&gt; and covered some corner cases.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href="https://github.com/sympy/sympy/pull/16981"&gt;#16981&lt;/a&gt; : This PR added the architecture of stochastic processes. It also added discrete Markov chain to &lt;code class="highlighter-rouge"&gt;sympy.stats&lt;/code&gt;.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href="https://github.com/sympy/sympy/pull/17003"&gt;#17003&lt;/a&gt; : This PR ignored the &lt;code class="highlighter-rouge"&gt;__pycahce__&lt;/code&gt; folder by adding it &lt;code class="highlighter-rouge"&gt;.gitignore&lt;/code&gt; file.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href="https://github.com/sympy/sympy/pull/17030"&gt;#17030&lt;/a&gt; : Some features like, &lt;code class="highlighter-rouge"&gt;joint_dsitribution&lt;/code&gt; were added in this PR.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href="https://github.com/sympy/sympy/pull/17046"&gt;#17046&lt;/a&gt; : Some common properties of discrete Markov chains, like fundamental matrix, fixed row vector were added.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;Open&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href="https://github.com/sympy/sympy/pull/16962"&gt;#16962&lt;/a&gt; : The aim of this PR is to allow symbolic dimensions to single finite distributions, like &lt;code class="highlighter-rouge"&gt;Die&lt;/code&gt;, &lt;code class="highlighter-rouge"&gt;Binomial&lt;/code&gt;. The work from my side is complete on this.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href="https://github.com/sympy/sympy/pull/16934"&gt;#16934&lt;/a&gt; : This PR aims to fix the bugs and test the code introduced in &lt;code class="highlighter-rouge"&gt;GSoC&lt;/code&gt; 2018.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Apart from the above PRs I also reviewed code written by other contributors.
Overall, according to me phase 1 was a great learning and working experience.&lt;/p&gt;

&lt;p&gt;Let me share with you my plan for phase 2. Since, I will be working on random matrices during the upcoming phase, I have started the discussions for design with my mentors and things are taking shape. However, apart from random matrices, I will also work on few more general improvements for my phase 1 work.&lt;/p&gt;

&lt;p&gt;The outline is given below,&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;I will work on extending the scope of queries handeled by discrete Markov chains by covering some uncommon cases.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Some work will be done to extend the &lt;code class="highlighter-rouge"&gt;DiscreteMarkovChain&lt;/code&gt; by adding &lt;code class="highlighter-rouge"&gt;ContinuousMarkovChain&lt;/code&gt; as the latter is almost same but with some extra parameters.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;I will implement random matrices and its various Gaussian ensembles according to the conclusion of the design discussions.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Last but not the least, I will try to merge my open PRs.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;Thanks for reading and see you soon in phase 2. Bye!!&lt;/p&gt;</description>
    </item>
    <item>
      <guid isPermaLink="false">https://ritesh99rakesh.github.io/Sympy_post6</guid>
      <author>Ritesh Kumar (ritesh99rakesh)</author>
      <title>Ritesh Kumar (ritesh99rakesh): Week 4</title>
      <pubDate>Sun, 23 Jun 2019 00:00:00 GMT</pubDate>
      <link>https://ritesh99rakesh.github.io/Sympy_post6/</link>
      <description>&lt;p&gt;Phase I has ended and here are the details of the PRs I have raised: #16935 #16843 #16848 #16858 #16886 #16888 #16970 #17004 #17033 #17036 #17068 #17070 #17076 #17077 Many of the above PRs are merged and some are open. I will work to get other merged. My plan for second phase: Complete the sampling method and finish the exporting of random variables to external libraries. I will work on Compound distributions and will finish it in the phase 2. I will add Wishart and Inverse Wishart distributions after multigamma function is merged. I will also discuss the implementation of Random Walks and will start working on the PR. This phase was a great learning experience. That&amp;#8217;s all from my side. Namaste!</description>
    </item>
    <item>
      <guid isPermaLink="false">https://jmig5776.github.io//gsoc-week-4</guid>
      <author>Jogi Miglani (jmig5776)</author>
      <title>Jogi Miglani (jmig5776): GSoC 2019 - Week 4</title>
      <pubDate>Sat, 22 Jun 2019 00:00:00 GMT</pubDate>
      <link>https://jmig5776.github.io//gsoc-week-4</link>
      <description>&lt;p&gt;This was the fourth week meeting with the GSoC mentors which was scheduled on
Sunday 22th June, 2019 between 12:30 - 01:30 PM (IST). Me and Yathartha
were the attendees of the meeting.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Discussing previous week&amp;#8217;s progress&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;In the previous week many things happened very suddenly. In the starting of the
week it was decided that we had to create a function &lt;code class="highlighter-rouge"&gt;power_list&lt;/code&gt; which could
return powers. So I thought to create this type of function as a new feature in
this PR &lt;a href="https://github.com/sympy/sympy/pull/17043"&gt;#17043&lt;/a&gt;.
But as @jksoum and @smichr advised that this function can act as
helper function in &lt;code class="highlighter-rouge"&gt;bivariate&lt;/code&gt; itself so it was decided to make it as helper
function there. And we discussed the code for handling modular equations also.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;Next week goals&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Implementing and get plan for defining imageset union&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;As per the timeline we decided that Imageset Union should be defined first rather
than code for handling nested trigonometric equation solver. So according to
timeline this week goes for discussion and getting plan for implementing imageset
union. A PR &lt;a href="https://github.com/sympy/sympy/pull/17079"&gt;#17079&lt;/a&gt; is also started
based on fundamental approach to solve the problem.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Getting merge Lambert Solver&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Most of the work had been done only a little improvement is to be done in &lt;code class="highlighter-rouge"&gt;power_list&lt;/code&gt;
function. Hope it gets merged by this week.&lt;/p&gt;

&lt;p&gt;Code improvement takes time!!&lt;/p&gt;</description>
    </item>
    <item>
      <guid isPermaLink="false">https://sc0rpi0n101.github.io/2019/06/week-4-the-fortran-parser-is-finally-here/</guid>
      <author>Nikhil Maan (Sc0rpi0n101)</author>
      <title>Nikhil Maan (Sc0rpi0n101): Week 4: The Fortran Parser is finally here</title>
      <pubDate>Sat, 22 Jun 2019 00:00:00 GMT</pubDate>
      <link>https://sc0rpi0n101.github.io/2019/06/week-4-the-fortran-parser-is-finally-here/</link>
      <description>&lt;p&gt;&amp;ldquo;When someone says: &amp;lsquo;I want a programming language in which I need only say what I wish done&amp;rsquo;, give him a lollipop.&amp;rdquo;  &amp;#8212; Alan J. Perlis in Software Metrics
 Welcome everyone, this is your host Nikhil Maan aka Sc0rpi0n101 and this week has been relatively a little odd. The week started a little slow but slowly it turned out to be a good and productive week.</description>
    </item>
    <item>
      <guid isPermaLink="false">https://anpandey.github.io/posts/sympy/2019-06-21-weeks-3-and-4.html</guid>
      <author>Ankit Pandey (anpandey)</author>
      <title>Ankit Pandey (anpandey): Google Summer of Code Weeks 3 and 4: Matrix Optimizations</title>
      <pubDate>Fri, 21 Jun 2019 00:00:00 GMT</pubDate>
      <link>https://anpandey.github.io/posts/sympy/2019-06-21-weeks-3-and-4.html</link>
      <description>&lt;p&gt;&lt;em&gt;See the &lt;a href="https://anpandey.github.io/2019-06-07-week-2.html"&gt;previous post&lt;/a&gt; for Week 2&lt;/em&gt;.&lt;/p&gt;
&lt;p&gt;I spent a large part of last week travelling, so I&amp;#8217;m combining the blog posts for the last two weeks.&lt;/p&gt;
&lt;h2 id="finishing-up-with-lfortran"&gt;Finishing up with LFortran&lt;/h2&gt;
&lt;p&gt;I&amp;#8217;m finished with the &lt;a href="https://github.com/sympy/sympy/pull/16931"&gt;pull request&lt;/a&gt; for the LFortran code printer for now, though it&amp;#8217;s definitely way too incomplete to be merged. The code passes &lt;em&gt;most&lt;/em&gt; of the rudimentary tests I&amp;#8217;ve added.&lt;/p&gt;
&lt;p&gt;Here&amp;#8217;s a simple example of one of the failing LFortran tests: Suppose we want to generate Fortran (using LFortran) code from the mathematical expression &lt;span class="math inline"&gt;&amp;#8197;&amp;#8722;&amp;#8197;&lt;em&gt;x&lt;/em&gt;&lt;/span&gt;. SymPy sees this expression as multiplication with -1, as it implements only addition and multiplication in its arithmetic operations:&lt;/p&gt;
&lt;div class="sourceCode" id="cb1"&gt;&lt;pre class="sourceCode python"&gt;&lt;code class="sourceCode python"&gt;&lt;a class="sourceLine" id="cb1-1" title="1"&gt;&lt;span class="op"&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class="im"&gt;from&lt;/span&gt; sympy &lt;span class="im"&gt;import&lt;/span&gt; &lt;span class="op"&gt;*&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb1-2" title="2"&gt;&lt;span class="op"&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt; x &lt;span class="op"&gt;=&lt;/span&gt; Symbol(&lt;span class="st"&gt;'x'&lt;/span&gt;)&lt;/a&gt;
&lt;a class="sourceLine" id="cb1-3" title="3"&gt;&lt;span class="op"&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt; srepr(&lt;span class="op"&gt;-&lt;/span&gt;x)&lt;/a&gt;
&lt;a class="sourceLine" id="cb1-4" title="4"&gt;&lt;span class="co"&gt;&amp;quot;Mul(Integer(-1), Symbol('x'))&amp;quot;&lt;/span&gt;&lt;/a&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Directly converting same mathematical expression in Fortran as &lt;code&gt;-x&lt;/code&gt; we can see that LFortran instead sees it as unary subtraction:&lt;/p&gt;
&lt;div class="sourceCode" id="cb2"&gt;&lt;pre class="sourceCode python"&gt;&lt;code class="sourceCode python"&gt;&lt;a class="sourceLine" id="cb2-1" title="1"&gt;&lt;span class="op"&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class="im"&gt;from&lt;/span&gt; lfortran &lt;span class="im"&gt;import&lt;/span&gt; &lt;span class="op"&gt;*&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb2-2" title="2"&gt;&lt;span class="op"&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt; src_to_ast(&lt;span class="st"&gt;&amp;quot;-x&amp;quot;&lt;/span&gt;, &lt;span class="va"&gt;False&lt;/span&gt;)&lt;/a&gt;
&lt;a class="sourceLine" id="cb2-3" title="3"&gt;&lt;span class="op"&gt;&amp;lt;&lt;/span&gt;lfortran.ast.ast.UnaryOp &lt;span class="bu"&gt;object&lt;/span&gt; at &lt;span class="bn"&gt;0x7f9027f1aba8&lt;/span&gt;&lt;span class="op"&gt;&amp;gt;&lt;/span&gt;&lt;/a&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;This is a major problem for the tests, which right now look to see if the Lfortran-parsed output of &lt;code&gt;fcode&lt;/code&gt; (SymPy&amp;#8217;s current Fortran code generator) on an expression matches the same directly translated AST. This won&amp;#8217;t be true for &lt;span class="math inline"&gt;&amp;#8197;&amp;#8722;&amp;#8197;&lt;em&gt;x&lt;/em&gt;&lt;/span&gt;, since the translated expression is a multiplication &lt;code&gt;BinOp&lt;/code&gt; while the parsed expression in an &lt;code&gt;UnaryOp&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;One solution might be to not parse &lt;code&gt;fcode&lt;/code&gt;&amp;#8217;s output and instead just check for equivalence between strings. This would mean dealing with the quirks of the code printers (such as their tendency to produce excessive parenthesis), and take away some of the advantages of direct translation. The more probable solution would be to introduce substitution rules within the LFortran AST.&lt;/p&gt;
&lt;h2 id="missing-matrix-nodes"&gt;Missing matrix nodes&lt;/h2&gt;
&lt;p&gt;I filed issue &lt;a href="https://github.com/sympy/sympy/issues/17006"&gt;#17006&lt;/a&gt;, in which &lt;code&gt;lambdify&lt;/code&gt; misinterpreted identity matrices as the imaginary unit. The fix in &lt;a href="https://github.com/sympy/sympy/pull/17022"&gt;#17022&lt;/a&gt; is pretty simple: just generate identity matrices with &lt;code&gt;np.eye&lt;/code&gt; when we can.&lt;/p&gt;
&lt;p&gt;I also went through the matrix expression classes to see which ones weren&amp;#8217;t supported by the NumPy code printer and filed issue &lt;a href="https://github.com/sympy/sympy/issues/17013"&gt;#17013&lt;/a&gt;. These are addressed by another contributor in &lt;a href="https://github.com/sympy/sympy/pull/17029%5D"&gt;#17029&lt;/a&gt;.&lt;/p&gt;
&lt;h2 id="rewriting-matrix-inversion"&gt;Rewriting matrix inversion&lt;/h2&gt;
&lt;p&gt;Most of this week was spent on implementing an optimization for the NumPy generator suggested by Aaron: given the expression &lt;span class="math inline"&gt;&lt;em&gt;A&lt;/em&gt;&lt;sup&gt;&amp;#8197;&amp;#8722;&amp;#8197;1&lt;/sup&gt;&lt;em&gt;b&lt;/em&gt;&lt;/span&gt; where &lt;span class="math inline"&gt;&lt;em&gt;A&lt;/em&gt;&lt;/span&gt; is a square matrix and &lt;span class="math inline"&gt;&lt;em&gt;b&lt;/em&gt;&lt;/span&gt; a vector, generate the expression &lt;code&gt;np.linalg.solve(A, b)&lt;/code&gt; instead of &lt;code&gt;np.linalg.inv(A) * b&lt;/code&gt;. While both &lt;code&gt;solve&lt;/code&gt; and &lt;code&gt;inv&lt;/code&gt; use the same LU-decomposition based LAPACK &lt;a href="http://www.netlib.org/lapack95/DOC/la_gesv.txt"&gt;&lt;code&gt;?gesv&lt;/code&gt;&lt;/a&gt; functions &lt;a class="footnote-ref" href="https://anpandey.github.io/atom-sympy.xml#fn1" id="fnref1"&gt;&lt;sup&gt;1&lt;/sup&gt;&lt;/a&gt;, &lt;code&gt;solve&lt;/code&gt; is called on a vector while the &lt;code&gt;inv&lt;/code&gt; on a (much larger) matrix. In addition to cutting down on the number of operations, this optimization might also remove any errors introduced in calculating the inverse.&lt;/p&gt;
&lt;p&gt;My pull request for this optimization is available at &lt;a href="https://github.com/sympy/sympy/pull/17041"&gt;#17041&lt;/a&gt;, which uses SymPy&amp;#8217;s assumption system to make sure that &lt;span class="math inline"&gt;&lt;em&gt;A&lt;/em&gt;&lt;/span&gt; is full-rank (a constraint imposed by &lt;code&gt;solve&lt;/code&gt;). My initial approach was to embed these optimizations directly in the code printing base classes. After some discussion with Bj&amp;#246;rn, we decided it would be better to separate optimization from printing as much as possible, leading to the representation of the solving operation as its own distinct AST node. This approach is much better than the original, since it was fairly easy to the optimization to the Octave/Matlab code printer.&lt;/p&gt;
&lt;h2 id="next-steps"&gt;Next Steps&lt;/h2&gt;
&lt;p&gt;For this week, I&amp;#8217;ll be continuing with the matrix optimization PR. I&amp;#8217;ll try to find other optimizations that can be applied (such as the evaluation order of complicated matrix expressions) and look into using Sympy&amp;#8217;s unification capabilities in simplifying the expression of optimization rules.&lt;/p&gt;
&lt;section class="footnotes"&gt;
&lt;hr /&gt;
&lt;ol&gt;
&lt;li id="fn1"&gt;&lt;p&gt;You can find the C definitions for the functions eventually called by &lt;a href="https://github.com/numpy/numpy/blob/b80d360e/numpy/linalg/umath_linalg.c.src#L1694"&gt;&lt;code&gt;inv&lt;/code&gt;&lt;/a&gt; and &lt;a href="https://github.com/numpy/numpy/blob/b80d360e/numpy/linalg/umath_linalg.c.src#L1622"&gt;&lt;code&gt;solve&lt;/code&gt;&lt;/a&gt;. These are written in a special templated version of C, but you can find the &lt;a href="https://github.com/numpy/numpy/blob/b80d360e/numpy/linalg/umath_linalg.c.src#L1560"&gt;template variable definitions&lt;/a&gt; a bit higher up in the source.&lt;a class="footnote-back" href="https://anpandey.github.io/atom-sympy.xml#fnref1"&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;/section&gt;</description>
    </item>
    <item>
      <guid isPermaLink="false">https://arighnaiitg.github.io/2019-06-19-gsoc-week3/</guid>
      <author>Arighna Chakrabarty (arighnaiitg)</author>
      <title>Arighna Chakrabarty (arighnaiitg): GSoC Week 3 !!</title>
      <pubDate>Wed, 19 Jun 2019 07:00:00 GMT</pubDate>
      <link>https://arighnaiitg.github.io/2019-06-19-gsoc-week3/</link>
      <description>&lt;p&gt;Week 3 ends.. - 
          Week 3 of the first phase of this coding period is coming to an end. The week started with a bad note, given that I had fallen sick due to travelling. But the work in Week 2, and the meeting with Sartaj on 11th of June helped me to progress...</description>
    </item>
    <item>
      <guid isPermaLink="false">https://divyanshu132.github.io//gsoc-week-3</guid>
      <author>Divyanshu Thakur (divyanshu132)</author>
      <title>Divyanshu Thakur (divyanshu132): GSoC 2019 - Week 3 - Polycyclic Groups</title>
      <pubDate>Mon, 17 Jun 2019 00:00:00 GMT</pubDate>
      <link>https://divyanshu132.github.io//gsoc-week-3</link>
      <description>&lt;p&gt;The third week has ended and a good amount of work has been done on polycyclic groups PR &lt;a href="https://github.com/sympy/sympy/pull/16991"&gt;here&lt;/a&gt;. The collection algorithm has been implemented, from the beginning of the week, I started with understanding the algorithm which took some time and then finally it was implemented, still we are facing a problem in type conversion(&lt;a href="https://github.com/sympy/sympy/pull/16991#discussion_r294054681"&gt;here&lt;/a&gt;) but that will be sorted out soon!&lt;/p&gt;

&lt;p&gt;Even though only two weeks were alloted for polycyclic group implementation but it seems we need one more week or maybe more than a week to implement more functionalities for pc groups. But it&amp;#8217;s completely fine because we started work early and according to the proposed timeline we still have one week.&lt;/p&gt;

&lt;p&gt;Few of the issues with the current implementation which needs to be sorted out are:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;firstly to &lt;code class="highlighter-rouge"&gt;compute uncollected subwords&lt;/code&gt; the word is manipulated using its &lt;code class="highlighter-rouge"&gt;array_form&lt;/code&gt; which eventually leads to change in the type of the subwords computed and it creates a problem in processing these subwords further.&lt;/li&gt;
  &lt;li&gt;Some more issues were pointed out by Kalevi and can be seen in the comments of the PR.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;The complete week was spent implementing collection of words so a lot of tasks targeted last week were not completed, I&amp;#8217;ll try to cover those tasks in the upcomming week.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Solve the issues with collection of words.&lt;/li&gt;
  &lt;li&gt;Get ready with the pc presentation.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Till then, Good byee..!&lt;/p&gt;</description>
    </item>
    <item>
      <guid isPermaLink="false">https://shubhamkjha.github.io/2019/06/17/GSoC-2019-Week-3</guid>
      <author>Shubham Kumar Jha (ShubhamKJha)</author>
      <title>Shubham Kumar Jha (ShubhamKJha): GSoC 2019: Week 3</title>
      <pubDate>Mon, 17 Jun 2019 00:00:00 GMT</pubDate>
      <link>https://shubhamkjha.github.io/2019/06/17/GSoC-2019-Week-3.html</link>
      <description>&lt;p&gt;The third week of coding period has ended and as I already stated in the last blog, I couldn&amp;#8217;t be much productive this week. Nevertheless, I tried to wrap-up some unfinished works. PR &lt;a href="https://github.com/sympy/sympy/pull/16956"&gt;#16956&lt;/a&gt; is ready to merge, just waiting for some last reviews. This PR needs to be supplemented with some fixes in the code of &lt;code class="highlighter-rouge"&gt;Add&lt;/code&gt; class to handle all the issues over &lt;code class="highlighter-rouge"&gt;Relationals&lt;/code&gt;. PR &lt;a href="https://github.com/sympy/sympy/pull/16978"&gt;#16978&lt;/a&gt; had one major failing test from the &lt;code class="highlighter-rouge"&gt;stats&lt;/code&gt; module. I tried to debug it ,but due to my unfamiliarity with that part of code I took help from &lt;a href="https://github.com/czgdp1807"&gt;Gagandeep&lt;/a&gt; and as his &lt;a href="https://github.com/sympy/sympy/pull/16978#discussion_r294039337"&gt;comment&lt;/a&gt; suggests, the result this PR is giving is correct and more intuitive. At least, one less issue to handle &amp;#128524;.&lt;/p&gt;

&lt;p&gt;Over the end of the week, I shifted my focus towards &lt;em&gt;New Assumptions&lt;/em&gt;. One of my major tasks for this summer is to speed up the &lt;em&gt;satask&lt;/em&gt; module. As suggested by Aaron, I searched the repository for issues and PRs over this, and I found a number of such unfinished work. I would need to study these ideas and profile the results before working ahead. I would create a issue-tree over it connecting all such PRs and there respective benchmarks.&lt;/p&gt;

&lt;p&gt;For this week, I would focus on the above mentioned task only. Since the first phase is about to end, I would have to speed things up.&lt;/p&gt;</description>
    </item>
    <item>
      <guid isPermaLink="false">https://www.kangzhiq.com/?p=20</guid>
      <author>Zhiqi KANG (kangzhiq)</author>
      <title>Zhiqi KANG (kangzhiq): [GSoC 2019] WEEK 3!</title>
      <pubDate>Sun, 16 Jun 2019 22:11:07 GMT</pubDate>
      <link>https://www.kangzhiq.com/2019/06/17/gsoc-2019-week-3/</link>
      <description>&lt;p&gt;Hello, the third week ends! I am a little bit too busy to keep contributing on my GSoC project as the first two weeks. Fortunately, thank to the work of the past 2 weeks and the help of my mentors, I become more productive which compensates, more or less,  the lack of time.&lt;/p&gt;



&lt;ul&gt;&lt;li&gt;Overview&lt;/li&gt;&lt;/ul&gt;



&lt;p&gt;The task about sparse arrays nearly comes to an end which is the main goal for the first phase. I still have one case to be fixed but most of them are merged in to Sympy&amp;#8217;s master and are ready to be used. I started as well preparing for the next task: implementing more data structure for sparse arrays. This would be started in the next week and is supposed to be ended by the begining of phase 2.&lt;/p&gt;



&lt;ul&gt;&lt;li&gt;PRs&lt;/li&gt;&lt;/ul&gt;



&lt;p&gt;Several PR are merged this week for sparse arrays operations.  &lt;a href="https://github.com/sympy/sympy/pull/16937"&gt;#16937&lt;/a&gt;  is finally merged with a code style much simpler than its first version.  &lt;a href="https://github.com/sympy/sympy/pull/16994"&gt;#16994&lt;/a&gt;  about __mul__ and __rmul__ is closed and replaced by &lt;a href="https://github.com/sympy/sympy/pull/17014"&gt;#17014&lt;/a&gt; due to a mistake about rebase. &lt;a href="https://github.com/sympy/sympy/pull/17026"&gt;#17026&lt;/a&gt;  about __div__ and __neg__ operators for sparse arrays is opened and merged.  &lt;a href="https://github.com/sympy/sympy/pull/17035"&gt;#17035&lt;/a&gt; about permutedims and transpose for sparse arrays is opened and reviewed by my mentor.&lt;/p&gt;



&lt;ul&gt;&lt;li&gt;Issues&lt;/li&gt;&lt;/ul&gt;



&lt;p&gt;No specific issue opened. The list in &lt;a href="https://github.com/sympy/sympy/issues/16941"&gt;#16941&lt;/a&gt; is continously being updated.&lt;/p&gt;



&lt;ul&gt;&lt;li&gt;Reviews&lt;/li&gt;&lt;/ul&gt;



&lt;p&gt;No review due to the lack of time.&lt;/p&gt;



&lt;ul&gt;&lt;li&gt;Related works&lt;/li&gt;&lt;/ul&gt;



&lt;p&gt;Pratice of rebasing and merging for a specific case: updated local repository from the upstream master after opening a PR. Even though I have broken the PR  &lt;a href="https://github.com/sympy/sympy/pull/16994"&gt;#16994&lt;/a&gt;, I am still happy to learn some new tricks that I didn&amp;#8217;t know before.&lt;/p&gt;



&lt;p&gt;Preparing a blog about presenting sparse array associated with my work in SymPy so that my contribution can indeed help people when they need to use this class but don&amp;#8217;t really know how to do it and what the advantage would be .&lt;/p&gt;</description>
    </item>
    <item>
      <guid isPermaLink="false">http://ishanaj.wordpress.com/?p=48</guid>
      <author>Ishan Joshi (ishanaj)</author>
      <title>Ishan Joshi (ishanaj): GSoC&#x2019;19: Week 3 &#x2013; Wrapping up Stage-I</title>
      <pubDate>Sun, 16 Jun 2019 19:20:32 GMT</pubDate>
      <link>https://ishanaj.wordpress.com/2019/06/17/gsoc19-week-3-wrapping-up-stage-i/</link>
      <description>&lt;p&gt;This week started with working on &lt;a href="https://github.com/sympy/sympy/pull/17001"&gt;PR #17001&lt;/a&gt;. The algorithm was extended to handle concave polygons as well. I came up with a new method which I have explained in the &lt;a href="https://github.com/sympy/sympy/wiki/A-method-to-return-a-cut-section-of-any-polygon-geometry"&gt;wiki page&lt;/a&gt; that I have created. It has to be tested against some symbolic coordinates to make it a complete method.&lt;/p&gt;
&lt;p&gt;The API of the CrossSection class has been changed as discussed in the last week. The documentation of the class has been completed.&lt;/p&gt;
&lt;p&gt;There were some discussions being done on the necessity and the importance of the CrossSection class. Despite the CrossSection class providing some very useful functionalities of calculating the section modulus, the first moment of area and polar modulus, is there really a need for such a class? After getting some pros and cons listed out we got to a conclusion, that it would probably be better to add these functionalities directly to the geometry module.&lt;/p&gt;
&lt;p&gt;But the question of complex geometries like T-shape and I-shape still remains. The alternative to this that we came up with in the discussion was Boolean operations on simple polygons. There are some clipping algorithms like Vatti algorithm and Greiner Hormann algorithm which might be helpful in implementing these.&lt;/p&gt;
&lt;p&gt;In short, this is what is left to be done:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Transferring the cross-sectional properties defined in the CrossSection class to the geometry module&lt;/li&gt;
&lt;li&gt;Making the beam class to accept any geometry instead of the second moment that is currently accepted from the user.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;In later stages, I might try to work on the Boolean operations as currently there is a limitation of time and the implementation of the stage -II awaits.&lt;/p&gt;
&lt;p&gt;After this, the stage-I would end and I will have to start with the next implementation i.e. the column buckling calculations&lt;/p&gt;
&lt;h2&gt;Next Week:&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;Completing leftovers of the previous week&lt;/li&gt;
&lt;li&gt;Starting off with stage-II&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;The work and the progress during the stage-I were full of ups and downs. Will try to make it smoother this time. Will try to discuss the implementations with the mentors and the members in even more detail. Hope to have a good coding week.&lt;/p&gt;
&lt;p&gt;Will keep you updated!&lt;/p&gt;
&lt;p&gt;Thanks!&lt;/p&gt;</description>
    </item>
    <item>
      <guid isPermaLink="false">https://czgdp1807.github.io/week_3</guid>
      <author>Gagandeep Singh (czgdp1807)</author>
      <title>Gagandeep Singh (czgdp1807): Week 3 - Evaluation is coming :P</title>
      <pubDate>Sun, 16 Jun 2019 00:00:00 GMT</pubDate>
      <link>https://czgdp1807.github.io/week_3/</link>
      <description>&lt;p&gt;Week 3 has ended and we are moving towards phase 1 evaluations by entering the fourth week. Let me tell you what all has been done during the previous week to make the last step smooth.&lt;/p&gt;

&lt;p&gt;The basic structure of stochastic process has been added with the merging of the PR &lt;a href="https://github.com/sympy/sympy/pull/16981"&gt;#16981&lt;/a&gt; and I am currently working on adding more features like, &lt;code class="highlighter-rouge"&gt;joint_distribution&lt;/code&gt;, &lt;code class="highlighter-rouge"&gt;expectation&lt;/code&gt; and may be some more according to the suggestions recieved from the community. You can read more about it, &lt;a href="https://github.com/sympy/sympy/pull/17030#issuecomment-502455179"&gt;here&lt;/a&gt;. So this was about some processes, now lets move to the case of symbolic dimensions. Well, I made a comment and the members showed agreement to that. I have made some updates to the PR &lt;a href="https://github.com/sympy/sympy/pull/16962"&gt;#16962&lt;/a&gt; and the summary is available at &lt;a href="https://github.com/sympy/sympy/pull/16962#issuecomment-502461264"&gt;this comment&lt;/a&gt;. I also discovered that docs of &lt;code class="highlighter-rouge"&gt;SymPy&lt;/code&gt; weren&amp;#8217;t being updated at &lt;code class="highlighter-rouge"&gt;https://docs.sympy.org&lt;/code&gt; for the &lt;code class="highlighter-rouge"&gt;stats&lt;/code&gt; module and therefore I modified the PR &lt;a href="https://github.com/sympy/sympy/pull/16934"&gt;#16934&lt;/a&gt;. For preparation of phase 2, I have created the issue &lt;a href="https://github.com/sympy/sympy/issues/17039"&gt;#17039&lt;/a&gt; for discussion on random matrices.&lt;/p&gt;

&lt;p&gt;So, what I learnt? Premature optimization is bad for the health of the code. Yes, while reviewing PRs I learnt that concept. I also got to know why some imports cannot be put at the top of the file, all due to a concept called, &lt;code class="highlighter-rouge"&gt;circular imports&lt;/code&gt;. Sounds intuitive and faced a lot earlier but wasn&amp;#8217;t aware of the exact term. Thanks to &lt;a href="https://github.com/leosartaj"&gt;leosartaj&lt;/a&gt; for this. I also tried the coverage tests on my local system with the help of &lt;a href="https://github.com/oscarbenjamin"&gt;oscarbenjamin&lt;/a&gt;. Read &lt;a href="https://github.com/sympy/sympy/pull/16981#issuecomment-502095724"&gt;this comment&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;That&amp;#8217;s it for now, bye!!&lt;/p&gt;</description>
    </item>
    <item>
      <guid isPermaLink="false">https://jmig5776.github.io//gsoc-week-3</guid>
      <author>Jogi Miglani (jmig5776)</author>
      <title>Jogi Miglani (jmig5776): GSoC 2019 - Week 3</title>
      <pubDate>Sun, 16 Jun 2019 00:00:00 GMT</pubDate>
      <link>https://jmig5776.github.io//gsoc-week-3</link>
      <description>&lt;p&gt;This was the third week meeting with the GSoC mentors which was scheduled on
Sunday 16th June, 2019 between 12:00 - 01:00 PM (IST). Me, Amit, Yathartha and
Shekhar were the attendees of the meeting. In this meeting mainly it was discussed
to improve the code quality and make routine of independent working code.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Code quality&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Every programmer should master this skill to write a good quality code. Everything from
naming, documentation to make routines includes in this skill.&lt;/p&gt;

&lt;p&gt;And we discussed mainly the code for the PR &lt;a href="https://github.com/sympy/sympy/pull/16890"&gt;#16890&lt;/a&gt;
and realising that a new function &lt;code class="highlighter-rouge"&gt;power_list&lt;/code&gt; to be made to return all the
powers of symbols present in an expression.&lt;/p&gt;

&lt;p&gt;Learning new skills!!&lt;/p&gt;</description>
    </item>
    <item>
      <guid isPermaLink="false">https://ritesh99rakesh.github.io/Sympy_post5</guid>
      <author>Ritesh Kumar (ritesh99rakesh)</author>
      <title>Ritesh Kumar (ritesh99rakesh): Week 3</title>
      <pubDate>Sun, 16 Jun 2019 00:00:00 GMT</pubDate>
      <link>https://ritesh99rakesh.github.io/Sympy_post5/</link>
      <description>&lt;p&gt;Week 3 has ended and o boy, what a week it has been. I was able to achieve quite a bit this week. Opened a PR for sampling methods, along the lines of Francesco Bonazzi&amp;#8217;s suggestion, and it has well receieved. I will continue my work to more it more robust and avoid code repetition as much as possible. I have started the discussion on Compound distributions and have started an issue regarding the same. I also went through the implementation of Joint distribution to see how it was structured and will take inspiration from it for implementation of Compound distribution. I also raised a PR for Compound distribution and will continue to work on it. In addition I also implemented some more distributions and factorial moment function for statistics module. I will try to get them merged before evaluation begin.</description>
    </item>
    <item>
      <guid isPermaLink="false">https://sc0rpi0n101.github.io/2019/06/week-3-whats-happening-where-have-i-been/</guid>
      <author>Nikhil Maan (Sc0rpi0n101)</author>
      <title>Nikhil Maan (Sc0rpi0n101): Week 3: What's Happening? Where have I been?</title>
      <pubDate>Sun, 16 Jun 2019 00:00:00 GMT</pubDate>
      <link>https://sc0rpi0n101.github.io/2019/06/week-3-whats-happening-where-have-i-been/</link>
      <description>&lt;p&gt;&amp;#8220;How did it get so late so soon?&amp;#8221;  &amp;#8213; Dr. Seuss
 Welcome everyone, this is your host Nikhil Maan aka Sc0rpi0n101 and we&amp;rsquo;re running late on everything this week. This time we will talk about some operating system stuff along with the week&amp;rsquo;s work. I will have more blogs on operating systems and that type of stuff soon. For now, let&amp;rsquo;s talk about what&amp;rsquo;s happening.
Why so Late?</description>
    </item>
    <item>
      <guid isPermaLink="false">https://shubhamkjha.github.io/2019/06/13/GSoC-2019-Week-2</guid>
      <author>Shubham Kumar Jha (ShubhamKJha)</author>
      <title>Shubham Kumar Jha (ShubhamKJha): GSoC 2019: Week 2</title>
      <pubDate>Thu, 13 Jun 2019 00:00:00 GMT</pubDate>
      <link>https://shubhamkjha.github.io/2019/06/13/GSoC-2019-Week-2.html</link>
      <description>&lt;p&gt;The second week of official coding period has concluded. I will give you a brief summary of the week&amp;#8217;s work.&lt;/p&gt;

&lt;p&gt;I started this week with working on PR &lt;a href="https://github.com/sympy/sympy/pull/16956"&gt;#16956&lt;/a&gt;, the PR is now passing tests. I will try to get it merged soon. Later this week, I tried to include &lt;code class="highlighter-rouge"&gt;complex -&amp;gt; finite&lt;/code&gt; in the assumptions system. I started PR &lt;a href="https://github.com/sympy/sympy/pull/16978"&gt;#16978&lt;/a&gt; over this. This PR changes the assumptions system to work over the &lt;code class="highlighter-rouge"&gt;complex -&amp;gt; finite&lt;/code&gt; clause. All the instances of use of &lt;code class="highlighter-rouge"&gt;is_complex&lt;/code&gt; call has to be modified. As suggested by Aaron, the &lt;code class="highlighter-rouge"&gt;is_complex&lt;/code&gt; call was changed with a disjunction of &lt;code class="highlighter-rouge"&gt;is_complex&lt;/code&gt; and &lt;code class="highlighter-rouge"&gt;is_infinite&lt;/code&gt; calls. Luckily for me, the usage of complex assumption was not much in the codebase &amp;#128524;. Though it meant less test failures to handle, the core assumptions system (in the old system) is quite complex to understand and debug, and hence handling all the failing tests proved quite difficult. Also, I tried to work on it without including any new assumptions to the system. One important result of this is, &lt;code class="highlighter-rouge"&gt;zoo.is_complex&lt;/code&gt; returns &lt;code class="highlighter-rouge"&gt;False&lt;/code&gt; now.&lt;/p&gt;

&lt;p&gt;Apart from that I have worked on to sync these changes in the new assumptions system as well and I will be sending PR over it soon.&lt;/p&gt;

&lt;p&gt;For the coming week,&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;I will start to work on SAT solver and to speed it up. As suggested by Aaron, I will first look into the other unfinished PRs over this.&lt;/li&gt;
  &lt;li&gt;I will sync the new assumptions with the recent developments in the old system.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;With enough said, these PRs made me realize how much the codebase can break with small changes in the assumptions. Also, I know this post is a little bit late(because of bad health). I have some pending work over from the last week and I will try to catch speed as soon as possible.&lt;/p&gt;</description>
    </item>
    <item>
      <guid isPermaLink="false">https://divyanshu132.github.io//gsoc-week-2</guid>
      <author>Divyanshu Thakur (divyanshu132)</author>
      <title>Divyanshu Thakur (divyanshu132): GSoC 2019 - Week 2 - Polycyclic Group Presentation in SymPy</title>
      <pubDate>Tue, 11 Jun 2019 00:00:00 GMT</pubDate>
      <link>https://divyanshu132.github.io//gsoc-week-2</link>
      <description>&lt;p&gt;Hello world,
The second week of coding period has been ended and for the complete week we worked on the presentation of polycyclic groups. I&amp;#8217;ve created a WIP PR for the basic structure of PcGroups &lt;a href="https://github.com/sympy/sympy/pull/16991"&gt;here&lt;/a&gt; but it seems like there are a lot of things that needs to be changed or enhanced in this presentation.&lt;/p&gt;

&lt;p&gt;Initially I thought of representing PcGroups with just the generators of the given permutation group and then from the last week we already have composition-series(&lt;a href="https://divyanshu132.github.io//gsoc-week-1"&gt;here&lt;/a&gt;) so we can easily compute the generating sequence(pcgs) for the polycyclic group. But, finally we realised that the composition-series will be too big to do all the computations for the PcGroup. Also, in the presentation we can&amp;#8217;t ignore the relators.&lt;/p&gt;

&lt;p&gt;So, after all this we thought of computing the smaller version of subnormal series with cyclic factors and finally we realised that &lt;strong&gt;collection algorithm&lt;/strong&gt; is something that we need. Can&amp;#8217;t say more about this because I have to look into the &lt;code class="highlighter-rouge"&gt;rewriting&lt;/code&gt; code which looks like a tough task for me but let&amp;#8217;s hope for the best.&lt;/p&gt;

&lt;p&gt;For the next week I&amp;#8217;m setting these milestones for me:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Get ready with the presentation of PcGroups(still I&amp;#8217;m not sure if collection algorithm is what we need!).&lt;/li&gt;
  &lt;li&gt;Implement &lt;code class="highlighter-rouge"&gt;exponent-vector&lt;/code&gt; which may further help in HallSubgroup computation.&lt;/li&gt;
  &lt;li&gt;Include more methods in the PcGroup class.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Will try my best to execute things in order mentioned above. With this, sign out for the next week.&lt;/p&gt;</description>
    </item>
    <item>
      <guid isPermaLink="false">https://www.kangzhiq.com/?p=15</guid>
      <author>Zhiqi KANG (kangzhiq)</author>
      <title>Zhiqi KANG (kangzhiq): [GSoC 2019] WEEK 2!</title>
      <pubDate>Sun, 09 Jun 2019 22:53:12 GMT</pubDate>
      <link>https://www.kangzhiq.com/2019/06/10/gsoc-2019week-2/</link>
      <description>&lt;p&gt;Hello everyone! I am glad to present some of my progress during this past week.&lt;/p&gt;



&lt;ul&gt;&lt;li&gt;Overview&lt;/li&gt;&lt;/ul&gt;



&lt;p&gt;I was mainly working on the sparse aray issue over this week. A sparse array is, by a brief definition, an array in which most of the elements are zero.  In order to save the memory cost, sparse array is distinguished from the dense array(which means most of elements are non-zero) and then is stored and manipulated in a different way. The default data format in SymPy for sparse array is called Dictionary of keys (DOK), where the non-zero value is stored in a dictionary.&lt;/p&gt;



&lt;p&gt;However, the sparse array is cast to dense array in various ways. So what I am trying to do is to free these sparse arrays and nake good use of them for cases like large scale sparse array operations. &lt;/p&gt;



&lt;ul&gt;&lt;li&gt;PRs&lt;/li&gt;&lt;/ul&gt;



&lt;p&gt;The PR about derive_by_array &lt;a href="https://github.com/sympy/sympy/pull/16937"&gt;#16937&lt;/a&gt; is not yet merged. Thank to the guidance of my mentor Francesco, the PR is being ameliorated and now has satisfactory result. Besides the operation of derive_by_array, I have updated as well the way Array module perform a equality test and apply function. To show the result of these changes, let&amp;#8217;s see what the behavior of derive_by_array was:&lt;/p&gt;



&lt;pre class="wp-block-code"&gt;&lt;code&gt;&gt;&gt;&gt; a = MutableSparseNDimArray.zeros(10000, 20000)
&gt;&gt;&gt; a[1, 1] = i
&gt;&gt;&gt; a[1, 2] = j
&gt;&gt;&gt; d = derive_by_array(a, i)
MemoryError
&gt;&gt;&gt; d = derive_by_array(a, (i, j))
MemoryError&lt;/code&gt;&lt;/pre&gt;



&lt;p&gt;The sparse array is cast to a list which leads to the MemoryError. Now, we can have:&lt;/p&gt;



&lt;pre class="wp-block-code"&gt;&lt;code&gt;&gt;&gt;&gt; a = MutableSparseNDimArray.zeros(10000, 20000)
&gt;&gt;&gt; a[1, 1] = i
&gt;&gt;&gt; derive_by_array(a, i) = ImmutableSparseNDimArray({20001:1},(10000, 20000))
True
&gt;&gt;&gt; a[1, 2] = j
&gt;&gt;&gt; derive_by_array(a, (i, j)) == ImmutableSparseNDimArray({20001: 1, 200020002: 1},(2, 10000, 20000))
True&lt;/code&gt;&lt;/pre&gt;



&lt;p&gt;The operation is much more rapid and can save a lot of spaces of memory. &lt;/p&gt;



&lt;p&gt;Francesco also helped to improve the quality of codes. For example, to perform the deriative of a sparse array, he suggested me to use a dictionary comprehension instead of a for loop, so an extra function is replaced by one single line of code.&lt;/p&gt;



&lt;p&gt;A new PR &lt;a href="https://github.com/sympy/sympy/pull/16994"&gt;#16994&lt;/a&gt; about __mul__ and__rmul__ is opened, which solves the problem of casting in these operators. Same as another new PR &lt;a href="https://github.com/sympy/sympy/pull/17000"&gt;#17000&lt;/a&gt; for tensorproduct. However, these PRs cannot pass the test for now because the issue about equality test is not yet fixed and merged into master of SymPy.&lt;/p&gt;



&lt;p&gt;A new PR &lt;a href="https://github.com/sympy/sympy/pull/16969"&gt;#16969&lt;/a&gt; about adding functions and tests for ArrayComprehension is merged, which added functions like .tomatrix(), .tolist() for this class.&lt;/p&gt;



&lt;ul&gt;&lt;li&gt;Issues&lt;/li&gt;&lt;/ul&gt;



&lt;p&gt;I have opened a issue &lt;a href="https://github.com/sympy/sympy/issues/16984"&gt;#16984&lt;/a&gt; about equality test of Dict and dict objects. I ran into this case while comparing the dictionaries of sparse array. Fortunately, this issue is recently fixed. &lt;/p&gt;



&lt;ul&gt;&lt;li&gt;Reviews&lt;/li&gt;&lt;/ul&gt;



&lt;p&gt;No reviews for other contributors&amp;#8217; PR. I have participated in the review of my own PRs since there are some errors have been found after the creation of PR.&lt;/p&gt;



&lt;ul&gt;&lt;li&gt;Related works&lt;/li&gt;&lt;/ul&gt;



&lt;p&gt;I have participated in the discussion about the nature of ArrayComprehension in the community this week. Comprehension is a new class that I implemented last week(See &lt;a href="https://www.kangzhiq.com/2019/06/03/gsoc-week-1/"&gt;last post&lt;/a&gt; for more details) This discussion helped me better understand the difference between a multipledimensional list and an array: an array is suppposed to perform vectorized operations while list is mosyly element-wise.&lt;/p&gt;</description>
    </item>
    <item>
      <guid isPermaLink="false">http://ishanaj.wordpress.com/?p=46</guid>
      <author>Ishan Joshi (ishanaj)</author>
      <title>Ishan Joshi (ishanaj): GSoC&#x2019;19: Week 2 &#x2013; Working on CrossSection class</title>
      <pubDate>Sun, 09 Jun 2019 18:20:25 GMT</pubDate>
      <link>https://ishanaj.wordpress.com/2019/06/09/gsoc19-week-2-working-on-crosssection-class/</link>
      <description>&lt;p&gt;The second week has ended and here I am to give you a brief about the week&amp;#8217;s work!&lt;/p&gt;
&lt;p&gt;The week started with the opening of a &lt;a href="https://github.com/sympy/sympy/pull/16964"&gt;PR #16964&lt;/a&gt; which intended to define a class &lt;strong&gt;CrossSection &lt;/strong&gt;as planned. Discussions have been done in this PR regarding its API and its need. All these discussions lead to a conclusion of making a slight change in the API to make it accept any arbitrary cross-section which the user can define using the geometry module. So now the &lt;strong&gt;CrossSection&lt;/strong&gt; class will take the input of a pre-defined object of the geometry module and calculate its corresponding properties. This will make the &lt;strong&gt;CrossSection&lt;/strong&gt; class much simpler and generalized. I will be updating the same in the &lt;strong&gt;PR&lt;/strong&gt; soon.&lt;/p&gt;
&lt;p&gt;I had also researched some of the previous works done in this area. &lt;a href="https://github.com/sympy/sympy/pull/14434"&gt;PR #14434&lt;/a&gt;, which intends to implement a shape class, giving functionality to cut an ellipse or a parabola via a line and determine the properties of the newly formed segment. I have tried to implement a similar concept to the Polygon class via a method &lt;strong&gt;cut_section() &lt;/strong&gt;in &lt;a href="https://github.com/sympy/sympy/pull/17001"&gt;PR #17001&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;Also since one of the major issues also was to determine the first moment of area, this PR would further help in the calculation of the first moment of area. It intends to give the Polygon class functionality to return a new Polygon segment formed when a given line intersects the Polygon. Although, an alternative method of &lt;strong&gt;Polygon triangulation&lt;/strong&gt; also has been discussed in this PR, to determine the first moment. I will have to do a bit of research for this to get this implemented&lt;strong&gt;.&lt;/strong&gt;&lt;/p&gt;
&lt;h2&gt;&lt;strong&gt;Next Week:&lt;/strong&gt;&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;Implementing a method to determine the first moment of area&lt;/li&gt;
&lt;li&gt;Completing the CrossSection class along with its documentation and testing&lt;/li&gt;
&lt;li&gt;Linking it with the beam module&lt;/li&gt;
&lt;li&gt;Working over the implementation of &lt;strong&gt;Stage-II&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;I will try to make the CrossSection class fully functional, by the end of the coming week.&lt;/p&gt;
&lt;p&gt;Will keep you updated!&lt;/p&gt;
&lt;p&gt;Thanks!&lt;/p&gt;</description>
    </item>
  </channel>
</rss>
