<?xml version="1.0"?>
<rss version="2.0" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Planet SymPy</title>
    <link>http://planet.sympy.org/</link>
    <language>en</language>
    <description>Planet SymPy - http://planet.sympy.org/</description>
    <atom:link href="http://planet.sympy.org/rss10.xml" rel="self" type="application/rss+xml"/>
    <item>
      <guid isPermaLink="false">https://arighnaiitg.github.io/2019-06-19-gsoc-week3/</guid>
      <author>Arighna Chakrabarty (arighnaiitg)</author>
      <title>Arighna Chakrabarty (arighnaiitg): GSoC Week 1 !!</title>
      <pubDate>Wed, 19 Jun 2019 07:00:00 GMT</pubDate>
      <link>https://arighnaiitg.github.io/2019-06-19-gsoc-week3/</link>
      <description>&lt;p&gt;Week 1 ends.. - 
          Week 3 of the first phase of this coding period is coming to an end. The week started with a bad note, given that I had fallen sick due to travelling. But the work in Week 2, and the meeting with Sartaj on 11th of June helped me to progress...</description>
    </item>
    <item>
      <guid isPermaLink="false">https://divyanshu132.github.io//gsoc-week-3</guid>
      <author>Divyanshu Thakur (divyanshu132)</author>
      <title>Divyanshu Thakur (divyanshu132): GSoC 2019 - Week 3 - Polycyclic Groups</title>
      <pubDate>Mon, 17 Jun 2019 00:00:00 GMT</pubDate>
      <link>https://divyanshu132.github.io//gsoc-week-3</link>
      <description>&lt;p&gt;The third week has ended and a good amount of work has been done on polycyclic groups PR &lt;a href="https://github.com/sympy/sympy/pull/16991"&gt;here&lt;/a&gt;. The collection algorithm has been implemented, from the beginning of the week, I started with understanding the algorithm which took some time and then finally it was implemented, still we are facing a problem in type conversion(&lt;a href="https://github.com/sympy/sympy/pull/16991#discussion_r294054681"&gt;here&lt;/a&gt;) but that will be sorted out soon!&lt;/p&gt;

&lt;p&gt;Even though only two weeks were alloted for polycyclic group implementation but it seems we need one more week or maybe more than a week to implement more functionalities for pc groups. But it&amp;#8217;s completely fine because we started work early and according to the proposed timeline we still have one week.&lt;/p&gt;

&lt;p&gt;Few of the issues with the current implementation which needs to be sorted out are:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;firstly to &lt;code class="highlighter-rouge"&gt;compute uncollected subwords&lt;/code&gt; the word is manipulated using its &lt;code class="highlighter-rouge"&gt;array_form&lt;/code&gt; which eventually leads to change in the type of the subwords computed and it creates a problem in processing these subwords further.&lt;/li&gt;
  &lt;li&gt;Some more issues were pointed out by Kalevi and can be seen in the comments of the PR.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;The complete week was spent implementing collection of words so a lot of tasks targeted last week were not completed, I&amp;#8217;ll try to cover those tasks in the upcomming week.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Solve the issues with collection of words.&lt;/li&gt;
  &lt;li&gt;Get ready with the pc presentation.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Till then, Good byee..!&lt;/p&gt;</description>
    </item>
    <item>
      <guid isPermaLink="false">https://shubhamkjha.github.io/2019/06/17/GSoC-2019-Week-3</guid>
      <author>Shubham Kumar Jha (ShubhamKJha)</author>
      <title>Shubham Kumar Jha (ShubhamKJha): GSoC 2019: Week 3</title>
      <pubDate>Mon, 17 Jun 2019 00:00:00 GMT</pubDate>
      <link>https://shubhamkjha.github.io/2019/06/17/GSoC-2019-Week-3.html</link>
      <description>&lt;p&gt;The third week of coding period has ended and as I already stated in the last blog, I couldn&amp;#8217;t be much productive this week. Nevertheless, I tried to wrap-up some unfinished works. PR &lt;a href="https://github.com/sympy/sympy/pull/16956"&gt;#16956&lt;/a&gt; is ready to merge, just waiting for some last reviews. This PR needs to be supplemented with some fixes in the code of &lt;code class="highlighter-rouge"&gt;Add&lt;/code&gt; class to handle all the issues over &lt;code class="highlighter-rouge"&gt;Relationals&lt;/code&gt;. PR &lt;a href="https://github.com/sympy/sympy/pull/16978"&gt;#16978&lt;/a&gt; had one major failing test from the &lt;code class="highlighter-rouge"&gt;stats&lt;/code&gt; module. I tried to debug it ,but due to my unfamiliarity with that part of code I took help from &lt;a href="https://github.com/czgdp1807"&gt;Gagandeep&lt;/a&gt; and as his &lt;a href="https://github.com/sympy/sympy/pull/16978#discussion_r294039337"&gt;comment&lt;/a&gt; suggests, the result this PR is giving is correct and more intuitive. At least, one less issue to handle &amp;#128524;.&lt;/p&gt;

&lt;p&gt;Over the end of the week, I shifted my focus towards &lt;em&gt;New Assumptions&lt;/em&gt;. One of my major tasks for this summer is to speed up the &lt;em&gt;satask&lt;/em&gt; module. As suggested by Aaron, I searched the repository for issues and PRs over this, and I found a number of such unfinished work. I would need to study these ideas and profile the results before working ahead. I would create a issue-tree over it connecting all such PRs and there respective benchmarks.&lt;/p&gt;

&lt;p&gt;For this week, I would focus on the above mentioned task only. Since the first phase is about to end, I would have to speed things up.&lt;/p&gt;</description>
    </item>
    <item>
      <guid isPermaLink="false">https://www.kangzhiq.com/?p=20</guid>
      <author>Zhiqi KANG (kangzhiq)</author>
      <title>Zhiqi KANG (kangzhiq): [GSoC 2019] WEEK 3!</title>
      <pubDate>Sun, 16 Jun 2019 22:11:07 GMT</pubDate>
      <link>https://www.kangzhiq.com/2019/06/17/gsoc-2019-week-3/</link>
      <description>&lt;p&gt;Hello, the third week ends! I am a little bit too busy to keep contributing on my GSoC project as the first two weeks. Fortunately, thank to the work of the past 2 weeks and the help of my mentors, I become more productive which compensates, more or less,  the lack of time.&lt;/p&gt;



&lt;ul&gt;&lt;li&gt;Overview&lt;/li&gt;&lt;/ul&gt;



&lt;p&gt;The task about sparse arrays nearly comes to an end which is the main goal for the first phase. I still have one case to be fixed but most of them are merged in to Sympy&amp;#8217;s master and are ready to be used. I started as well preparing for the next task: implementing more data structure for sparse arrays. This would be started in the next week and is supposed to be ended by the begining of phase 2.&lt;/p&gt;



&lt;ul&gt;&lt;li&gt;PRs&lt;/li&gt;&lt;/ul&gt;



&lt;p&gt;Several PR are merged this week for sparse arrays operations.  &lt;a href="https://github.com/sympy/sympy/pull/16937"&gt;#16937&lt;/a&gt;  is finally merged with a code style much simpler than its first version.  &lt;a href="https://github.com/sympy/sympy/pull/16994"&gt;#16994&lt;/a&gt;  about __mul__ and __rmul__ is closed and replaced by &lt;a href="https://github.com/sympy/sympy/pull/17014"&gt;#17014&lt;/a&gt; due to a mistake about rebase. &lt;a href="https://github.com/sympy/sympy/pull/17026"&gt;#17026&lt;/a&gt;  about __div__ and __neg__ operators for sparse arrays is opened and merged.  &lt;a href="https://github.com/sympy/sympy/pull/17035"&gt;#17035&lt;/a&gt; about permutedims and transpose for sparse arrays is opened and reviewed by my mentor.&lt;/p&gt;



&lt;ul&gt;&lt;li&gt;Issues&lt;/li&gt;&lt;/ul&gt;



&lt;p&gt;No specific issue opened. The list in &lt;a href="https://github.com/sympy/sympy/issues/16941"&gt;#16941&lt;/a&gt; is continously being updated.&lt;/p&gt;



&lt;ul&gt;&lt;li&gt;Reviews&lt;/li&gt;&lt;/ul&gt;



&lt;p&gt;No review due to the lack of time.&lt;/p&gt;



&lt;ul&gt;&lt;li&gt;Related works&lt;/li&gt;&lt;/ul&gt;



&lt;p&gt;Pratice of rebasing and merging for a specific case: updated local repository from the upstream master after opening a PR. Even though I have broken the PR  &lt;a href="https://github.com/sympy/sympy/pull/16994"&gt;#16994&lt;/a&gt;, I am still happy to learn some new tricks that I didn&amp;#8217;t know before.&lt;/p&gt;



&lt;p&gt;Preparing a blog about presenting sparse array associated with my work in SymPy so that my contribution can indeed help people when they need to use this class but don&amp;#8217;t really know how to do it and what the advantage would be .&lt;/p&gt;</description>
    </item>
    <item>
      <guid isPermaLink="false">http://ishanaj.wordpress.com/?p=48</guid>
      <author>Ishan Joshi (ishanaj)</author>
      <title>Ishan Joshi (ishanaj): GSoC&#x2019;19: Week 3 &#x2013; Wrapping up Stage-I</title>
      <pubDate>Sun, 16 Jun 2019 19:20:32 GMT</pubDate>
      <link>https://ishanaj.wordpress.com/2019/06/17/gsoc19-week-3-wrapping-up-stage-i/</link>
      <description>&lt;p&gt;This week started with working on &lt;a href="https://github.com/sympy/sympy/pull/17001"&gt;PR #17001&lt;/a&gt;. The algorithm was extended to handle concave polygons as well. I came up with a new method which I have explained in the &lt;a href="https://github.com/sympy/sympy/wiki/A-method-to-return-a-cut-section-of-any-polygon-geometry"&gt;wiki page&lt;/a&gt; that I have created. It has to be tested against some symbolic coordinates to make it a complete method.&lt;/p&gt;
&lt;p&gt;The API of the CrossSection class has been changed as discussed in the last week. The documentation of the class has been completed.&lt;/p&gt;
&lt;p&gt;There were some discussions being done on the necessity and the importance of the CrossSection class. Despite the CrossSection class providing some very useful functionalities of calculating the section modulus, the first moment of area and polar modulus, is there really a need for such a class? After getting some pros and cons listed out we got to a conclusion, that it would probably be better to add these functionalities directly to the geometry module.&lt;/p&gt;
&lt;p&gt;But the question of complex geometries like T-shape and I-shape still remains. The alternative to this that we came up with in the discussion was Boolean operations on simple polygons. There are some clipping algorithms like Vatti algorithm and Greiner Hormann algorithm which might be helpful in implementing these.&lt;/p&gt;
&lt;p&gt;In short, this is what is left to be done:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Transferring the cross-sectional properties defined in the CrossSection class to the geometry module&lt;/li&gt;
&lt;li&gt;Making the beam class to accept any geometry instead of the second moment that is currently accepted from the user.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;In later stages, I might try to work on the Boolean operations as currently there is a limitation of time and the implementation of the stage -II awaits.&lt;/p&gt;
&lt;p&gt;After this, the stage-I would end and I will have to start with the next implementation i.e. the column buckling calculations&lt;/p&gt;
&lt;h2&gt;Next Week:&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;Completing leftovers of the previous week&lt;/li&gt;
&lt;li&gt;Starting off with stage-II&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;The work and the progress during the stage-I were full of ups and downs. Will try to make it smoother this time. Will try to discuss the implementations with the mentors and the members in even more detail. Hope to have a good coding week.&lt;/p&gt;
&lt;p&gt;Will keep you updated!&lt;/p&gt;
&lt;p&gt;Thanks!&lt;/p&gt;</description>
    </item>
    <item>
      <guid isPermaLink="false">https://czgdp1807.github.io/week_3</guid>
      <author>Gagandeep Singh (czgdp1807)</author>
      <title>Gagandeep Singh (czgdp1807): Week 3 - Evaluation is coming :P</title>
      <pubDate>Sun, 16 Jun 2019 00:00:00 GMT</pubDate>
      <link>https://czgdp1807.github.io/week_3/</link>
      <description>&lt;p&gt;Week 3 has ended and we are moving towards phase 1 evaluations by entering the fourth week. Let me tell you what all has been done during the previous week to make the last step smooth.&lt;/p&gt;

&lt;p&gt;The basic structure of stochastic process has been added with the merging of the PR &lt;a href="https://github.com/sympy/sympy/pull/16981"&gt;#16981&lt;/a&gt; and I am currently working on adding more features like, &lt;code class="highlighter-rouge"&gt;joint_distribution&lt;/code&gt;, &lt;code class="highlighter-rouge"&gt;expectation&lt;/code&gt; and may be some more according to the suggestions recieved from the community. You can read more about it, &lt;a href="https://github.com/sympy/sympy/pull/17030#issuecomment-502455179"&gt;here&lt;/a&gt;. So this was about some processes, now lets move to the case of symbolic dimensions. Well, I made a comment and the members showed agreement to that. I have made some updates to the PR &lt;a href="https://github.com/sympy/sympy/pull/16962"&gt;#16962&lt;/a&gt; and the summary is available at &lt;a href="https://github.com/sympy/sympy/pull/16962#issuecomment-502461264"&gt;this comment&lt;/a&gt;. I also discovered that docs of &lt;code class="highlighter-rouge"&gt;SymPy&lt;/code&gt; weren&amp;#8217;t being updated at &lt;code class="highlighter-rouge"&gt;https://docs.sympy.org&lt;/code&gt; for the &lt;code class="highlighter-rouge"&gt;stats&lt;/code&gt; module and therefore I modified the PR &lt;a href="https://github.com/sympy/sympy/pull/16934"&gt;#16934&lt;/a&gt;. For preparation of phase 2, I have created the issue &lt;a href="https://github.com/sympy/sympy/issues/17039"&gt;#17039&lt;/a&gt; for discussion on random matrices.&lt;/p&gt;

&lt;p&gt;So, what I learnt? Premature optimization is bad for the health of the code. Yes, while reviewing PRs I learnt that concept. I also got to know why some imports cannot be put at the top of the file, all due to a concept called, &lt;code class="highlighter-rouge"&gt;circular imports&lt;/code&gt;. Sounds intuitive and faced a lot earlier but wasn&amp;#8217;t aware of the exact term. Thanks to &lt;a href="https://github.com/leosartaj"&gt;leosartaj&lt;/a&gt; for this. I also tried the coverage tests on my local system with the help of &lt;a href="https://github.com/oscarbenjamin"&gt;oscarbenjamin&lt;/a&gt;. Read &lt;a href="https://github.com/sympy/sympy/pull/16981#issuecomment-502095724"&gt;this comment&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;That&amp;#8217;s it for now, bye!!&lt;/p&gt;</description>
    </item>
    <item>
      <guid isPermaLink="false">https://jmig5776.github.io//gsoc-week-3</guid>
      <author>Jogi Miglani (jmig5776)</author>
      <title>Jogi Miglani (jmig5776): GSoC 2019 - Week 3</title>
      <pubDate>Sun, 16 Jun 2019 00:00:00 GMT</pubDate>
      <link>https://jmig5776.github.io//gsoc-week-3</link>
      <description>&lt;p&gt;This was the third week meeting with the GSoC mentors which was scheduled on
Sunday 16th June, 2019 between 12:00 - 01:00 PM (IST). Me, Amit, Yathartha and
Shekhar were the attendees of the meeting. In this meeting mainly it was discussed
to improve the code quality and make routine of independent working code.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Code quality&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Every programmer should master this skill to write a good quality code. Everything from
naming, documentation to make routines includes in this skill.&lt;/p&gt;

&lt;p&gt;And we discussed mainly the code for the PR &lt;a href="https://github.com/sympy/sympy/pull/16890"&gt;#16890&lt;/a&gt;
and realising that a new function &lt;code class="highlighter-rouge"&gt;power_list&lt;/code&gt; to be made to return all the
powers of symbols present in an expression.&lt;/p&gt;

&lt;p&gt;Learning new skills!!&lt;/p&gt;</description>
    </item>
    <item>
      <guid isPermaLink="false">https://sc0rpi0n101.github.io/2019/06/week-3-whats-happening-where-have-i-been/</guid>
      <author>Nikhil Maan (Sc0rpi0n101)</author>
      <title>Nikhil Maan (Sc0rpi0n101): Week 3: What's Happening? Where have I been?</title>
      <pubDate>Sun, 16 Jun 2019 00:00:00 GMT</pubDate>
      <link>https://sc0rpi0n101.github.io/2019/06/week-3-whats-happening-where-have-i-been/</link>
      <description>&lt;p&gt;&amp;#8220;How did it get so late so soon?&amp;#8221;  &amp;#8213; Dr. Seuss
 Welcome everyone, this is your host Nikhil Maan aka Sc0rpi0n101 and we&amp;rsquo;re running late on everything this week. This time we will talk about some operating system stuff along with the week&amp;rsquo;s work. I will have more blogs on operating systems and that type of stuff soon. For now, let&amp;rsquo;s talk about what&amp;rsquo;s happening.
Why so Late?</description>
    </item>
    <item>
      <guid isPermaLink="false">https://shubhamkjha.github.io/2019/06/13/GSoC-2019-Week-2</guid>
      <author>Shubham Kumar Jha (ShubhamKJha)</author>
      <title>Shubham Kumar Jha (ShubhamKJha): GSoC 2019: Week 2</title>
      <pubDate>Thu, 13 Jun 2019 00:00:00 GMT</pubDate>
      <link>https://shubhamkjha.github.io/2019/06/13/GSoC-2019-Week-2.html</link>
      <description>&lt;p&gt;The second week of official coding period has concluded. I will give you a brief summary of the week&amp;#8217;s work.&lt;/p&gt;

&lt;p&gt;I started this week with working on PR &lt;a href="https://github.com/sympy/sympy/pull/16956"&gt;#16956&lt;/a&gt;, the PR is now passing tests. I will try to get it merged soon. Later this week, I tried to include &lt;code class="highlighter-rouge"&gt;complex -&amp;gt; finite&lt;/code&gt; in the assumptions system. I started PR &lt;a href="https://github.com/sympy/sympy/pull/16978"&gt;#16978&lt;/a&gt; over this. This PR changes the assumptions system to work over the &lt;code class="highlighter-rouge"&gt;complex -&amp;gt; finite&lt;/code&gt; clause. All the instances of use of &lt;code class="highlighter-rouge"&gt;is_complex&lt;/code&gt; call has to be modified. As suggested by Aaron, the &lt;code class="highlighter-rouge"&gt;is_complex&lt;/code&gt; call was changed with a disjunction of &lt;code class="highlighter-rouge"&gt;is_complex&lt;/code&gt; and &lt;code class="highlighter-rouge"&gt;is_infinite&lt;/code&gt; calls. Luckily for me, the usage of complex assumption was not much in the codebase &amp;#128524;. Though it meant less test failures to handle, the core assumptions system (in the old system) is quite complex to understand and debug, and hence handling all the failing tests proved quite difficult. Also, I tried to work on it without including any new assumptions to the system. One important result of this is, &lt;code class="highlighter-rouge"&gt;zoo.is_complex&lt;/code&gt; returns &lt;code class="highlighter-rouge"&gt;False&lt;/code&gt; now.&lt;/p&gt;

&lt;p&gt;Apart from that I have worked on to sync these changes in the new assumptions system as well and I will be sending PR over it soon.&lt;/p&gt;

&lt;p&gt;For the coming week,&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;I will start to work on SAT solver and to speed it up. As suggested by Aaron, I will first look into the other unfinished PRs over this.&lt;/li&gt;
  &lt;li&gt;I will sync the new assumptions with the recent developments in the old system.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;With enough said, these PRs made me realize how much the codebase can break with small changes in the assumptions. Also, I know this post is a little bit late(because of bad health). I have some pending work over from the last week and I will try to catch speed as soon as possible.&lt;/p&gt;</description>
    </item>
    <item>
      <guid isPermaLink="false">https://divyanshu132.github.io//gsoc-week-2</guid>
      <author>Divyanshu Thakur (divyanshu132)</author>
      <title>Divyanshu Thakur (divyanshu132): GSoC 2019 - Week 2 - Polycyclic Group Presentation in SymPy</title>
      <pubDate>Tue, 11 Jun 2019 00:00:00 GMT</pubDate>
      <link>https://divyanshu132.github.io//gsoc-week-2</link>
      <description>&lt;p&gt;Hello world,
The second week of coding period has been ended and for the complete week we worked on the presentation of polycyclic groups. I&amp;#8217;ve created a WIP PR for the basic structure of PcGroups &lt;a href="https://github.com/sympy/sympy/pull/16991"&gt;here&lt;/a&gt; but it seems like there are a lot of things that needs to be changed or enhanced in this presentation.&lt;/p&gt;

&lt;p&gt;Initially I thought of representing PcGroups with just the generators of the given permutation group and then from the last week we already have composition-series(&lt;a href="https://divyanshu132.github.io//gsoc-week-1"&gt;here&lt;/a&gt;) so we can easily compute the generating sequence(pcgs) for the polycyclic group. But, finally we realised that the composition-series will be too big to do all the computations for the PcGroup. Also, in the presentation we can&amp;#8217;t ignore the relators.&lt;/p&gt;

&lt;p&gt;So, after all this we thought of computing the smaller version of subnormal series with cyclic factors and finally we realised that &lt;strong&gt;collection algorithm&lt;/strong&gt; is something that we need. Can&amp;#8217;t say more about this because I have to look into the &lt;code class="highlighter-rouge"&gt;rewriting&lt;/code&gt; code which looks like a tough task for me but let&amp;#8217;s hope for the best.&lt;/p&gt;

&lt;p&gt;For the next week I&amp;#8217;m setting these milestones for me:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Get ready with the presentation of PcGroups(still I&amp;#8217;m not sure if collection algorithm is what we need!).&lt;/li&gt;
  &lt;li&gt;Implement &lt;code class="highlighter-rouge"&gt;exponent-vector&lt;/code&gt; which may further help in HallSubgroup computation.&lt;/li&gt;
  &lt;li&gt;Include more methods in the PcGroup class.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Will try my best to execute things in order mentioned above. With this, sign out for the next week.&lt;/p&gt;</description>
    </item>
    <item>
      <guid isPermaLink="false">https://www.kangzhiq.com/?p=15</guid>
      <author>Zhiqi KANG (kangzhiq)</author>
      <title>Zhiqi KANG (kangzhiq): [GSoC 2019] WEEK 2!</title>
      <pubDate>Sun, 09 Jun 2019 22:53:12 GMT</pubDate>
      <link>https://www.kangzhiq.com/2019/06/10/gsoc-2019week-2/</link>
      <description>&lt;p&gt;Hello everyone! I am glad to present some of my progress during this past week.&lt;/p&gt;



&lt;ul&gt;&lt;li&gt;Overview&lt;/li&gt;&lt;/ul&gt;



&lt;p&gt;I was mainly working on the sparse aray issue over this week. A sparse array is, by a brief definition, an array in which most of the elements are zero.  In order to save the memory cost, sparse array is distinguished from the dense array(which means most of elements are non-zero) and then is stored and manipulated in a different way. The default data format in SymPy for sparse array is called Dictionary of keys (DOK), where the non-zero value is stored in a dictionary.&lt;/p&gt;



&lt;p&gt;However, the sparse array is cast to dense array in various ways. So what I am trying to do is to free these sparse arrays and nake good use of them for cases like large scale sparse array operations. &lt;/p&gt;



&lt;ul&gt;&lt;li&gt;PRs&lt;/li&gt;&lt;/ul&gt;



&lt;p&gt;The PR about derive_by_array &lt;a href="https://github.com/sympy/sympy/pull/16937"&gt;#16937&lt;/a&gt; is not yet merged. Thank to the guidance of my mentor Francesco, the PR is being ameliorated and now has satisfactory result. Besides the operation of derive_by_array, I have updated as well the way Array module perform a equality test and apply function. To show the result of these changes, let&amp;#8217;s see what the behavior of derive_by_array was:&lt;/p&gt;



&lt;pre class="wp-block-code"&gt;&lt;code&gt;&gt;&gt;&gt; a = MutableSparseNDimArray.zeros(10000, 20000)
&gt;&gt;&gt; a[1, 1] = i
&gt;&gt;&gt; a[1, 2] = j
&gt;&gt;&gt; d = derive_by_array(a, i)
MemoryError
&gt;&gt;&gt; d = derive_by_array(a, (i, j))
MemoryError&lt;/code&gt;&lt;/pre&gt;



&lt;p&gt;The sparse array is cast to a list which leads to the MemoryError. Now, we can have:&lt;/p&gt;



&lt;pre class="wp-block-code"&gt;&lt;code&gt;&gt;&gt;&gt; a = MutableSparseNDimArray.zeros(10000, 20000)
&gt;&gt;&gt; a[1, 1] = i
&gt;&gt;&gt; derive_by_array(a, i) = ImmutableSparseNDimArray({20001:1},(10000, 20000))
True
&gt;&gt;&gt; a[1, 2] = j
&gt;&gt;&gt; derive_by_array(a, (i, j)) == ImmutableSparseNDimArray({20001: 1, 200020002: 1},(2, 10000, 20000))
True&lt;/code&gt;&lt;/pre&gt;



&lt;p&gt;The operation is much more rapid and can save a lot of spaces of memory. &lt;/p&gt;



&lt;p&gt;Francesco also helped to improve the quality of codes. For example, to perform the deriative of a sparse array, he suggested me to use a dictionary comprehension instead of a for loop, so an extra function is replaced by one single line of code.&lt;/p&gt;



&lt;p&gt;A new PR &lt;a href="https://github.com/sympy/sympy/pull/16994"&gt;#16994&lt;/a&gt; about __mul__ and__rmul__ is opened, which solves the problem of casting in these operators. Same as another new PR &lt;a href="https://github.com/sympy/sympy/pull/17000"&gt;#17000&lt;/a&gt; for tensorproduct. However, these PRs cannot pass the test for now because the issue about equality test is not yet fixed and merged into master of SymPy.&lt;/p&gt;



&lt;p&gt;A new PR &lt;a href="https://github.com/sympy/sympy/pull/16969"&gt;#16969&lt;/a&gt; about adding functions and tests for ArrayComprehension is merged, which added functions like .tomatrix(), .tolist() for this class.&lt;/p&gt;



&lt;ul&gt;&lt;li&gt;Issues&lt;/li&gt;&lt;/ul&gt;



&lt;p&gt;I have opened a issue &lt;a href="https://github.com/sympy/sympy/issues/16984"&gt;#16984&lt;/a&gt; about equality test of Dict and dict objects. I ran into this case while comparing the dictionaries of sparse array. Fortunately, this issue is recently fixed. &lt;/p&gt;



&lt;ul&gt;&lt;li&gt;Reviews&lt;/li&gt;&lt;/ul&gt;



&lt;p&gt;No reviews for other contributors&amp;#8217; PR. I have participated in the review of my own PRs since there are some errors have been found after the creation of PR.&lt;/p&gt;



&lt;ul&gt;&lt;li&gt;Related works&lt;/li&gt;&lt;/ul&gt;



&lt;p&gt;I have participated in the discussion about the nature of ArrayComprehension in the community this week. Comprehension is a new class that I implemented last week(See &lt;a href="https://www.kangzhiq.com/2019/06/03/gsoc-week-1/"&gt;last post&lt;/a&gt; for more details) This discussion helped me better understand the difference between a multipledimensional list and an array: an array is suppposed to perform vectorized operations while list is mosyly element-wise.&lt;/p&gt;</description>
    </item>
    <item>
      <guid isPermaLink="false">http://ishanaj.wordpress.com/?p=46</guid>
      <author>Ishan Joshi (ishanaj)</author>
      <title>Ishan Joshi (ishanaj): GSoC&#x2019;19: Week 2 &#x2013; Working on CrossSection class</title>
      <pubDate>Sun, 09 Jun 2019 18:20:25 GMT</pubDate>
      <link>https://ishanaj.wordpress.com/2019/06/09/gsoc19-week-2-working-on-crosssection-class/</link>
      <description>&lt;p&gt;The second week has ended and here I am to give you a brief about the week&amp;#8217;s work!&lt;/p&gt;
&lt;p&gt;The week started with the opening of a &lt;a href="https://github.com/sympy/sympy/pull/16964"&gt;PR #16964&lt;/a&gt; which intended to define a class &lt;strong&gt;CrossSection &lt;/strong&gt;as planned. Discussions have been done in this PR regarding its API and its need. All these discussions lead to a conclusion of making a slight change in the API to make it accept any arbitrary cross-section which the user can define using the geometry module. So now the &lt;strong&gt;CrossSection&lt;/strong&gt; class will take the input of a pre-defined object of the geometry module and calculate its corresponding properties. This will make the &lt;strong&gt;CrossSection&lt;/strong&gt; class much simpler and generalized. I will be updating the same in the &lt;strong&gt;PR&lt;/strong&gt; soon.&lt;/p&gt;
&lt;p&gt;I had also researched some of the previous works done in this area. &lt;a href="https://github.com/sympy/sympy/pull/14434"&gt;PR #14434&lt;/a&gt;, which intends to implement a shape class, giving functionality to cut an ellipse or a parabola via a line and determine the properties of the newly formed segment. I have tried to implement a similar concept to the Polygon class via a method &lt;strong&gt;cut_section() &lt;/strong&gt;in &lt;a href="https://github.com/sympy/sympy/pull/17001"&gt;PR #17001&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;Also since one of the major issues also was to determine the first moment of area, this PR would further help in the calculation of the first moment of area. It intends to give the Polygon class functionality to return a new Polygon segment formed when a given line intersects the Polygon. Although, an alternative method of &lt;strong&gt;Polygon triangulation&lt;/strong&gt; also has been discussed in this PR, to determine the first moment. I will have to do a bit of research for this to get this implemented&lt;strong&gt;.&lt;/strong&gt;&lt;/p&gt;
&lt;h2&gt;&lt;strong&gt;Next Week:&lt;/strong&gt;&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;Implementing a method to determine the first moment of area&lt;/li&gt;
&lt;li&gt;Completing the CrossSection class along with its documentation and testing&lt;/li&gt;
&lt;li&gt;Linking it with the beam module&lt;/li&gt;
&lt;li&gt;Working over the implementation of &lt;strong&gt;Stage-II&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;I will try to make the CrossSection class fully functional, by the end of the coming week.&lt;/p&gt;
&lt;p&gt;Will keep you updated!&lt;/p&gt;
&lt;p&gt;Thanks!&lt;/p&gt;</description>
    </item>
    <item>
      <guid isPermaLink="false">https://arighnaiitg.github.io/2019-06-09-gsoc-week2/</guid>
      <author>Arighna Chakrabarty (arighnaiitg)</author>
      <title>Arighna Chakrabarty (arighnaiitg): GSoC Week 2 !!</title>
      <pubDate>Sun, 09 Jun 2019 07:00:00 GMT</pubDate>
      <link>https://arighnaiitg.github.io/2019-06-09-gsoc-week2/</link>
      <description>&lt;p&gt;Week 2 ends.. - 
          Week 2 of the Coding Period (Phase 1) is coming to an end. This week was mostly devoted towards polishing the existing PRs, and bringing them to a mergeable condition. And this week resulted in the merge of 2 PRs. Yayy !!! Here are the deliverables which have been completed...</description>
    </item>
    <item>
      <guid isPermaLink="false">https://czgdp1807.github.io/week_2</guid>
      <author>Gagandeep Singh (czgdp1807)</author>
      <title>Gagandeep Singh (czgdp1807): Week 2 - A lot of work</title>
      <pubDate>Sun, 09 Jun 2019 00:00:00 GMT</pubDate>
      <link>https://czgdp1807.github.io/week_2/</link>
      <description>&lt;p&gt;This week involved a lot of work and reviews. I worked on three PRs this week which were started for the purpose of, Markov chains, symbolic dimensions and symbolic conditions for finite RVs. Let me tell you how I managed all this.&lt;/p&gt;

&lt;p&gt;The most important and the most demanding PR from all the said topics was that of Markov chain. I told you that we were discussing API for the same. Fortunately the discussion concluded and I started implementation with the starting of the second week, by opeining &lt;a href="https://github.com/sympy/sympy/pull/16981"&gt;#16981&lt;/a&gt;. Infact, the basic structure is ready and I am vary happy, that the code is able to handle &lt;code class="highlighter-rouge"&gt;probability&lt;/code&gt; queries and is generating desirable results. Out of curiosity, I started work on symbolic dimensions for helping one of my fellow students. Infact, it&amp;#8217;s also going to be completed, see &lt;a href="https://github.com/sympy/sympy/pull/16962"&gt;#16962&lt;/a&gt;. The work for symbolic conditions which started for the purpose of correcting &lt;code class="highlighter-rouge"&gt;@XFAIL&lt;/code&gt; tests is also almost complete, take a look at &lt;a href="https://github.com/sympy/sympy/pull/16908"&gt;#16908&lt;/a&gt;. I have observed that still there are some issues with &lt;code class="highlighter-rouge"&gt;sympy.stats.frv&lt;/code&gt; which need to be handled in a different set of PRs. Hopefully, I am planning to make some of those this week if time permits. I also aim to add more features to &lt;code class="highlighter-rouge"&gt;StochasticProcess&lt;/code&gt; like &lt;code class="highlighter-rouge"&gt;joint_distribution&lt;/code&gt;, and adding more properties to &lt;code class="highlighter-rouge"&gt;DiscreteMarkovChain&lt;/code&gt; like, whether it&amp;#8217;s absorbing, transient. Adding, &lt;code class="highlighter-rouge"&gt;ContinuousMarkovChain&lt;/code&gt; will also be on my list.&lt;/p&gt;

&lt;p&gt;Apart from a lot of work there was a lot of learning too. I got many of my concepts cleared, like, inherit &lt;code class="highlighter-rouge"&gt;Basic&lt;/code&gt; only when the instance of the class is going to be a part of &lt;code class="highlighter-rouge"&gt;SymPy&lt;/code&gt; expression. Thanks to &lt;a href="https://github.com/certik"&gt;Ond&amp;#345;ej &amp;#268;ert&amp;#237;k&lt;/a&gt; for this. I also realized the worth of &lt;code class="highlighter-rouge"&gt;sympy.stats.symbolic_probability&lt;/code&gt; while working on symbolic dimensions. Francesco used to suggest that we should use it wherever necessary, but now I completely understand his view.&lt;/p&gt;

&lt;p&gt;That&amp;#8217;s all, thanks for reading. Bye!!&lt;/p&gt;</description>
    </item>
    <item>
      <guid isPermaLink="false">https://jmig5776.github.io//gsoc-week-2</guid>
      <author>Jogi Miglani (jmig5776)</author>
      <title>Jogi Miglani (jmig5776): GSoC 2019 - Week 2</title>
      <pubDate>Sat, 08 Jun 2019 00:00:00 GMT</pubDate>
      <link>https://jmig5776.github.io//gsoc-week-2</link>
      <description>&lt;p&gt;This was the second week meeting with the GSoC mentors which was scheduled on
Saturday 8th June, 2019 between 12:00 - 01:00 PM (IST). Me, Amit, Yathartha and Harsh
were the attendees of the meeting. It was a surprise having Harsh on this meeting.
In this meeting we mainly discussed about how to integrate lambert another way because
the existing method in PR &lt;a href="https://github.com/sympy/sympy/pull/16890"&gt;#16890&lt;/a&gt; is
not trustworthy and upto the mark. So this week I will try to implement the method
or approach told by Yathartha. Important lesson learned in this meeting was that
the method that I implement should have these following qualities to be a better
software developer:-&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Proof Of Correctness&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;This is very important because I should have a plan before I get to code. Many
things already get straightened up while planning for what to implement and it
ultimately reduces coding time and let us get a more accurate and concrete code.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Clean and Understandable Code&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;This factor is also very important to write a code that is easily understandable.
It is better for us as well as it also persuade new contributors easily who are
willing to contribute.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Extensible Code&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;A well written code is always extensible. Proper techniques should be learned to
write an extensible code rather than a code that looks like patch.&lt;/p&gt;

&lt;p&gt;In this week I also started a PR &lt;a href="https://github.com/sympy/sympy/pull/16976"&gt;#16976&lt;/a&gt;
to handle modular equations.&lt;br /&gt;
It was a worth it meeting because I got to learn various important and necessary
qualities from all of the mentors. Harsh was also glad that we were trying to focus
on well written clean code.&lt;/p&gt;

&lt;p&gt;A lot more to learn and implement :) !!&lt;/p&gt;</description>
    </item>
    <item>
      <guid isPermaLink="false">https://sc0rpi0n101.github.io/2019/06/week-2-a-tale-of-the-illusive-pull-request/</guid>
      <author>Nikhil Maan (Sc0rpi0n101)</author>
      <title>Nikhil Maan (Sc0rpi0n101): Week 2: A Tale of The Illusive Pull Request</title>
      <pubDate>Sat, 08 Jun 2019 00:00:00 GMT</pubDate>
      <link>https://sc0rpi0n101.github.io/2019/06/week-2-a-tale-of-the-illusive-pull-request/</link>
      <description>&lt;p&gt;Welcome everyone, this is your host Nikhil Maan aka Sc0rpi0n101 and this time we will talk about the Week 2 of the coding period for GSoC 2019 and the story of the elusive pull requests which people had to wait almost the whole week for.
The Weekend after the Meeting
A Bad Start
Finally, the Pull Request
The Meeting for the Week
The Next Week
The Weekend after the Meeting The plan for the week was discussed in the meeting held on May 30 which was to post a PR with the Clang work and get on track with LFortran with the developer examples in the developer tutorial and post a PR if possible.</description>
    </item>
    <item>
      <guid isPermaLink="false">https://anpandey.github.io/posts/sympy/2019-06-07-week-2.html</guid>
      <author>Ankit Pandey (anpandey)</author>
      <title>Ankit Pandey (anpandey): Google Summer of Code: Week 2</title>
      <pubDate>Fri, 07 Jun 2019 00:00:00 GMT</pubDate>
      <link>https://anpandey.github.io/posts/sympy/2019-06-07-week-2.html</link>
      <description>&lt;p&gt;&lt;article&gt;
    &lt;section class="header"&gt;
        Posted on June  7, 2019
        
            by Ankit Pandey
        
    &lt;/section&gt;
    &lt;section&gt;
        &lt;p&gt;&lt;em&gt;See the &lt;a href="https://anpandey.github.io/2019-05-31-week-1.html"&gt;previous post&lt;/a&gt; for Week 1&lt;/em&gt;.&lt;/p&gt;
&lt;p&gt;For this week, I&amp;#8217;ve continued working on adding support for LFortran to SymPy&amp;#8217;s code generation capabilities. This week mostly involved getting the infrastructure for testing the functionality of the new code generator working. I also extended the number of expressions the generator can handle, in addition to adding to LFortran&amp;#8217;s ability to parse numbers upstream.&lt;/p&gt;
&lt;h2 id="more-expressions"&gt;More Expressions&lt;/h2&gt;
&lt;p&gt;I&amp;#8217;ve added support for four more expression types that the generator can handle: &lt;code&gt;Float&lt;/code&gt;, &lt;code&gt;Rational&lt;/code&gt;, &lt;code&gt;Pow&lt;/code&gt; and &lt;code&gt;Function&lt;/code&gt;. Since our base translation class was already in place from last week, implementing these was relatively straightforward and involved just defining the node visitors for each expression type (The commit that implements this can be found &lt;a href="https://github.com/sympy/sympy/pull/16931/commits/67a06a83d4aa239e8d319837d9ed7d11b67f7846"&gt;here&lt;/a&gt;). Here&amp;#8217;s a demonstration showing the abstract syntax tree generated from translating the expression &lt;math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"&gt;&lt;semantics&gt;&lt;msup&gt;&lt;mrow&gt;&lt;mo form="prefix" stretchy="true"&gt;(&lt;/mo&gt;&lt;mfrac&gt;&lt;mn&gt;4&lt;/mn&gt;&lt;mn&gt;3&lt;/mn&gt;&lt;/mfrac&gt;&lt;mo form="postfix" stretchy="true"&gt;)&lt;/mo&gt;&lt;/mrow&gt;&lt;mi&gt;x&lt;/mi&gt;&lt;/msup&gt;&lt;annotation encoding="application/x-tex"&gt;\left(\frac{4}{3}\right)^{x}&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;:&lt;/p&gt;
&lt;div class="sourceCode" id="cb1"&gt;&lt;pre class="sourceCode python"&gt;&lt;code class="sourceCode python"&gt;&lt;a class="sourceLine" id="cb1-1" title="1"&gt;&lt;span class="op"&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class="im"&gt;from&lt;/span&gt; sympy.abc &lt;span class="im"&gt;import&lt;/span&gt; x&lt;/a&gt;
&lt;a class="sourceLine" id="cb1-2" title="2"&gt;&lt;span class="op"&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class="im"&gt;from&lt;/span&gt; sympy.codegen.lfort &lt;span class="im"&gt;import&lt;/span&gt; sympy_to_lfortran&lt;/a&gt;
&lt;a class="sourceLine" id="cb1-3" title="3"&gt;&lt;span class="op"&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class="im"&gt;from&lt;/span&gt; lfortran.asr.pprint &lt;span class="im"&gt;import&lt;/span&gt; pprint_asr&lt;/a&gt;
&lt;a class="sourceLine" id="cb1-4" title="4"&gt;&lt;span class="op"&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt; pprint_asr(sympy_to_lfortran(Rational(&lt;span class="dv"&gt;4&lt;/span&gt;, &lt;span class="dv"&gt;3&lt;/span&gt;) &lt;span class="op"&gt;**&lt;/span&gt; x))&lt;/a&gt;
&lt;a class="sourceLine" id="cb1-5" title="5"&gt;expr.BinOp&lt;/a&gt;
&lt;a class="sourceLine" id="cb1-6" title="6"&gt;&amp;#9500;&amp;#9472;left&lt;span class="op"&gt;=&lt;/span&gt;expr.BinOp&lt;/a&gt;
&lt;a class="sourceLine" id="cb1-7" title="7"&gt;&amp;#9474; &amp;#9500;&amp;#9472;left&lt;span class="op"&gt;=&lt;/span&gt;expr.Num&lt;/a&gt;
&lt;a class="sourceLine" id="cb1-8" title="8"&gt;&amp;#9474; &amp;#9474; &amp;#9500;&amp;#9472;n&lt;span class="op"&gt;=&lt;/span&gt;&lt;span class="st"&gt;'4_dp'&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb1-9" title="9"&gt;&amp;#9474; &amp;#9474; &amp;#9584;&amp;#9472;type&lt;span class="op"&gt;=&lt;/span&gt;ttype.Real&lt;/a&gt;
&lt;a class="sourceLine" id="cb1-10" title="10"&gt;&amp;#9474; &amp;#9474;   &amp;#9500;&amp;#9472;kind&lt;span class="op"&gt;=&lt;/span&gt;&lt;span class="dv"&gt;4&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb1-11" title="11"&gt;&amp;#9474; &amp;#9474;   &amp;#9584;&amp;#9472;dims&lt;span class="op"&gt;=&lt;/span&gt;[]&lt;/a&gt;
&lt;a class="sourceLine" id="cb1-12" title="12"&gt;&amp;#9474; &amp;#9500;&amp;#9472;op&lt;span class="op"&gt;=&lt;/span&gt;operator.Div&lt;/a&gt;
&lt;a class="sourceLine" id="cb1-13" title="13"&gt;&amp;#9474; &amp;#9500;&amp;#9472;right&lt;span class="op"&gt;=&lt;/span&gt;expr.Num&lt;/a&gt;
&lt;a class="sourceLine" id="cb1-14" title="14"&gt;&amp;#9474; &amp;#9474; &amp;#9500;&amp;#9472;n&lt;span class="op"&gt;=&lt;/span&gt;&lt;span class="st"&gt;'3_dp'&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb1-15" title="15"&gt;&amp;#9474; &amp;#9474; &amp;#9584;&amp;#9472;type&lt;span class="op"&gt;=&lt;/span&gt;ttype.Real&lt;/a&gt;
&lt;a class="sourceLine" id="cb1-16" title="16"&gt;&amp;#9474; &amp;#9474;   &amp;#9500;&amp;#9472;kind&lt;span class="op"&gt;=&lt;/span&gt;&lt;span class="dv"&gt;4&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb1-17" title="17"&gt;&amp;#9474; &amp;#9474;   &amp;#9584;&amp;#9472;dims&lt;span class="op"&gt;=&lt;/span&gt;[]&lt;/a&gt;
&lt;a class="sourceLine" id="cb1-18" title="18"&gt;&amp;#9474; &amp;#9584;&amp;#9472;type&lt;span class="op"&gt;=&lt;/span&gt;ttype.Real&lt;/a&gt;
&lt;a class="sourceLine" id="cb1-19" title="19"&gt;&amp;#9474;   &amp;#9500;&amp;#9472;kind&lt;span class="op"&gt;=&lt;/span&gt;&lt;span class="dv"&gt;4&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb1-20" title="20"&gt;&amp;#9474;   &amp;#9584;&amp;#9472;dims&lt;span class="op"&gt;=&lt;/span&gt;[]&lt;/a&gt;
&lt;a class="sourceLine" id="cb1-21" title="21"&gt;&amp;#9500;&amp;#9472;op&lt;span class="op"&gt;=&lt;/span&gt;operator.Pow&lt;/a&gt;
&lt;a class="sourceLine" id="cb1-22" title="22"&gt;&amp;#9500;&amp;#9472;right&lt;span class="op"&gt;=&lt;/span&gt;x&lt;/a&gt;
&lt;a class="sourceLine" id="cb1-23" title="23"&gt;&amp;#9584;&amp;#9472;type&lt;span class="op"&gt;=&lt;/span&gt;ttype.Real&lt;/a&gt;
&lt;a class="sourceLine" id="cb1-24" title="24"&gt;  &amp;#9500;&amp;#9472;kind&lt;span class="op"&gt;=&lt;/span&gt;&lt;span class="dv"&gt;4&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb1-25" title="25"&gt;  &amp;#9584;&amp;#9472;dims&lt;span class="op"&gt;=&lt;/span&gt;[]&lt;/a&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;However, the translator fails for expressions that should in theory work. Right now, we can&amp;#8217;t add an integer to a symbol because symbols default to real numbers, resulting in a type mismatch:&lt;/p&gt;
&lt;div class="sourceCode" id="cb2"&gt;&lt;pre class="sourceCode python"&gt;&lt;code class="sourceCode python"&gt;&lt;a class="sourceLine" id="cb2-1" title="1"&gt;&lt;span class="op"&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt; pprint_asr(sympy_to_lfortran(&lt;span class="dv"&gt;3&lt;/span&gt; &lt;span class="op"&gt;+&lt;/span&gt; x))&lt;/a&gt;
&lt;a class="sourceLine" id="cb2-2" title="2"&gt;lfortran.asr.asr_check.TypeMismatch: Type mismatch&lt;/a&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Fortran allows the implicit conversion of a float to a real, and the expression shouldn&amp;#8217;t generate an error. This is functionality that will hopefully be implemented by the time I come back to this project close to the end of the summer.&lt;/p&gt;
&lt;h2 id="testing-the-lfortran-converter"&gt;Testing the LFortran Converter&lt;/h2&gt;
&lt;p&gt;I also added the initial infrastructure for testing the new code generation functions, with the starting commit available &lt;a href="https://github.com/sympy/sympy/pull/16931/commits/918c12de43e319f8d3f16d48c19f25d1db248909"&gt;here&lt;/a&gt;. As Aaron mentioned in one of our meetings, the plan right now is for code generated by the LFortran backend to be equivalent to the output generated by the existing &lt;code&gt;fcode&lt;/code&gt; at the AST level. Each test should be in the form of an assertion that tests the (parsed) output of &lt;code&gt;fcode&lt;/code&gt; applied to a SymPy expression against the same AST generated by our newly implemented &lt;code&gt;sympy_to_lfortran&lt;/code&gt;. The LFortran project already has code to check generated ASTs against expected values, so I adapted this to the testing library of our code generator (I&amp;#8217;m also not sure how this works in terms of licensing, since both SymPy and LFortran use the BSD-3 license).&lt;/p&gt;
&lt;p&gt;One problem that immediately became apparent was the way that LFortran represents numbers. Looking at the expression tree above, the real numbers are actually stored as strings. On the parser side, LFortran stores a real number as the string used to represent that number. This means that the ASTs of two expressions that represent the same number in different ways are not identical (for example, &lt;code&gt;1.0_dp&lt;/code&gt; and &lt;code&gt;1.d0&lt;/code&gt; both represent the same double precision floating point number, but the strings stored by LFortran will be different). It&amp;#8217;s only at the &amp;#8220;annotation&amp;#8221; stage of evaluation that LFortran canonicalizes floating point representations. For now, the tests use the annotation function of this stage, and I filed a &lt;a href="https://gitlab.com/lfortran/lfortran/merge_requests/225"&gt;merge request&lt;/a&gt; on the LFortran project to add support for parsing numbers in the way that &lt;code&gt;fcode&lt;/code&gt; generates them.&lt;/p&gt;
&lt;p&gt;While the initial infrastructure is in place, I haven&amp;#8217;t added any tests yet. Since the LFortran project is still in early alpha, the functionality needed to compare the syntax tree made by the builder API against the syntax tree parsed from the output of &lt;code&gt;fcode&lt;/code&gt; hasn&amp;#8217;t been implemented yet. Again, this is something that will hopefully be implemented in LFortran near the end of the summer when I start on this portion of the project again.&lt;/p&gt;
&lt;h3 id="contributing-upstream"&gt;Contributing Upstream&lt;/h3&gt;
&lt;p&gt;After I filed the merge request to add the functionality I needed to LFortran, Ondr&amp;#780;ej (the creator of LFortran and one of my mentors) mentioned that he was planning on eventually removing the module I contributed to. The merge request I filed actually wasn&amp;#8217;t the one I had in mind at first. I thought about adding support for canonicalizing number nodes right after they&amp;#8217;re created in the builder API, but I decided against this because I felt that any changes I made would have to be minimally invasive. In retrospect, this was probably a misplaced concern, since it&amp;#8217;s important to consider the development stage of a project when deciding how much of it should be changed. Because of this, LFortran will probably end up with something I opted at the moment to not implement.&lt;/p&gt;
&lt;h2 id="next-steps"&gt;Next Steps&lt;/h2&gt;
&lt;p&gt;There&amp;#8217;s still some work left to be done with LFortran, such as filing issues I encountered and preparing the pull request for a merge (though it&amp;#8217;ll probably remain a work in progress for some time). After that, I&amp;#8217;ll be finished with LFortran for the time being and move on to extending support for matrix expressions in the Python code generator. The Python code generator can already convert (most) matrix expressions through NumPy, though there are still some bugs owing to an incomplete implementation. For next week, I&amp;#8217;ll have to figure out what this missing functionality is how it can be implemented.&lt;/p&gt;
    &lt;/section&gt;
&lt;/article&gt;</description>
    </item>
    <item>
      <guid isPermaLink="false">https://sc0rpi0n101.github.io/2019/06/week-0-communtiy-bonding-period-a-new-beginning/</guid>
      <author>Nikhil Maan (Sc0rpi0n101)</author>
      <title>Nikhil Maan (Sc0rpi0n101): Week 0: Communtiy Bonding Period - A new Beginning</title>
      <pubDate>Wed, 05 Jun 2019 00:00:00 GMT</pubDate>
      <link>https://sc0rpi0n101.github.io/2019/06/week-0-communtiy-bonding-period-a-new-beginning/</link>
      <description>&lt;p&gt;Welcome everyone, this is your host Nikhil Maan aka Sc0rpi0n101 and today I would like to tell you about the Community Bonding Period of GSoC 2019 and also talk about my project and organization in detail.
 GSoC My Project The Organizations Community Bonding Period  GSoC Google Summer of Code (GSoC) is a 12-week program, sponsored by Google to promote open-source among various college students around the world, where the people selected are assigned to projects from different open-source organizations working over the summer contributing to open-source software.</description>
    </item>
    <item>
      <guid isPermaLink="false">https://divyanshu132.github.io//gsoc-week-1</guid>
      <author>Divyanshu Thakur (divyanshu132)</author>
      <title>Divyanshu Thakur (divyanshu132): GSoC 2019 - Week 1 - Composition series computation</title>
      <pubDate>Tue, 04 Jun 2019 00:00:00 GMT</pubDate>
      <link>https://divyanshu132.github.io//gsoc-week-1</link>
      <description>&lt;p&gt;The coding period has been started from 27 may 2019 and the first week went well. We worked on the composition series computation for solvable groups. I was waiting for the PR to get merged so, that I can include a fully completed PR here &amp;#128578;. Kalevi helped a lot in reviewing and helping me with the algorithm. The PR link is &lt;a href="https://github.com/sympy/sympy/pull/16881"&gt;here&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Till now, everything is going as it was planned. The abelian invariants PR has been already merged in the community bonding period itself, may be some other time I&amp;#8217;ll discuss about the details of it but for the time being one can look into the PR of abelian invariants &lt;a href="https://github.com/sympy/sympy/pull/16670"&gt;here&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Composition series of a group &lt;code class="highlighter-rouge"&gt;G&lt;/code&gt; is defined as the subnormal series &lt;code class="highlighter-rouge"&gt;G = H_0 &amp;gt; H_1 &amp;gt; H_2 \ldots &amp;gt; H_k = 1&lt;/code&gt; where every factor group
&lt;code class="highlighter-rouge"&gt;H(i+1)/H(i)&lt;/code&gt; is simple. The algorithm is described in the implementation itself. We wanted to make sure, the implemeted method work as expected so, I wrote a good amount of tests and examples in the docs.&lt;/p&gt;

&lt;p&gt;The tasks that I&amp;#8217;m hopping to accomplish in the next week are:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Discuss with Kalevi about the Polycyclic group implementation.&lt;/li&gt;
  &lt;li&gt;In the end of the week get ready with WIP PR on pc groups.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Hopping I&amp;#8217;ll be able to execute things as planned! Till then good bye, keep learning.&lt;/p&gt;</description>
    </item>
    <item>
      <guid isPermaLink="false">https://shubhamkjha.github.io/2019/06/04/GSoC-2019-Week-1</guid>
      <author>Shubham Kumar Jha (ShubhamKJha)</author>
      <title>Shubham Kumar Jha (ShubhamKJha): GSoC 2019: Week 1</title>
      <pubDate>Tue, 04 Jun 2019 00:00:00 GMT</pubDate>
      <link>https://shubhamkjha.github.io/2019/06/04/GSoC-2019-Week-1.html</link>
      <description>&lt;p&gt;The first week of official Coding Period is over and it went well &amp;#128516;.&lt;/p&gt;

&lt;p&gt;As proposed, I created a branch over &lt;a href="https://github.com/sympy/sympy/pull/7608"&gt;#7608&lt;/a&gt; and went through it locally. I have made certain improvements and I will create appropriate PR for them this week. I intend to get that merged in this week only, if everything goes well. Also, as suggested by Aaron, I looked for profiling tools for optimizing slow parts in the codebase. I will be using &lt;a href="https://pypi.org/project/pyinstrument/"&gt;&lt;strong&gt;pyinstrument&lt;/strong&gt;&lt;/a&gt; and the profiler of PyCharm for this purpose.&lt;/p&gt;

&lt;p&gt;Later in this week, I started the PR &lt;a href="https://github.com/sympy/sympy/pull/16956"&gt;#16956&lt;/a&gt; which fixes issues &lt;a href="https://github.com/sympy/sympy/issues/16915"&gt;#16915&lt;/a&gt; and &lt;a href="https://github.com/sympy/sympy/issues/16582"&gt;#16582&lt;/a&gt;. Both these issues are related to assumptions handling in Relationals. It broke more code than expected &amp;#128517;. This shows how embedded the old assumptions are in the codebase. I will try to fix them ASAP.&lt;/p&gt;

&lt;p&gt;With the first week wrapped up, in the next week :&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;I will create an experimental PR to include &lt;code class="highlighter-rouge"&gt;complex -&amp;gt; finite&lt;/code&gt; in the old assumptions. This is going to break &lt;code class="highlighter-rouge"&gt;zoo.is_complex&lt;/code&gt; overall. I will try to do it without including new facts. &lt;a href="https://github.com/sympy/sympy/pull/16666"&gt;#16666&lt;/a&gt; shows how difficult such proceedings can be.&lt;/li&gt;
  &lt;li&gt;I will also create a PR to include &lt;code class="highlighter-rouge"&gt;complex -&amp;gt; finite&lt;/code&gt; in the new assumptions. This should be easier than the former. The new assumptions is still not used much in the codebase &amp;#128524;.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;I will try to shift my focus more towards the new assumptions. But I will also look for any major inconsistency between the assumptions systems.&lt;/p&gt;

&lt;p&gt;With this, sign out for the next week.&lt;/p&gt;</description>
    </item>
    <item>
      <guid isPermaLink="false">https://www.kangzhiq.com/?p=11</guid>
      <author>Zhiqi KANG (kangzhiq)</author>
      <title>Zhiqi KANG (kangzhiq): [GSoC 2019] WEEK 1!</title>
      <pubDate>Sun, 02 Jun 2019 22:38:28 GMT</pubDate>
      <link>https://www.kangzhiq.com/2019/06/03/gsoc-week-1/</link>
      <description>&lt;p&gt;Hello everyone! Here comes the end of the first coding week. This blog is dedicated to present the progress that I have had during the past week. &lt;/p&gt;



&lt;ul&gt;&lt;li&gt;PRs&lt;/li&gt;&lt;/ul&gt;



&lt;p&gt;This week the PR about  ArrayComprehension   is merged. &lt;a href="https://github.com/sympy/sympy/pull/16845"&gt;#16845&lt;/a&gt;. This class is designed as an extension of list comprehension in Python, which enables the list comprehension with symbolic dimensions. &lt;/p&gt;



&lt;p&gt;A new PR &lt;a href="https://github.com/sympy/sympy/pull/16937"&gt;#16937&lt;/a&gt; about the sparse array being cast to dense array in the case of derive_by_array is opened. But somes improvements are still needed. The challenge is to find an approriate method to override and perform a derivative correctly. &lt;/p&gt;



&lt;ul&gt;&lt;li&gt;Issues&lt;/li&gt;&lt;/ul&gt;



&lt;p&gt;An issue &lt;a href="https://github.com/sympy/sympy/issues/16911"&gt;#16911&lt;/a&gt; is opened. It is in fact a discussion about implementing a NumPy-Like behavior in Array module. It is interesting because my mentor was, at first, not in favor of this implementation. But some differences of behavior between the Array module in SymPy and the one in NumPy did change his mind. So this implementation can be kept in my proposal and will be my tasks for the next phase.&lt;/p&gt;



&lt;p&gt;Another issue &lt;a href="https://github.com/sympy/sympy/issues/16941"&gt;#16941&lt;/a&gt; whose aim is to list out all cases where a sparse array is cast to dense arrays is opened this week. Not only as a discussion, this issue would also be a overview of the problems so that the PRs like &lt;a href="https://github.com/sympy/sympy/pull/16937"&gt;#16937&lt;/a&gt; can refer to it. A checklist is being updated to show the avancement. &lt;/p&gt;



&lt;p&gt;Please feel free to comment on the issues or the PRs that I opened. I would love to listen to your opinions.&lt;/p&gt;



&lt;ul&gt;&lt;li&gt;Reviews&lt;/li&gt;&lt;/ul&gt;



&lt;p&gt;After the merge of ArrayComprehension, another student  &lt;a href="https://github.com/czgdp1807"&gt;Gagandeep Singh&lt;/a&gt;  opened a new PR to ameliorate the code quality of this class. I have also participated as a reviewer to offer some help. I have also leant a lot from the discussion.&lt;/p&gt;



&lt;ul&gt;&lt;li&gt;Related works&lt;/li&gt;&lt;/ul&gt;



&lt;p&gt;Not much, due to the burden of projects in college. &lt;/p&gt;</description>
    </item>
    <item>
      <guid isPermaLink="false">http://ishanaj.wordpress.com/?p=42</guid>
      <author>Ishan Joshi (ishanaj)</author>
      <title>Ishan Joshi (ishanaj): GSoC&#x2019;19: Week 1 &#x2013; Starting with the CrossSection class</title>
      <pubDate>Sun, 02 Jun 2019 18:39:36 GMT</pubDate>
      <link>https://ishanaj.wordpress.com/2019/06/03/gsoc19-week-1-starting-with-the-crosssection-class/</link>
      <description>&lt;p&gt;The &lt;strong&gt;GSoC&lt;/strong&gt; timeline started as soon as the projects were announced and so did the work on projects.&lt;/p&gt;
&lt;p&gt;The &lt;strong&gt;Community bonding&lt;/strong&gt; period ended last week. There wasn&amp;#8217;t much work in the community bonding period. All I had to do was to extend my knowledge base related to the project and to familiarize with the development flow.&lt;/p&gt;
&lt;p&gt;I started with going through the geometry module, which has a major role to play in the implementation of the &lt;strong&gt;Stage-I&lt;/strong&gt; i.e. the implementation of CrossSection module. Also, I studied about the different properties of cross-sections, like, the first moment of area, polar modulus, section modulus, etc.&lt;/p&gt;
&lt;p&gt;So the coding period started on &lt;strong&gt;27&lt;sup&gt;th&lt;/sup&gt; May&lt;/strong&gt; and now the first week is completed. My task in the first week was to start the implementation of the CrossSection module. It majorly comprised of defining a &lt;strong&gt;new class CrossSection&lt;/strong&gt;.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Major tasks&lt;/strong&gt; inside the CrossSection class were:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Defining the different geometries using the geometry module:&lt;/strong&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Circle:&amp;#160;&lt;/strong&gt;A circular cross-section was easily defined by using class &lt;a href="https://docs.sympy.org/latest/modules/geometry/ellipses.html#sympy.geometry.ellipse.Circle"&gt;sympy.geometry.ellipses.Circle&lt;/a&gt;&lt;span&gt;.&amp;#160;&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Rectangle, I-section, T-section, triangle:&amp;#160;&lt;/strong&gt;These four shapes were defined using class &lt;a href="https://docs.sympy.org/latest/modules/geometry/polygons.html#sympy.geometry.polygon.Polygon"&gt;sympy.geometry.polygons.Polygon&lt;/a&gt;. These geometries were defined using &lt;strong&gt;point to point mapping&lt;/strong&gt; in the counter-clockwise direction in such a way that it starts at the origin and joins all the given points or vertices of the polygon in the given sequence.&lt;/li&gt;
&lt;li&gt;All these geometries were defined in a way that they lie in the first quadrant, in order to get correct values of the centroid.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Defining different properties of the above cross-sections:&lt;/strong&gt;
&lt;ul&gt;
&lt;li&gt;Area&lt;/li&gt;
&lt;li&gt;Centroid&lt;/li&gt;
&lt;li&gt;Second moment&lt;/li&gt;
&lt;li&gt;Polar modulus&lt;/li&gt;
&lt;li&gt;Section Modulus&lt;/li&gt;
&lt;li&gt;First moment&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Implementing these was not that difficult as area, centroid, the second moment are already implemented in the geometry module. On the other hand, polar modulus and section modulus were specifically defined in the CrossSection module separately for each geometry.&lt;/p&gt;
&lt;h2&gt;&lt;strong&gt;The problem of defining the first moment of area: &lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;The way the first moment of area is calculated can be seen from &lt;a href="https://skyciv.com/tutorials/calculating-statical-or-first-moment-of-area-of-beam-sections/"&gt;here&lt;/a&gt;. And since the first moment of area is required majorly to calculate the &lt;a href="http://abe-research.illinois.edu/faculty/dickc/Engineering/beamshear2b.htm"&gt;Transverse shear stress&lt;/a&gt; on a beam, we are interested only in the first moment along the x-axis (or the horizontal axis).&lt;/p&gt;
&lt;p&gt;But just a day pondering over it I realized that the first moment calculated as above calculates it for the extreme layer of the beam. Probably, we will have to return it &lt;strong&gt;in terms of y&lt;/strong&gt;, so that the shear stress at any layer could be calculated.&lt;/p&gt;
&lt;p&gt;&lt;em&gt;&lt;strong&gt;where &amp;#8220;y&amp;#8221;&amp;#160;&lt;/strong&gt;is the distance of the layer of the beam from the neutral axis&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;So, I will be opening an &lt;strong&gt;issue-cum-discussion &lt;/strong&gt;regarding the above problem to discuss it with the mentors. Also, I will soon be opening a &lt;strong&gt;work-in-progress&lt;/strong&gt; &lt;strong&gt;PR&lt;/strong&gt; regarding what has been implemented.&lt;/p&gt;
&lt;h2&gt;&lt;strong&gt;Next Week:&lt;/strong&gt;&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;Completing the CrossSection class and linking it with the beam module via an&lt;strong&gt; add_cross_section() &lt;/strong&gt;function.&lt;/li&gt;
&lt;li&gt;Adding tests to the CrossSection module and in the Beam module&lt;/li&gt;
&lt;li&gt;Completing documentation of the CrossSection module.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Since I had to travel this weekend there was a bit of delay in the progress. But I am positive that I will be able to compensate for it in the next week. Also, I will try to keep the work a bit in advance.&lt;/p&gt;
&lt;p&gt;Will keep you updated!&lt;/p&gt;
&lt;p&gt;Thanks!&lt;/p&gt;</description>
    </item>
    <item>
      <guid isPermaLink="false">https://arighnaiitg.github.io/2019-06-02-gsoc-week1/</guid>
      <author>Arighna Chakrabarty (arighnaiitg)</author>
      <title>Arighna Chakrabarty (arighnaiitg): GSoC Week 1 !!</title>
      <pubDate>Sun, 02 Jun 2019 07:00:00 GMT</pubDate>
      <link>https://arighnaiitg.github.io/2019-06-02-gsoc-week1/</link>
      <description>&lt;p&gt;Week 1 ends.. - 
          Week 1 of the Coding Period (Phase 1) is coming to an end. It was a hectic week for me, as I had to travel in the initial days of the week, but the work done in Community Bonding Period, helped me to progress faster. I also had a meeting...</description>
    </item>
    <item>
      <guid isPermaLink="false">https://czgdp1807.github.io/first_week</guid>
      <author>Gagandeep Singh (czgdp1807)</author>
      <title>Gagandeep Singh (czgdp1807): Week 1 - All about design, imporvements and bug fixes</title>
      <pubDate>Sun, 02 Jun 2019 00:00:00 GMT</pubDate>
      <link>https://czgdp1807.github.io/first_week/</link>
      <description>&lt;p&gt;The first week of official coding phase is over and it&amp;#8217;s time to tell you about what I did and what I learnt. So here it goes.&lt;/p&gt;

&lt;p&gt;I started discussion with my mentor about API design of Markov chain. We have more clarity about the same than before. The final API will be somewhat closer to the one mentioned in &lt;a href="https://github.com/sympy/sympy/issues/16895#issuecomment-497649797"&gt;this&lt;/a&gt; comment. The discussion about probability space of stochastic process is under way. We will conclude that soon.&lt;/p&gt;

&lt;p&gt;I also made some PRs during this week for improving the distributions which I added during the bonding period. The PR &lt;a href="https://github.com/sympy/sympy/pull/16914"&gt;#16914&lt;/a&gt; allowed the possibility of symbolic dimensions in &lt;code class="highlighter-rouge"&gt;MultivariateEwens&lt;/code&gt;. We earlier decided that we will use &lt;code class="highlighter-rouge"&gt;ArrayComprehension&lt;/code&gt; which one of my fellow students developed. However, currently it needs a lot of improvements before being put to use. I have made an attempt to optimise the code of &lt;code class="highlighter-rouge"&gt;ArrayComprehension&lt;/code&gt; via PR &lt;a href="https://github.com/sympy/sympy/pull/16929"&gt;#16929&lt;/a&gt;. It also covers some cases which were left during the inital merge. I have also tried to allow symbolic conditions to finite probability spaces. I have two approaches for review. One of them is in the &lt;a href="https://github.com/sympy/sympy/pull/16908/files"&gt;diff of PR #16908&lt;/a&gt; and the other one is in &lt;a href="https://github.com/sympy/sympy/pull/16908#issuecomment-497950242"&gt;this&lt;/a&gt; comment. I have also made some minor improvements like changing namespace of &lt;code class="highlighter-rouge"&gt;joint_rv_types&lt;/code&gt; via PR &lt;a href="https://github.com/sympy/sympy/pull/16919"&gt;#16919&lt;/a&gt;, enhancement of &lt;code class="highlighter-rouge"&gt;P&lt;/code&gt; in PR &lt;a href="https://github.com/sympy/sympy/pull/16907"&gt;#16907&lt;/a&gt; and some general bug fixes in &lt;code class="highlighter-rouge"&gt;MarginalDistribution&lt;/code&gt; at PR &lt;a href="https://github.com/sympy/sympy/pull/16934"&gt;#16934&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Doing all this I learnt a lot of things. The most important was that API design matters the most. Without it, it&amp;#8217;s not possible to develop a good class structure. Thanks to Francesco for making me learn this fact. The other thing is, how sometimes even to make small changes in a large code base, it takes hours to get it right. Another fact which I learnt is how small optimisations in a large of code base can improve the performance.&lt;/p&gt;

&lt;p&gt;See you next week with some more progress. :)&lt;/p&gt;</description>
    </item>
    <item>
      <guid isPermaLink="false">https://jmig5776.github.io//gsoc-week-1</guid>
      <author>Jogi Miglani (jmig5776)</author>
      <title>Jogi Miglani (jmig5776): GSoC 2019 - Week 1</title>
      <pubDate>Sun, 02 Jun 2019 00:00:00 GMT</pubDate>
      <link>https://jmig5776.github.io//gsoc-week-1</link>
      <description>&lt;p&gt;This was the first week meeting with the GSoC mentors which was scheduled on
Sunday 2nd June, 2019 between 11:30 AM - 12:30 PM (IST). Me, Amit and Yathartha
were the attendees of the meeting. In this meeting we mainly discussed about the
problems and implementation for my pull request &lt;a href="https://github.com/sympy/sympy/pull/16890"&gt;#16890&lt;/a&gt;
to complete the lambert solver.&lt;br /&gt;
As Amit requested changes at the pull request to describe the problem in detail,
to give proof of correctness and describe the plan more briefly. So here below
are the all details for what I am trying to achieve and how I am trying to
achieve this:-&lt;/p&gt;

&lt;h3 id="current-implementation"&gt;Current Implementation&lt;/h3&gt;

&lt;p&gt;Let me show here code from &lt;code class="highlighter-rouge"&gt;_lambert&lt;/code&gt; function to show the current
implementation so that I could describe the problem in detail:-&lt;/p&gt;
&lt;div class="language-python highlighter-rouge"&gt;&lt;div class="highlight"&gt;&lt;pre class="highlight"&gt;&lt;code&gt;&lt;span class="n"&gt;u&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;Dummy&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;'rhs'&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="n"&gt;sol&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;[]&lt;/span&gt;
&lt;span class="c"&gt;# check only real solutions:&lt;/span&gt;
&lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="n"&gt;k&lt;/span&gt; &lt;span class="ow"&gt;in&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;]:&lt;/span&gt;
    &lt;span class="n"&gt;l&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;LambertW&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;d&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;b&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;exp&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;c&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;d&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="n"&gt;b&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;exp&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;f&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;),&lt;/span&gt; &lt;span class="n"&gt;k&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="c"&gt;# if W's arg is between -1/e and 0 there is&lt;/span&gt;
    &lt;span class="c"&gt;# a -1 branch real solution, too.&lt;/span&gt;
    &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="n"&gt;k&lt;/span&gt; &lt;span class="ow"&gt;and&lt;/span&gt; &lt;span class="ow"&gt;not&lt;/span&gt; &lt;span class="n"&gt;l&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;is_real&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
        &lt;span class="k"&gt;continue&lt;/span&gt;
    &lt;span class="n"&gt;rhs&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;c&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="n"&gt;b&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="n"&gt;d&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;l&lt;/span&gt;

    &lt;span class="n"&gt;solns&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;solve&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;X1&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt; &lt;span class="n"&gt;u&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;tmp&lt;/span&gt; &lt;span class="ow"&gt;in&lt;/span&gt; &lt;span class="nb"&gt;enumerate&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;solns&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
        &lt;span class="n"&gt;solns&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;tmp&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;subs&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;u&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;rhs&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
        &lt;span class="n"&gt;sol&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;append&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;solns&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;])&lt;/span&gt;
&lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;sol&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Explanation of for loop:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;&lt;code class="highlighter-rouge"&gt;k == -1&lt;/code&gt; :- In this case all the real solutions are considered due to &lt;code class="highlighter-rouge"&gt;not l.is_real&lt;/code&gt;.&lt;/li&gt;
  &lt;li&gt;&lt;code class="highlighter-rouge"&gt;k == 0&lt;/code&gt; :- In this case all the solutions come out to be real as always.&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id="what-solutions-are-missed"&gt;What solutions are missed?&lt;/h3&gt;
&lt;p&gt;The solutions are missed due to the argument inside the &lt;code class="highlighter-rouge"&gt;LambertW&lt;/code&gt; function of value&lt;/p&gt;
&lt;div class="highlighter-rouge"&gt;&lt;div class="highlight"&gt;&lt;pre class="highlight"&gt;&lt;code&gt;l = LambertW(d/(a*b)*exp(c*d/a/b)*exp(-f/a), k)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;While converting all lambert solvable equations to this form
&lt;code class="highlighter-rouge"&gt;F(X, a..f) = a*log(b*X + c) + d*X + f = 0&lt;/code&gt; some solutions get missed.&lt;/p&gt;

&lt;p&gt;For eg:
Consider the equation &lt;code class="highlighter-rouge"&gt;(a/x + exp(x/2)).diff(x) = 0&lt;/code&gt; which is
&lt;code class="highlighter-rouge"&gt;-a/x**2 + exp(x/2)/2 = 0&lt;/code&gt;(Please take note of the &lt;code class="highlighter-rouge"&gt;x**2&lt;/code&gt; in denominator of a).
And we can also write this equation as &lt;code class="highlighter-rouge"&gt;-a/(-x)**2 + exp(x/2)/2 = 0&lt;/code&gt;.
What sympy do is to convert this equation to this form:&lt;/p&gt;
&lt;div class="highlighter-rouge"&gt;&lt;div class="highlight"&gt;&lt;pre class="highlight"&gt;&lt;code&gt;F(X, a..f) = a*log(b*X + c) + d*X + f = 0
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;which will be &lt;code class="highlighter-rouge"&gt;2*log(x) + x/2 - log(a) = 0&lt;/code&gt; and &lt;code class="highlighter-rouge"&gt;2*log(-x) + x/2 - log(a) = 0&lt;/code&gt; respectively:
So solutions corresponding to both equations are:&lt;/p&gt;
&lt;div class="highlighter-rouge"&gt;&lt;div class="highlight"&gt;&lt;pre class="highlight"&gt;&lt;code&gt;2*log(x) + x/2 - log(a) = 0 --&amp;gt; [4*LambertW(sqrt(2)*sqrt(a)/4)] --&amp;gt; this is currently included
2*log(-x) + x/2 - log(a) = 0 --&amp;gt; [4*LambertW(-sqrt(2)*sqrt(a)/4)] --&amp;gt; this is missed
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id="what-type-of-lambert-type-equation-it-is-for"&gt;What type of lambert type equation it is for?&lt;/h3&gt;
&lt;p&gt;This is for the equations where the changing of cofficients of the target equation doesn&amp;#8217;t
change the original equation just like the above case.&lt;/p&gt;

&lt;h3 id="whats-the-current-algorithm-to-solve-such-type-of-equation-and-whats-wrong-with-current-logic"&gt;What&amp;#8217;s the current algorithm to solve such type of equation and what&amp;#8217;s wrong with current logic?&lt;/h3&gt;

&lt;p&gt;Current implementation is shown above and what is wrong is that it is not considering
the other logarithm equations which are originated from the original equation.
&lt;code class="highlighter-rouge"&gt;2*log(-x) + x/2 - log(a) = 0&lt;/code&gt; in case of &lt;code class="highlighter-rouge"&gt;(a/x + exp(x/2)).diff(x) = 0&lt;/code&gt;.&lt;/p&gt;

&lt;h3 id="whats-the-proposed-solution"&gt;What&amp;#8217;s the proposed solution?&lt;/h3&gt;

&lt;p&gt;This problem can be solved by two methods as follows:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Combining all the logarithm forms generated by the original equation(by taking abs)
    &lt;div class="highlighter-rouge"&gt;&lt;div class="highlight"&gt;&lt;pre class="highlight"&gt;&lt;code&gt;2*log(x) + x/2 - log(a) = 0 + 2*log(-x) + x/2 - log(a) = 0
                      \      /
                       \    /
                        \  /
          2*log(abs(x)) + x/2 - log(a) = 0                     
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
    &lt;p&gt;I think this method is not viable at this time as it will be very complex to solve
the equation invloving abs with log.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;This method I propose to solve this problem i.e considering all solutions and
eliminating by substitution.
For example for this equation &lt;code class="highlighter-rouge"&gt;(1/x + exp(x/2)).diff(x) = 0&lt;/code&gt;
Possible solutions considered &lt;code class="highlighter-rouge"&gt;[4*LambertW(-sqrt(2)*sqrt(a)/4), 4*LambertW(sqrt(2)*sqrt(a)/4), \
4*LambertW(-sqrt(2)*sqrt(a)/4, -1), 4*LambertW(sqrt(2)*sqrt(a)/4, -1)]&lt;/code&gt;
Solutions after filtering from checksol &lt;code class="highlighter-rouge"&gt;[4*LambertW(-sqrt(2)*sqrt(a)/4), 4*LambertW(sqrt(2)*sqrt(a)/4)]&lt;/code&gt;.&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id="why-is-the-proposed-solution-better-and-how-it-wont-effect-the-other-equations-no-side-effects"&gt;Why is the proposed solution better and how it won&amp;#8217;t effect the other equations (no side effects)?&lt;/h3&gt;

&lt;p&gt;This method involves less computation to solve this problem i.e considering all solutions and
eliminating by substitution rather than first converting the given equation to target equation
in which we doesn&amp;#8217;t know about coffecient of logarithmic equation and solving it again by
making different equations from it in case of abs taken.&lt;/p&gt;

&lt;p&gt;This doesn&amp;#8217;t effect other equation because the only thing we are doing is considering all solutions
and not changing code for other type of equations. And we are using checksol to check the correct solutions.&lt;/p&gt;

&lt;h3 id="what-is-the-testing-strategy-to-verify-that-the-proposed-solution-works"&gt;What is the testing strategy to verify that the proposed solution works?&lt;/h3&gt;
&lt;p&gt;Testing strategy should be to involve the cases where current implementation is
missing other logarithmic equations.&lt;/p&gt;

&lt;h3 id="which-examplesequations-are-we-going-to-use-to-make-sure-that-those-are-necessary-and-sufficient-for-testing-purposes"&gt;Which examples/equations are we going to use to make sure that those are necessary and sufficient for testing purposes?&lt;/h3&gt;
&lt;p&gt;According to me these tests are sufficient test this strategy:&lt;/p&gt;
&lt;div class="highlighter-rouge"&gt;&lt;div class="highlight"&gt;&lt;pre class="highlight"&gt;&lt;code&gt;assert solve((a/x + exp(x/2)).diff(x), x) == \
        [4*LambertW(-sqrt(2)*sqrt(a)/4), 4*LambertW(sqrt(2)*sqrt(a)/4)]
assert solve(x*log(x) + 3*x + 1, x) == \
        [exp(-3 + LambertW(-exp(3))), exp(-3 + LambertW(-exp(3), -1))]
assert solve((1/x + exp(x/2)).diff(x, 2), x) == \
            [6*LambertW((-1)**(S(1)/3)/3), 6*LambertW((-1)**(S(1)/3)/3, -1)]
assert solve(-x**2 + 2**x, x) == [2, 4, -2*LambertW(log(2)/2)/log(2)]
# issue 4271
assert solve((a/x + exp(x/2)).diff(x, 2), x) == \
            [6*LambertW(-(-1)**(S(1)/3)*a**(S(1)/3)/3),
            6*LambertW((-1)**(S(1)/3)*a**(S(1)/3)/3),
            6*LambertW(-(-1)**(S(1)/3)*a**(S(1)/3)/3, -1),
            6*LambertW((-1)**(S(1)/3)*a**(S(1)/3)/3, -1)]
assert solve(x**2 - y**2/exp(x), x, y, dict=True) == \
                [{x: 2*LambertW(-y/2)}, {x: 2*LambertW(y/2)}]
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id="some-test-cases-that-fail-due-to-some-other-reasons"&gt;Some test cases that fail due to some other reasons&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;div class="highlighter-rouge"&gt;&lt;div class="highlight"&gt;&lt;pre class="highlight"&gt;&lt;code&gt;assert solve((1/x + exp(x/2)).diff(x), x) == \
[4*LambertW(-sqrt(2)/4), 4*LambertW(sqrt(2)/4), 4*LambertW(-sqrt(2)/4, -1)]
assert solve(x**2 - 2**x, x) == [2, 4]
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
    &lt;p&gt;These tests are failing because checksol returns false but expected to return true
Although &lt;code class="highlighter-rouge"&gt;_lambert&lt;/code&gt; is returning correct solutions of equation.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;code class="highlighter-rouge"&gt;assert solve(a/x + exp(x/2), x) == [2*LambertW(-a/2), 2*LambertW(a/2)]&lt;/code&gt;
In this case &lt;code class="highlighter-rouge"&gt;2*LambertW(a/2)&lt;/code&gt; which is not a solution is included because checksol returns none.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;div class="highlighter-rouge"&gt;&lt;div class="highlight"&gt;&lt;pre class="highlight"&gt;&lt;code&gt;&amp;gt;&amp;gt;&amp;gt;solve((1/x + exp(x/2)).diff(x, 2), x)
[6*LambertW((-1)**(1/3)/3), 6*LambertW((-1)**(1/3)/3, -1)]
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
    &lt;p&gt;here &lt;code class="highlighter-rouge"&gt;(-1)**1/3&lt;/code&gt; can have these values &lt;code class="highlighter-rouge"&gt;-1, 1/6(1 - I*3**1/3), 1/6(1 + I*3**1/3)&lt;/code&gt;
but sympy only take &lt;code class="highlighter-rouge"&gt;(-1)**1/3&lt;/code&gt; to be &lt;code class="highlighter-rouge"&gt;1/6(1 - I*3**1/3)&lt;/code&gt; whereas
real solutions are &lt;code class="highlighter-rouge"&gt;[6*LambertW(-1/3), 6*LambertW(-1/3, -1)]&lt;/code&gt;&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id="why-including-checksol-in-_solve_lambert-"&gt;Why including checksol in &lt;code class="highlighter-rouge"&gt;_solve_lambert&lt;/code&gt; ?&lt;/h3&gt;

&lt;p&gt;Due to this test case:&lt;/p&gt;
&lt;div class="highlighter-rouge"&gt;&lt;div class="highlight"&gt;&lt;pre class="highlight"&gt;&lt;code&gt;p = symbols('p', positive=True)
eq = 4*2**(2*p + 3) - 2*p - 3
assert _solve_lambert(eq, p, _filtered_gens(Poly(eq), p)) == [
    -S(3)/2 - LambertW(-4*log(2))/(2*log(2))]
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;To remove the solutions which were supposed to be checked by checksol later in solve.&lt;/p&gt;

&lt;p&gt;Pardon me if I missed a thing!!&lt;/p&gt;</description>
    </item>
    <item>
      <guid isPermaLink="false">https://anpandey.github.io/posts/sympy/2019-05-31-week-1.html</guid>
      <author>Ankit Pandey (anpandey)</author>
      <title>Ankit Pandey (anpandey): Google Summer of Code: Week 1</title>
      <pubDate>Fri, 31 May 2019 00:00:00 GMT</pubDate>
      <link>https://anpandey.github.io/posts/sympy/2019-05-31-week-1.html</link>
      <description>&lt;p&gt;&lt;article&gt;
    &lt;section class="header"&gt;
        Posted on May 31, 2019
        
            by Ankit Pandey
        
    &lt;/section&gt;
    &lt;section&gt;
        &lt;p&gt;For the past week, I&amp;#8217;ve been working on adding support for &lt;a href="https://lfortran.org/"&gt;LFortran&lt;/a&gt; to SymPy&amp;#8217;s code generation capabilities. My current goal is to emulate SymPy&amp;#8217;s &lt;code&gt;fcode&lt;/code&gt;, which converts a SymPy expression to an equivalent expression in Fortran, utilizing only LFortran as a backend. This post is an outline of what I&amp;#8217;ve done (and learned) over last week.&lt;/p&gt;
&lt;h2 id="lfortran"&gt;LFortran&lt;/h2&gt;
&lt;p&gt;LFortran is a Fortran (with some extensions) to LLVM compiler. One advantage that this design provides is that it enables interactive execution of Fortran code. LFortran can also be used as a Jupyter kernel, which means it can be used in a Jupyter notebook environment (you can even find an online interactive demo &lt;a href="https://mybinder.org/v2/gl/lfortran%2Fweb%2Flfortran-binder/master?filepath=Demo.ipynb"&gt;here&lt;/a&gt;).&lt;/p&gt;
&lt;p&gt;In addition to being able to parse code, LFortran also provides the functionality of traversing a parse tree and generating the equivalent Fortran code. This means that if we want to generate Fortran code from a SymPy expression, the only work that we have to do is convert the SymPy expression tree to its LFortran equivalent.&lt;/p&gt;
&lt;h3 id="lfortran-builder"&gt;LFortran Builder&lt;/h3&gt;
&lt;p&gt;LFortran provides a number of convenience functions for building a Fortran AST. Since LFortran is still in early alpha, there are currently only about a dozen builder functions. However, these few basic functions are enough for constructing simple expressions in the Fortran AST. As an example, if we wanted to construct the expression represented by &lt;code&gt;c = a + b&lt;/code&gt;, where each variable involved is an integer, we could do something like:&lt;/p&gt;
&lt;div class="sourceCode" id="cb1"&gt;&lt;pre class="sourceCode python"&gt;&lt;code class="sourceCode python"&gt;&lt;a class="sourceLine" id="cb1-1" title="1"&gt;&lt;span class="op"&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class="im"&gt;import&lt;/span&gt; lfortran.asr.builder &lt;span class="im"&gt;as&lt;/span&gt; builder&lt;/a&gt;
&lt;a class="sourceLine" id="cb1-2" title="2"&gt;&lt;span class="op"&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class="im"&gt;import&lt;/span&gt; lfortran.asr.asr &lt;span class="im"&gt;as&lt;/span&gt; asr&lt;/a&gt;
&lt;a class="sourceLine" id="cb1-3" title="3"&gt;&lt;span class="op"&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt; integer &lt;span class="op"&gt;=&lt;/span&gt; builder.make_type_integer()&lt;/a&gt;
&lt;a class="sourceLine" id="cb1-4" title="4"&gt;&lt;span class="op"&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt; a &lt;span class="op"&gt;=&lt;/span&gt; asr.Variable(name&lt;span class="op"&gt;=&lt;/span&gt;&lt;span class="st"&gt;&amp;quot;a&amp;quot;&lt;/span&gt;, &lt;span class="bu"&gt;type&lt;/span&gt;&lt;span class="op"&gt;=&lt;/span&gt;integer)&lt;/a&gt;
&lt;a class="sourceLine" id="cb1-5" title="5"&gt;&lt;span class="op"&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt; b &lt;span class="op"&gt;=&lt;/span&gt; asr.Variable(name&lt;span class="op"&gt;=&lt;/span&gt;&lt;span class="st"&gt;&amp;quot;b&amp;quot;&lt;/span&gt;, &lt;span class="bu"&gt;type&lt;/span&gt;&lt;span class="op"&gt;=&lt;/span&gt;integer)&lt;/a&gt;
&lt;a class="sourceLine" id="cb1-6" title="6"&gt;&lt;span class="op"&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt; c &lt;span class="op"&gt;=&lt;/span&gt; asr.Variable(name&lt;span class="op"&gt;=&lt;/span&gt;&lt;span class="st"&gt;&amp;quot;c&amp;quot;&lt;/span&gt;, &lt;span class="bu"&gt;type&lt;/span&gt;&lt;span class="op"&gt;=&lt;/span&gt;integer)&lt;/a&gt;
&lt;a class="sourceLine" id="cb1-7" title="7"&gt;&lt;span class="op"&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class="bu"&gt;sum&lt;/span&gt; &lt;span class="op"&gt;=&lt;/span&gt; builder.make_binop(a, asr.Add(), b)&lt;/a&gt;
&lt;a class="sourceLine" id="cb1-8" title="8"&gt;&lt;span class="op"&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt; expr &lt;span class="op"&gt;=&lt;/span&gt; asr.Assignment(c, &lt;span class="bu"&gt;sum&lt;/span&gt;)&lt;/a&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;LFortran also provides functionality to visualize what the expression tree looks like:&lt;/p&gt;

&lt;div class="sourceCode"&gt;
&lt;pre class="sourceCode python"&gt;&lt;code class="sourceCode python"&gt;&lt;span class="op"&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class="im"&gt;import&lt;/span&gt; lfortran.asr.pprint &lt;span class="im"&gt;as&lt;/span&gt; pprint
&lt;span class="op"&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt; pprint.pprint_asr(expr)
&lt;span class="kw"&gt;stmt.Assignment&lt;/span&gt;
&amp;#9500;&amp;#9472;target&lt;span class="op"&gt;=&lt;/span&gt;c
&amp;#9584;&amp;#9472;value&lt;span class="op"&gt;=&lt;/span&gt;&lt;span class="kw"&gt;expr.BinOp&lt;/span&gt;
  &amp;#9500;&amp;#9472;left&lt;span class="op"&gt;=&lt;/span&gt;a
  &amp;#9500;&amp;#9472;op&lt;span class="op"&gt;=&lt;/span&gt;&lt;span class="kw"&gt;operator.Add&lt;/span&gt;
  &amp;#9500;&amp;#9472;right&lt;span class="op"&gt;=&lt;/span&gt;b
  &amp;#9584;&amp;#9472;type&lt;span class="op"&gt;=&lt;/span&gt;&lt;span class="kw"&gt;ttype.Integer&lt;/span&gt;
    &amp;#9500;&amp;#9472;kind&lt;span class="op"&gt;=&lt;/span&gt;&lt;span class="dv"&gt;4&lt;/span&gt;
    &amp;#9584;&amp;#9472;dims&lt;span class="op"&gt;=&lt;/span&gt;[]&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;h2 id="sympy-to-lfortran-converter"&gt;Sympy to LFortran Converter&lt;/h2&gt;
&lt;p&gt;I&amp;#8217;ve started with the implementation of a basic SymPy to LFortran converter utilizing the AST builder described above, with the current &lt;a href="https://github.com/sympy/sympy/pull/16931"&gt;pull request&lt;/a&gt; available on the SymPy GitHub. The converter follows the same node visitor class structure as all of the other code printers (it even inherits the &lt;code&gt;CodePrinter&lt;/code&gt; class, despite the methods not producing strings but rather AST nodes). Here&amp;#8217;s a simple example that demonstrates the conversion of a simple expression to an equivalent in LFortran:&lt;/p&gt;
&lt;div class="sourceCode" id="cb2"&gt;&lt;pre class="sourceCode python"&gt;&lt;code class="sourceCode python"&gt;&lt;a class="sourceLine" id="cb2-1" title="1"&gt;&lt;span class="op"&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class="im"&gt;from&lt;/span&gt; sympy.abc &lt;span class="im"&gt;import&lt;/span&gt; x&lt;/a&gt;
&lt;a class="sourceLine" id="cb2-2" title="2"&gt;&lt;span class="op"&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class="im"&gt;from&lt;/span&gt; sympy.codegen.lfort &lt;span class="im"&gt;import&lt;/span&gt; sympy_to_lfortran&lt;/a&gt;
&lt;a class="sourceLine" id="cb2-3" title="3"&gt;&lt;span class="op"&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class="im"&gt;import&lt;/span&gt; lfortran&lt;/a&gt;
&lt;a class="sourceLine" id="cb2-4" title="4"&gt;&lt;span class="op"&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt; e &lt;span class="op"&gt;=&lt;/span&gt; x &lt;span class="op"&gt;+&lt;/span&gt; &lt;span class="dv"&gt;1&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb2-5" title="5"&gt;&lt;span class="op"&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt; e_converted &lt;span class="op"&gt;=&lt;/span&gt; sympy_to_lfortran(e)&lt;/a&gt;
&lt;a class="sourceLine" id="cb2-6" title="6"&gt;&lt;span class="op"&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt; lfortran.ast_to_src(lfortran.asr_to_ast(e_converted)).replace(&lt;span class="st"&gt;'&lt;/span&gt;&lt;span class="ch"&gt;\n&lt;/span&gt;&lt;span class="st"&gt;'&lt;/span&gt;, &lt;span class="st"&gt;''&lt;/span&gt;)&lt;/a&gt;
&lt;a class="sourceLine" id="cb2-7" title="7"&gt;&lt;span class="co"&gt;'(x) + (1)'&lt;/span&gt;&lt;/a&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;There are two things to notice here. The first is that I had to replace all the newlines in the generated expression, since a &lt;a href="https://gitlab.com/lfortran/lfortran/issues/110"&gt;bug in LFortran&lt;/a&gt; causes too many newlines to be printed. The second is that there are a number of redundant parentheses in the printed expression. While this isn&amp;#8217;t an outright bug, it&amp;#8217;s another aspect of LFortran that is currently being improved upon.&lt;/p&gt;
&lt;p&gt;I&amp;#8217;ve also add another function, &lt;code&gt;sympy_to_lfortran_wrapped&lt;/code&gt;, which wraps an expression in a function definition, (poorly) emulating the wrapping part of &lt;a href="https://docs.sympy.org/latest/modules/utilities/autowrap.html"&gt;&lt;code&gt;autowrap&lt;/code&gt;&lt;/a&gt;:&lt;/p&gt;
&lt;div class="sourceCode"&gt;
&lt;pre class="sourceCode python"&gt;&lt;code class="sourceCode python"&gt;&lt;span class="op"&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class="im"&gt;from&lt;/span&gt; sympy.codegen.lfort &lt;span class="im"&gt;import&lt;/span&gt; sympy_to_lfortran_wrapped
&lt;span class="op"&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt; e_wrapped &lt;span class="op"&gt;=&lt;/span&gt; sympy_to_lfortran_wrapped(e)
&lt;span class="op"&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class="bu"&gt;print&lt;/span&gt;(lfortran.ast_to_src(lfortran.asr_to_ast(e_wrapped)))
&lt;span class="st"&gt;integer function f(x) result(ret)
integer, intent(in) :: x
ret = 1 + x
end function&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;Since LFortran can directly compile the AST to an LLVM intermediate representation, a future implementation of &lt;code&gt;autowrap&lt;/code&gt; might be implemented by compiling the output of this function (instead of first completely generating the code and then feeding it to &lt;code&gt;gfortran&lt;/code&gt; as it&amp;#8217;s done right now).&lt;/p&gt;
&lt;h2 id="next-steps"&gt;Next Steps&lt;/h2&gt;
&lt;p&gt;For the next couple of days, I will try to extend the types of SymPy expressions that may be converted. One thing to note is that there isn&amp;#8217;t a perfect correspondence between SymPy and LFortran AST nodes. LFortran supports nodes for operations like unary subtraction and division, which SymPy converts into multiplication and division respectively. On top of this, I&amp;#8217;ll also add some tests for the functionality that I have implemented so far. After that, I&amp;#8217;ll start with work on SymPy&amp;#8217;s matrix expression code generation (the second part of my GSoC project) and pick LFortran up again close to the end of the summer.&lt;/p&gt;
    &lt;/section&gt;
&lt;/article&gt;</description>
    </item>
    <item>
      <guid isPermaLink="false">https://sc0rpi0n101.github.io/2019/05/week-1-let-the-grind-begin/</guid>
      <author>Nikhil Maan (Sc0rpi0n101)</author>
      <title>Nikhil Maan (Sc0rpi0n101): Week 1: Let the Grind Begin</title>
      <pubDate>Fri, 31 May 2019 00:00:00 GMT</pubDate>
      <link>https://sc0rpi0n101.github.io/2019/05/week-1-let-the-grind-begin/</link>
      <description>&lt;p&gt;Welcome everyone, I am your host Nikhil Maan aka Sc0rpi0n101 and I will be barraging you with blogs of my progress with my GSoC project. This is the blog for the first week of work. The official coding started May 27.
Today is May 31, it&amp;rsquo;s been 5 days of work and I&amp;rsquo;ve had some progress since Monday and had the meeting for the first week yesterday. The week has not been as productive as I would&amp;rsquo;ve liked to be but I managed to get in some work.</description>
    </item>
    <item>
      <guid isPermaLink="false">https://shubhamkjha.github.io/2019/05/29/Community-bonding-period</guid>
      <author>Shubham Kumar Jha (ShubhamKJha)</author>
      <title>Shubham Kumar Jha (ShubhamKJha): Community Bonding Period</title>
      <pubDate>Wed, 29 May 2019 00:00:00 GMT</pubDate>
      <link>https://shubhamkjha.github.io/2019/05/29/Community-bonding-period.html</link>
      <description>&lt;p&gt;Community bonding period has concluded. Due to my exams and travelling, I was not able to devote much of my time over this. But I managed to review PR &lt;a href="https://github.com/sympy/sympy/pull/16666"&gt;#16666&lt;/a&gt; and helped it get merged. With this PR, SymPy comes one step closer to unifying both the Assumption systems. Also, with this I realized how difficult reviewing can be &amp;#128517;.&lt;/p&gt;

&lt;p&gt;I had my first meeting with my mentors, Aaron and Kalevi, on Monday where we decided about the timings of weekly meetings. It was also decided to use &lt;code class="highlighter-rouge"&gt;gitter&lt;/code&gt; as a medium for these meetings. Aaron also gave me some directions about the overall project.&lt;/p&gt;

&lt;p&gt;Since the official coding period has begun, I will try to stick to my proposal. These are my plans for the coming week:&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;As per my proposal, I have to include First Order Logic into SymPy. There is already a PR on this ( &lt;a href="https://github.com/sympy/sympy/pull/7608"&gt;#7608&lt;/a&gt;). During this week I will work on to improve over it.&lt;/li&gt;
  &lt;li&gt;Also as suggested by Aaron, I will look into some known performance issues with assumptions.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Along with this, I will also be looking for inconsistencies between the two Assumptions systems.&lt;/p&gt;

&lt;p&gt;Sign out for the next week &amp;#128516;&lt;/p&gt;</description>
    </item>
    <item>
      <guid isPermaLink="false">https://czgdp1807.github.io/bonding-period</guid>
      <author>Gagandeep Singh (czgdp1807)</author>
      <title>Gagandeep Singh (czgdp1807): Community Bonding - A head start</title>
      <pubDate>Mon, 27 May 2019 00:00:00 GMT</pubDate>
      <link>https://czgdp1807.github.io/bonding-period/</link>
      <description>&lt;p&gt;So, here I am with another set of experiences to share with you, i.e., the Community Bonding of GSoC. After discussing with my fellow developers, and my mentors, we reframed our timeline. I will be working on very interesting topics in statistics, including, joint distributions, Markov chains, random matrices, assumptions of dependence and simplifying the results of the stats module. For a head start, I started working on adding multivariate distributions and the good news is that I have completed majority of the work, apart from some technical constraints which will be solved by another project very soon. If you are interested in seeing the code, take a look at the PRs #16576, #16808, #16825. Infact, apart from the stats module, I also had an opportunity to work on other modules of SymPy, like, I improved the API of Sum in sympy.concrete, allowing Range to be passed as limits and that too while working on discrete joint distributions. You can check the PR #16810 for the details. Thanks to Christopher Smith for helping me with this. Still there are issues like, #16833 which require a lot of discussion before concrete implementation, will update you on this if some progress takes place. Apart from coding, we had discussions on design of Markov chain and random matrices. I also made two prototypes at PR #16852, and #16866 . We are currently having more to think on this part, like API, class structure, etc. Overall, the bonding period was very a great learning experience about how various modules affect each other and bring the best out of SymPy. See you soon in the next blog. :)</description>
    </item>
    <item>
      <guid isPermaLink="false">https://arighnaiitg.github.io/2019-05-26-gsoc-end-of-community-bonding-period/</guid>
      <author>Arighna Chakrabarty (arighnaiitg)</author>
      <title>Arighna Chakrabarty (arighnaiitg): GSoC - Community Bonding Period Ends !!</title>
      <pubDate>Sun, 26 May 2019 07:00:00 GMT</pubDate>
      <link>https://arighnaiitg.github.io/2019-05-26-gsoc-end-of-community-bonding-period/</link>
      <description>&lt;p&gt;The Journey will begin now !! - 
          The all-important Community Bonding Period ends!! During these three weeks, I have come to learn a lot more things about SymPy, and especially its Series module, the module I would be improving this summer. The first week of the CBP was wasted since I had college exams going on, and...</description>
    </item>
  </channel>
</rss>
