<?xml version="1.0"?>
<rss version="2.0" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Planet SymPy</title>
    <link>http://planet.sympy.org/</link>
    <language>en</language>
    <description>Planet SymPy - http://planet.sympy.org/</description>
    <atom:link href="http://planet.sympy.org/rss10.xml" rel="self" type="application/rss+xml"/>
    <item>
      <guid isPermaLink="false">http://ishanaj.wordpress.com/?p=58</guid>
      <author>Ishan Joshi (ishanaj)</author>
      <title>Ishan Joshi (ishanaj): GSoC&#x2019;19: Week-7- Starting with the phase-III draw() function</title>
      <pubDate>Mon, 15 Jul 2019 03:02:10 GMT</pubDate>
      <link>https://ishanaj.wordpress.com/2019/07/15/gsoc19-week-7-starting-with-the-phase-iii-draw-function/</link>
      <description>&lt;p&gt;The week was successfully completed as planned. The work on &lt;a href="https://github.com/sympy/sympy/pull/17122"&gt;Column class&lt;/a&gt; has been completed.&lt;/p&gt;
&lt;p&gt;The documentation and tests have been written and with some changes in the &lt;strong&gt;solve_slope_deflection()&lt;/strong&gt; and &lt;strong&gt;critical_load(),&lt;/strong&gt; the &lt;strong&gt;Column&lt;/strong&gt; class is now able to handle cases with trivial solutions of the constants ( C1 &amp;amp; C2) which made the deflection equation zero.&lt;/p&gt;
&lt;p&gt;Apart from this, another problem that we had with the &lt;strong&gt;pinned-fixed&lt;/strong&gt; end condition, where &lt;strong&gt;solve()&lt;/strong&gt; wasn&amp;#8217;t giving the output in the required form, has temporary been handled by making an &lt;strong&gt;XFAIL &lt;/strong&gt;test against it. We can work on it later. Either there has to be some changes in &lt;strong&gt;solve()&lt;/strong&gt;&amp;#160;so that we would be able to handle our case or we might have to figure out a way to rewrite it into the desired form.&lt;/p&gt;
&lt;p&gt;With the end of this week,&amp;#160;&lt;a href="https://github.com/sympy/sympy/pull/17122"&gt;PR #17122&lt;/a&gt; and &lt;a href="https://github.com/sympy/sympy/pull/17153"&gt;PR #17153&lt;/a&gt; are complete and ready for review. I have made some changes addressing some of the reviews, and we can have further discussions on it.&lt;/p&gt;
&lt;p&gt;Now, also moving on to the next phase, I have done a bit of research on it. I will most probably open a discussion to have an initial discussion regarding how work will progress in this stage. This phase is regarding plotting the beam diagrams using &lt;a href="https://matplotlib.org/"&gt;matplotlib&lt;/a&gt;. I have also considered &lt;strong&gt;pyglet&lt;/strong&gt; plotting module of SymPy, which according to the &lt;a href="https://docs.sympy.org/latest/modules/plotting.html#plotting-geometric-entities"&gt;documentation&lt;/a&gt; is capable of plotting geometries, but there has been some problems in this module and it doesn&amp;#8217;t seem to be working well. I had earlier made an &lt;a href="https://github.com/sympy/sympy/issues/16537"&gt;issue #16537&lt;/a&gt; regarding the same, but there seems to be no improvement here.&lt;/p&gt;
&lt;p&gt;So, we will be discussing the rest in an issue-cum-discussion, in the upcoming week.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Next week:&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Working on the Stage-III&lt;/li&gt;
&lt;li&gt;Simultaneously, discussing the leftover PR&amp;#8217;s and trying to finish them and make a merge.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Most probably, on successful discussion and planning, I will be opening a draft work-in-progress PR for the &lt;strong&gt;draw()&lt;/strong&gt; function in stage &amp;#8211;III.&lt;/p&gt;
&lt;p&gt;Will keep you updated!&lt;/p&gt;
&lt;p&gt;Thanks!&lt;/p&gt;</description>
    </item>
    <item>
      <guid isPermaLink="false">https://czgdp1807.github.io/week_7</guid>
      <author>Gagandeep Singh (czgdp1807)</author>
      <title>Gagandeep Singh (czgdp1807): Week 7 - All about logics and algorithms</title>
      <pubDate>Mon, 15 Jul 2019 00:00:00 GMT</pubDate>
      <link>https://czgdp1807.github.io/week_7/</link>
      <description>&lt;p&gt;This week required a lot of thinking before jumping to code the stuff. Interested? Okay move on to next paragraph.&lt;/p&gt;

&lt;p&gt;Basically, I worked on three PRs, &lt;a href="https://github.com/sympy/sympy/pull/17163"&gt;#17163&lt;/a&gt; for continuous time Markov chains, &lt;a href="https://github.com/sympy/sympy/pull/17174"&gt;#17174&lt;/a&gt; for random matrices and &lt;a href="https://github.com/sympy/sympy/pull/17146"&gt;#17146&lt;/a&gt; for symbolic Ranges. The first and the last PRs are very much intensive. I developed a new algorithm for the query handler of &lt;code class="highlighter-rouge"&gt;ContinuousMarkovChain.probability&lt;/code&gt; method, because the previous one which I implemented in &lt;code class="highlighter-rouge"&gt;DiscreteMarkovChain.probability&lt;/code&gt;, was not easy to maintain, quite ad-hoc, rigid and difficult to extend. The philosophy behind the algorithm is recursion i.e., boil everything down to &lt;code class="highlighter-rouge"&gt;Relational&lt;/code&gt; query, convert them to sets and then calculate the probability. You can find the complete description &lt;a href="https://github.com/sympy/sympy/pull/17163#issuecomment-510939984"&gt;here&lt;/a&gt;. I am waiting for any critical objections from my mentors and after that I will refactor the code as suggested by &lt;a href="https://github.com/oscarbenjamin"&gt;oscarbenjamin&lt;/a&gt; and &lt;a href="https://github.com/jksuom"&gt;jksuom&lt;/a&gt;. So, now let&amp;#8217;s move on to random matrices. As it was to be implemented from scratch, it required a bit of thinking to reach a decent architecture. Currently, the PR is at a basic level, and some more testing is to be done. Now, coming on to symbolic &lt;code class="highlighter-rouge"&gt;Range&lt;/code&gt;. Let me tell you, it requires a lot of logical thinking to make &lt;code class="highlighter-rouge"&gt;Range&lt;/code&gt; accept symbolic parameters. A lot of tests fail, and a lot of debugging has to be done to make a method work. In fact, we might deprecate &lt;code class="highlighter-rouge"&gt;xrange&lt;/code&gt; support from &lt;code class="highlighter-rouge"&gt;Range&lt;/code&gt; because we are going to drop &lt;code class="highlighter-rouge"&gt;Python 2&lt;/code&gt; support from &lt;code class="highlighter-rouge"&gt;SymPy&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;This week I learnt to combine the concepts from algorithms and software engineering to develop the stuff I mentioned above. This was the best week of my overall GSoC experience till now.&lt;/p&gt;

&lt;p&gt;A lot more lies ahead. Bye!!&lt;/p&gt;</description>
    </item>
    <item>
      <guid isPermaLink="false">https://divyanshu132.github.io//gsoc-week-7</guid>
      <author>Divyanshu Thakur (divyanshu132)</author>
      <title>Divyanshu Thakur (divyanshu132): GSoC 2019 - Week 7 - Modify Presentation and Addition of Methods</title>
      <pubDate>Mon, 15 Jul 2019 00:00:00 GMT</pubDate>
      <link>https://divyanshu132.github.io//gsoc-week-7</link>
      <description>&lt;p&gt;The seventh week of coding period has ended and a few methods has been introduced to polycyclic groups, also pc presentation has been modified. Previously for pc presentation we were computing the LHS for both power and conjugate relators via separate methods and then finally their RHS was computed.&lt;/p&gt;

&lt;p&gt;Now, the computation of presentation starts from the bottom of the polycyclic generating sequence(pcgs) and polycyclic series. Storing all the previous generators from pcgs and then taking the last generator as the generator which acts as a conjugator and conjugates all the previous generators in the list.&lt;/p&gt;

&lt;p&gt;To get a clear picture let&amp;#8217;s take an example of &lt;code class="highlighter-rouge"&gt;S(4)&lt;/code&gt;
For S(4) we&amp;#8217;ll have 4 generators in pcgs say &lt;code class="highlighter-rouge"&gt;[x0, x1, x2, x3]&lt;/code&gt; and the &lt;code class="highlighter-rouge"&gt;relative_order vector as [2, 3, 2, 2]&lt;/code&gt;. Starting from bottom of this sequence the presentation is computed in order as below.&lt;/p&gt;

&lt;div class="highlighter-rouge"&gt;&lt;div class="highlight"&gt;&lt;pre class="highlight"&gt;&lt;code&gt;x3**2	       	---| ---&amp;gt; using only [x3] from pcgs and pc_series[1]
x2**2		   |
x2**-1*x3*x2	---| from bottom up because pc_series[0] is an identity.

x1**3		---| ---&amp;gt; using [x3, x2] from pcgs and pc_series[2]	
x1**-1*x3*x1	   | 
x1**-1*x2*x1	---|      from bottom up(which have both the gens).

x0**2		---| ---&amp;gt; using [x3, x2, x1] from pcgs and pc_series[3]
x0**-1*x3*x0	   |
x0**-1*x2*x0	   |      from bottom up(which have all three gens).
x0**-1*x1*x0	---|

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;There were 3-methods which were added namely:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Exponent vector&lt;/li&gt;
  &lt;li&gt;Depth&lt;/li&gt;
  &lt;li&gt;Leading Exponent&lt;/li&gt;
&lt;/ul&gt;

&lt;div class="highlighter-rouge"&gt;&lt;div class="highlight"&gt;&lt;pre class="highlight"&gt;&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; from sympy.combinatorics import *
&amp;gt;&amp;gt;&amp;gt; from sympy.combinatorics.free_groups import free_group
&amp;gt;&amp;gt;&amp;gt; G = SymmetricGroup(4)
&amp;gt;&amp;gt;&amp;gt; PcGroup = G.polycyclic_group()
&amp;gt;&amp;gt;&amp;gt; pcgs = PcGroup.pcgs
&amp;gt;&amp;gt;&amp;gt; group, x0, x1, x2, x3 = free_group("x0, x1, x2, x3")
&amp;gt;&amp;gt;&amp;gt; PcGroup.exponent_vector(G[0], group)
[1, 0, 0, 0]
&amp;gt;&amp;gt;&amp;gt; exp = PcGroup.exponent_vector(G[1], group)
&amp;gt;&amp;gt;&amp;gt; g = Permutation()
&amp;gt;&amp;gt;&amp;gt; for i in range(len(exp)):
...     g = g*pcgs[i] if exp[i] else g
... 
&amp;gt;&amp;gt;&amp;gt; g == G[1]
True
&amp;gt;&amp;gt;&amp;gt; 

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;For the details of these methods one can look into the docstrings and doctests of these methods in the PR &lt;a href="https://github.com/sympy/sympy/pull/16991"&gt;sympy/sympy#16991&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Tasks I hope to complete next week:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Get the polycyclic group pr ready to be merged.&lt;/li&gt;
  &lt;li&gt;Get started with quotient groups.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Till then good byee..&lt;/p&gt;</description>
    </item>
    <item>
      <guid isPermaLink="false">https://shubhamkjha.github.io/2019/07/15/GSoC-2019-Week-6-and-7</guid>
      <author>Shubham Kumar Jha (ShubhamKJha)</author>
      <title>Shubham Kumar Jha (ShubhamKJha): GSoC 2019: Week 6 and 7</title>
      <pubDate>Mon, 15 Jul 2019 00:00:00 GMT</pubDate>
      <link>https://shubhamkjha.github.io/2019/07/15/GSoC-2019-Week-6-and-7.html</link>
      <description>&lt;p&gt;With this ends the seventh week of the official coding period. During the end of 6th week and the beginning of 7th week, I was mostly travelling, so I was not able to write a blog for the sixth week. Instead, I will try to summarize my work during the last two weeks here.&lt;/p&gt;

&lt;p&gt;For the last few weeks, I have been focused on optimizing the code of new assumptions to enhance its performance. Most of my work has been exploratory, as Aaron says &amp;#128517;. Indeed I have dry-run, backtracked, profiled, and ran the same code with a debugger too many times to understand the slow parts and the improvements I can make here and there. Mostly the code is optimized given the class structure of SymPy. But it is also the class structure that is adding up to the performance issues. Already noted in my last blog, classes like &lt;code class="highlighter-rouge"&gt;And&lt;/code&gt; and &lt;code class="highlighter-rouge"&gt;Or&lt;/code&gt; sorts their &lt;em&gt;args&lt;/em&gt;, hence take a great amount of time. But other SymPy class constructors also take significant time.&lt;/p&gt;

&lt;p&gt;With the success of fifth week&amp;#8217;s attempt, I have been desperate to bring down the execution time &amp;#128517;. Some of the attempts I have made, which are included in &lt;a href="https://github.com/sympy/sympy/pull/17144"&gt;#17144&lt;/a&gt;, are:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;I have modified &lt;strong&gt;CNF&lt;/strong&gt; class, which essentially is a low-level implementation for the &lt;a href="https://en.wikipedia.org/wiki/Conjunctive_normal_form"&gt;cnf&lt;/a&gt; of any boolean expression. &lt;strong&gt;CNF&lt;/strong&gt; object holds a set of clauses. These clauses are themselves &lt;code class="highlighter-rouge"&gt;frozenset&lt;/code&gt; of &lt;strong&gt;Literal&lt;/strong&gt; objects. &lt;strong&gt;Literal&lt;/strong&gt; class is being implemented just to reduce the unnecessary creation of &lt;code class="highlighter-rouge"&gt;Not&lt;/code&gt; objects (It takes significant execution time and is called many times).&lt;/li&gt;
  &lt;li&gt;I have also modified the code of &lt;em&gt;sympify()&lt;/em&gt;, it appeared to take more time than expected when the argument is a SymPy object already. Consider this, almost one-third execution time.&lt;/li&gt;
&lt;/ul&gt;

&lt;div class="language-python highlighter-rouge"&gt;&lt;div class="highlight"&gt;&lt;pre class="highlight"&gt;&lt;code&gt;&lt;span class="n"&gt;In&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;]:&lt;/span&gt; &lt;span class="n"&gt;x&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;Symbol&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;'x'&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;

&lt;span class="n"&gt;In&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="p"&gt;]:&lt;/span&gt; &lt;span class="n"&gt;timeit&lt;/span&gt; &lt;span class="n"&gt;sympify&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="c"&gt;# before change&lt;/span&gt;
&lt;span class="mi"&gt;601&lt;/span&gt; &lt;span class="n"&gt;ns&lt;/span&gt; &lt;span class="err"&gt;&amp;#177;&lt;/span&gt; &lt;span class="mf"&gt;14.6&lt;/span&gt; &lt;span class="n"&gt;ns&lt;/span&gt; &lt;span class="n"&gt;per&lt;/span&gt; &lt;span class="n"&gt;loop&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;mean&lt;/span&gt; &lt;span class="err"&gt;&amp;#177;&lt;/span&gt; &lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt; &lt;span class="n"&gt;dev&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt; &lt;span class="n"&gt;of&lt;/span&gt; &lt;span class="mi"&gt;7&lt;/span&gt; &lt;span class="n"&gt;runs&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;1000000&lt;/span&gt; &lt;span class="n"&gt;loops&lt;/span&gt; &lt;span class="n"&gt;each&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;

&lt;span class="n"&gt;In&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="p"&gt;]:&lt;/span&gt; &lt;span class="n"&gt;timeit&lt;/span&gt; &lt;span class="n"&gt;sympify&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="c"&gt;# after change&lt;/span&gt;
&lt;span class="mi"&gt;239&lt;/span&gt; &lt;span class="n"&gt;ns&lt;/span&gt; &lt;span class="err"&gt;&amp;#177;&lt;/span&gt; &lt;span class="mf"&gt;11.8&lt;/span&gt; &lt;span class="n"&gt;ns&lt;/span&gt; &lt;span class="n"&gt;per&lt;/span&gt; &lt;span class="n"&gt;loop&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;mean&lt;/span&gt; &lt;span class="err"&gt;&amp;#177;&lt;/span&gt; &lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt; &lt;span class="n"&gt;dev&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt; &lt;span class="n"&gt;of&lt;/span&gt; &lt;span class="mi"&gt;7&lt;/span&gt; &lt;span class="n"&gt;runs&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;1000000&lt;/span&gt; &lt;span class="n"&gt;loops&lt;/span&gt; &lt;span class="n"&gt;each&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;Finally, I rewrote &lt;code class="highlighter-rouge"&gt;to_cnf()&lt;/code&gt; for &lt;strong&gt;CNF&lt;/strong&gt; objects. By using mostly Python&amp;#8217;s built-ins and removing any SymPy object construction during its execution. The performance gain is quite subtle &amp;#128526;.&lt;/li&gt;
&lt;/ul&gt;

&lt;div class="language-python highlighter-rouge"&gt;&lt;div class="highlight"&gt;&lt;pre class="highlight"&gt;&lt;code&gt;&lt;span class="n"&gt;In&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;]:&lt;/span&gt; &lt;span class="kn"&gt;from&lt;/span&gt; &lt;span class="nn"&gt;sympy&lt;/span&gt; &lt;span class="kn"&gt;import&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;

&lt;span class="n"&gt;In&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;]:&lt;/span&gt; &lt;span class="kn"&gt;from&lt;/span&gt; &lt;span class="nn"&gt;sympy.abc&lt;/span&gt; &lt;span class="kn"&gt;import&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="n"&gt;b&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="n"&gt;c&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="n"&gt;y&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="n"&gt;z&lt;/span&gt;

&lt;span class="n"&gt;In&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="p"&gt;]:&lt;/span&gt; &lt;span class="n"&gt;k&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;x&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&lt;/span&gt; &lt;span class="n"&gt;y&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&lt;/span&gt; &lt;span class="n"&gt;z&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;|&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&lt;/span&gt; &lt;span class="n"&gt;b&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&lt;/span&gt; &lt;span class="n"&gt;c&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;

&lt;span class="n"&gt;In&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;4&lt;/span&gt;&lt;span class="p"&gt;]:&lt;/span&gt; &lt;span class="kn"&gt;from&lt;/span&gt; &lt;span class="nn"&gt;sympy.logic.boolalg&lt;/span&gt; &lt;span class="kn"&gt;import&lt;/span&gt; &lt;span class="n"&gt;CNF&lt;/span&gt;

&lt;span class="c"&gt;# Before&lt;/span&gt;
&lt;span class="n"&gt;In&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;5&lt;/span&gt;&lt;span class="p"&gt;]:&lt;/span&gt; &lt;span class="n"&gt;timeit&lt;/span&gt; &lt;span class="n"&gt;CNF&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;from_prop&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;k&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="c"&gt;# It is using to_cnf()&lt;/span&gt;
&lt;span class="mf"&gt;1.41&lt;/span&gt; &lt;span class="n"&gt;ms&lt;/span&gt; &lt;span class="err"&gt;&amp;#177;&lt;/span&gt; &lt;span class="mi"&gt;18&lt;/span&gt; &lt;span class="err"&gt;&amp;#181;&lt;/span&gt;&lt;span class="n"&gt;s&lt;/span&gt; &lt;span class="n"&gt;per&lt;/span&gt; &lt;span class="n"&gt;loop&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;mean&lt;/span&gt; &lt;span class="err"&gt;&amp;#177;&lt;/span&gt; &lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt; &lt;span class="n"&gt;dev&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt; &lt;span class="n"&gt;of&lt;/span&gt; &lt;span class="mi"&gt;7&lt;/span&gt; &lt;span class="n"&gt;runs&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;1000&lt;/span&gt; &lt;span class="n"&gt;loops&lt;/span&gt; &lt;span class="n"&gt;each&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;

&lt;span class="c"&gt;# after&lt;/span&gt;
&lt;span class="n"&gt;In&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;5&lt;/span&gt;&lt;span class="p"&gt;]:&lt;/span&gt; &lt;span class="n"&gt;timeit&lt;/span&gt; &lt;span class="n"&gt;CNF&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;from_prop&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;k&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="c"&gt;# It is using the new to_CNF()&lt;/span&gt;
&lt;span class="mf"&gt;31.5&lt;/span&gt; &lt;span class="err"&gt;&amp;#181;&lt;/span&gt;&lt;span class="n"&gt;s&lt;/span&gt; &lt;span class="err"&gt;&amp;#177;&lt;/span&gt; &lt;span class="mf"&gt;1.48&lt;/span&gt; &lt;span class="err"&gt;&amp;#181;&lt;/span&gt;&lt;span class="n"&gt;s&lt;/span&gt; &lt;span class="n"&gt;per&lt;/span&gt; &lt;span class="n"&gt;loop&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;mean&lt;/span&gt; &lt;span class="err"&gt;&amp;#177;&lt;/span&gt; &lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt; &lt;span class="n"&gt;dev&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt; &lt;span class="n"&gt;of&lt;/span&gt; &lt;span class="mi"&gt;7&lt;/span&gt; &lt;span class="n"&gt;runs&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;10000&lt;/span&gt; &lt;span class="n"&gt;loops&lt;/span&gt; &lt;span class="n"&gt;each&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;There is definitely a limit to performance we can get with Python. But implementing most of the things in Python built-ins we can definitely make things much faster.&lt;/p&gt;

&lt;p&gt;For the upcoming week, I will try to complete the following:&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;The CNF objects are still not simplified. I have to implement simplification to reduce the number of clauses. These have to be fed into &lt;code class="highlighter-rouge"&gt;satisfiable&lt;/code&gt; at the end, which can benefit from lesser number of clauses.&lt;/li&gt;
  &lt;li&gt;&lt;code class="highlighter-rouge"&gt;rcall&lt;/code&gt; used with &lt;strong&gt;sathandlers&lt;/strong&gt; is another major portion having high execution time. I will try to work it out.&lt;/li&gt;
  &lt;li&gt;Clean up the code and make it ready for reviewing.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Apart from that, I will also try to shift my focus towards the other part of my project and write some theory solvers. After all, I need to enhance the assumptions not just make it faster &amp;#128526;.&lt;/p&gt;

&lt;p&gt;&lt;em&gt;Peace&lt;/em&gt;&lt;/p&gt;</description>
    </item>
    <item>
      <guid isPermaLink="false">https://anpandey.github.io/posts/sympy/2019-07-14-week-7.html</guid>
      <author>Ankit Pandey (anpandey)</author>
      <title>Ankit Pandey (anpandey): Google Summer of Code Week 7: Matrix Wildcards</title>
      <pubDate>Sun, 14 Jul 2019 00:00:00 GMT</pubDate>
      <link>https://anpandey.github.io/posts/sympy/2019-07-14-week-7.html</link>
      <description>&lt;p&gt;I spent most of this week on extending wildcard support for matrix expressions, along with some more explorations in printing array contractions.&lt;/p&gt;
&lt;h3 id="matrices-and-wildcards"&gt;Matrices and Wildcards&lt;/h3&gt;
&lt;p&gt;As I&amp;#8217;ve probably mentioned in the last two blog posts, SymPy&amp;#8217;s support for matching matrix expressions through the &lt;code&gt;Wild&lt;/code&gt; class is currently severely limited (&lt;a href="https://github.com/sympy/sympy/issues/17172"&gt;when it works&lt;/a&gt;). While it is possible to construct a non-commutative &lt;code&gt;Wild&lt;/code&gt;, it isn&amp;#8217;t able to match expressions in a matrix multiplication:&lt;/p&gt;
&lt;div class="sourceCode" id="cb1"&gt;&lt;pre class="sourceCode python"&gt;&lt;code class="sourceCode python"&gt;&lt;a class="sourceLine" id="cb1-1" title="1"&gt;&lt;span class="op"&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt; W, X &lt;span class="op"&gt;=&lt;/span&gt; symbols(&lt;span class="st"&gt;'W, X'&lt;/span&gt;, cls&lt;span class="op"&gt;=&lt;/span&gt;Wild, commutative&lt;span class="op"&gt;=&lt;/span&gt;&lt;span class="va"&gt;False&lt;/span&gt;)&lt;/a&gt;
&lt;a class="sourceLine" id="cb1-2" title="2"&gt;&lt;span class="op"&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class="im"&gt;from&lt;/span&gt; sympy.abc &lt;span class="im"&gt;import&lt;/span&gt;  N&lt;/a&gt;
&lt;a class="sourceLine" id="cb1-3" title="3"&gt;&lt;span class="op"&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt; A, B &lt;span class="op"&gt;=&lt;/span&gt; MatrixSymbol(&lt;span class="st"&gt;'A'&lt;/span&gt;, N, N), MatrixSymbol(&lt;span class="st"&gt;'B'&lt;/span&gt;, N, N)&lt;/a&gt;
&lt;a class="sourceLine" id="cb1-4" title="4"&gt;&lt;span class="op"&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class="bu"&gt;type&lt;/span&gt;((A &lt;span class="op"&gt;*&lt;/span&gt; B).match(W &lt;span class="op"&gt;*&lt;/span&gt; X))&lt;/a&gt;
&lt;a class="sourceLine" id="cb1-5" title="5"&gt;&lt;span class="op"&gt;&amp;lt;&lt;/span&gt;&lt;span class="kw"&gt;class&lt;/span&gt; &lt;span class="st"&gt;'NoneType'&lt;/span&gt;&lt;span class="op"&gt;&amp;gt;&lt;/span&gt;&lt;/a&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;It&amp;#8217;s also currently not possible to combine matrices and wildcards in expressions, since wildcards don&amp;#8217;t have a defined shape and so may only function as scalars:&lt;/p&gt;
&lt;div class="sourceCode" id="cb2"&gt;&lt;pre class="sourceCode python"&gt;&lt;code class="sourceCode python"&gt;&lt;a class="sourceLine" id="cb2-1" title="1"&gt;&lt;span class="op"&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt; W &lt;span class="op"&gt;+&lt;/span&gt; A&lt;/a&gt;
&lt;a class="sourceLine" id="cb2-2" title="2"&gt;&lt;span class="pp"&gt;TypeError&lt;/span&gt;: Mix of Matrix &lt;span class="kw"&gt;and&lt;/span&gt; Scalar symbols&lt;/a&gt;
&lt;a class="sourceLine" id="cb2-3" title="3"&gt;&lt;span class="op"&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt; W &lt;span class="op"&gt;*&lt;/span&gt; A&lt;/a&gt;
&lt;a class="sourceLine" id="cb2-4" title="4"&gt;&lt;span class="pp"&gt;NotImplementedError&lt;/span&gt;: noncommutative scalars &lt;span class="kw"&gt;in&lt;/span&gt; MatMul are &lt;span class="kw"&gt;not&lt;/span&gt; supported.&lt;/a&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h3 id="matrixwild"&gt;&lt;code&gt;MatrixWild&lt;/code&gt;&lt;/h3&gt;
&lt;p&gt;I spent most of this week working on &lt;a href="https://github.com/sympy/sympy/pull/17177"&gt;#17177&lt;/a&gt;, which implements a &lt;code&gt;MatrixWild&lt;/code&gt; class that functions as both a wildcard and a matrix expression. In order to construct the wildcard, we need to give it a shape:&lt;/p&gt;
&lt;div class="sourceCode" id="cb3"&gt;&lt;pre class="sourceCode python"&gt;&lt;code class="sourceCode python"&gt;&lt;a class="sourceLine" id="cb3-1" title="1"&gt;&lt;span class="op"&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class="im"&gt;from&lt;/span&gt; sympy.abc &lt;span class="im"&gt;import&lt;/span&gt; N&lt;/a&gt;
&lt;a class="sourceLine" id="cb3-2" title="2"&gt;&lt;span class="op"&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class="im"&gt;from&lt;/span&gt; sympy.matrices.expressions.matexpr &lt;span class="im"&gt;import&lt;/span&gt; MatrixWild&lt;/a&gt;
&lt;a class="sourceLine" id="cb3-3" title="3"&gt;&lt;span class="op"&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt; W, X &lt;span class="op"&gt;=&lt;/span&gt; MatrixWild(&lt;span class="st"&gt;'W'&lt;/span&gt;, N, N), MatrixWild(&lt;span class="st"&gt;'X'&lt;/span&gt;, N, N)&lt;/a&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Unlike in the example above using &lt;code&gt;Wild&lt;/code&gt;, compound expressions are able to match against a matrix multiplication:&lt;/p&gt;
&lt;div class="sourceCode" id="cb4"&gt;&lt;pre class="sourceCode python"&gt;&lt;code class="sourceCode python"&gt;&lt;a class="sourceLine" id="cb4-1" title="1"&gt;&lt;span class="op"&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt; A, B &lt;span class="op"&gt;=&lt;/span&gt; MatrixSymbol(&lt;span class="st"&gt;'A'&lt;/span&gt;, N, N), MatrixSymbol(&lt;span class="st"&gt;'B'&lt;/span&gt;, N, N)&lt;/a&gt;
&lt;a class="sourceLine" id="cb4-2" title="2"&gt;&lt;span class="op"&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt; (A &lt;span class="op"&gt;*&lt;/span&gt; B).match(W &lt;span class="op"&gt;*&lt;/span&gt; X)&lt;/a&gt;
&lt;a class="sourceLine" id="cb4-3" title="3"&gt;{W_: A, X_: B}&lt;/a&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Note that in order for matrix wildcards to match, their shape must match with the target expression:&lt;/p&gt;
&lt;div class="sourceCode" id="cb5"&gt;&lt;pre class="sourceCode python"&gt;&lt;code class="sourceCode python"&gt;&lt;a class="sourceLine" id="cb5-1" title="1"&gt;&lt;span class="op"&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt; x &lt;span class="op"&gt;=&lt;/span&gt; MatrixSymbol(&lt;span class="st"&gt;'x'&lt;/span&gt;, N, &lt;span class="dv"&gt;1&lt;/span&gt;)&lt;/a&gt;
&lt;a class="sourceLine" id="cb5-2" title="2"&gt;&lt;span class="op"&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt; e &lt;span class="op"&gt;=&lt;/span&gt; A &lt;span class="op"&gt;*&lt;/span&gt; x&lt;/a&gt;
&lt;a class="sourceLine" id="cb5-3" title="3"&gt;&lt;span class="op"&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt; e.shape&lt;/a&gt;
&lt;a class="sourceLine" id="cb5-4" title="4"&gt;(N, &lt;span class="dv"&gt;1&lt;/span&gt;)&lt;/a&gt;
&lt;a class="sourceLine" id="cb5-5" title="5"&gt;&lt;span class="op"&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class="bu"&gt;type&lt;/span&gt;(e.match(W))&lt;/a&gt;
&lt;a class="sourceLine" id="cb5-6" title="6"&gt;&lt;span class="op"&gt;&amp;lt;&lt;/span&gt;&lt;span class="kw"&gt;class&lt;/span&gt; &lt;span class="st"&gt;'NoneType'&lt;/span&gt;&lt;span class="op"&gt;&amp;gt;&lt;/span&gt;&lt;/a&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;However, if we don&amp;#8217;t care about dimension, we can include another wildcard in the matrix wildcard&amp;#8217;s shape:&lt;/p&gt;
&lt;div class="sourceCode" id="cb6"&gt;&lt;pre class="sourceCode python"&gt;&lt;code class="sourceCode python"&gt;&lt;a class="sourceLine" id="cb6-1" title="1"&gt;&lt;span class="op"&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt; M &lt;span class="op"&gt;=&lt;/span&gt; MatrixSymbol(&lt;span class="st"&gt;'M'&lt;/span&gt;, &lt;span class="dv"&gt;3&lt;/span&gt;, &lt;span class="dv"&gt;3&lt;/span&gt;)&lt;/a&gt;
&lt;a class="sourceLine" id="cb6-2" title="2"&gt;&lt;span class="op"&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt; w &lt;span class="op"&gt;=&lt;/span&gt; Wild(&lt;span class="st"&gt;'w'&lt;/span&gt;)&lt;/a&gt;
&lt;a class="sourceLine" id="cb6-3" title="3"&gt;&lt;span class="op"&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt; Y &lt;span class="op"&gt;=&lt;/span&gt; MatrixWild(&lt;span class="st"&gt;'Y'&lt;/span&gt;, w, w)&lt;/a&gt;
&lt;a class="sourceLine" id="cb6-4" title="4"&gt;&lt;span class="op"&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt; M.match(Y)&lt;/a&gt;
&lt;a class="sourceLine" id="cb6-5" title="5"&gt;{w_: &lt;span class="dv"&gt;3&lt;/span&gt;, Y_: M}&lt;/a&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;While this is a good first step to the matching functionality I was looking for with &lt;code&gt;unify&lt;/code&gt; for rewriting matrix expressions, there is still quite a bit of functionality (and tests) to be implemented, along with an unknown number of bugs to fix.&lt;/p&gt;
&lt;h2 id="printing-indexed-bases"&gt;Printing Indexed Bases&lt;/h2&gt;
&lt;p&gt;I&amp;#8217;ve also been working on a small pull request to improve the functionality the printing &lt;code&gt;IndexedBases&lt;/code&gt; so that it instead uses intermediate values (represented through the new code generation classes) to accumulate the values of contractions. Currently, this does nothing but break existing compatibility (Fortran versions older than Fortran 95 don&amp;#8217;t support variable declarations in arbitrary locations, and the variable currently defaults to a 32-bit floating point number), though I think this is a good first step for supporting the printing of more complex contractions.&lt;/p&gt;
&lt;h2 id="next-steps"&gt;Next Steps&lt;/h2&gt;
&lt;p&gt;For this week, I plan to finish with the implementation of&lt;code&gt;MatrixWild&lt;/code&gt; (and hopefully get started with using it for rewriting matrix expressions), along with making some more progress on the indexed bases pull request.&lt;/p&gt;</description>
    </item>
    <item>
      <guid isPermaLink="false">https://sc0rpi0n101.github.io/2019/07/week-7a-little-step-towards-consistency/</guid>
      <author>Nikhil Maan (Sc0rpi0n101)</author>
      <title>Nikhil Maan (Sc0rpi0n101): Week 7:A Little Step Towards Consistency</title>
      <pubDate>Sat, 13 Jul 2019 00:00:00 GMT</pubDate>
      <link>https://sc0rpi0n101.github.io/2019/07/week-7a-little-step-towards-consistency/</link>
      <description>&lt;p&gt;&amp;#8220;It&amp;rsquo;s not what we do once in a while that shapes our lives. It&amp;rsquo;s what we do consistently.&amp;#8221;  &amp;#8213; Anthony Robbins
 Welcome everyone, this is your host Nikhil Maan aka Sc0rpi0n101 and this week I&amp;rsquo;ve tried to be more consistent with my schedule, work and communications with the Organization. I&amp;rsquo;ve taken a few small steps and plan to improve as I keep working.
 Consistency!? Merging the Pull Requests?</description>
    </item>
    <item>
      <guid isPermaLink="false">http://ishanaj.wordpress.com/?p=56</guid>
      <author>Ishan Joshi (ishanaj)</author>
      <title>Ishan Joshi (ishanaj): GSoC&#x2019;19: Week-6-Completing the Column class.</title>
      <pubDate>Mon, 08 Jul 2019 04:44:15 GMT</pubDate>
      <link>https://ishanaj.wordpress.com/2019/07/08/gsoc19-week-6-completing-the-column-class/</link>
      <description>&lt;p&gt;The sixth week has ended with a lot of work to be done ahead.&lt;/p&gt;
&lt;p&gt;Last week the work was majorly focused on the work in progress &lt;a href="https://github.com/sympy/sympy/pull/17122"&gt;PR #17122&lt;/a&gt;. I have included the critical load function which makes the Column class capable of determining the critical load. Some problems still came up in solving some equations. I have made an &lt;a href="https://github.com/sympy/sympy/issues/17162"&gt;issue&lt;/a&gt; related to those.&lt;/p&gt;
&lt;p&gt;An equation similar to &lt;strong&gt;tan(x) &amp;#8211; x&lt;/strong&gt; comes up while determining the critical load for the&amp;#160;&lt;strong&gt;pinned-fixed&lt;/strong&gt;&amp;#160;end-condition. SymPy&amp;#8217;s &lt;strong&gt;solve() &lt;/strong&gt;won&amp;#8217;t be able to solve such an equation, and as per the solution given in the &lt;a href="https://github.com/sympy/sympy/issues/17162"&gt;issue&lt;/a&gt;, I think that &lt;strong&gt;nsolve()&lt;/strong&gt; would surely help in this case. So I will be going ahead to solve it using the approximation returned by &lt;strong&gt;nsolve()&lt;/strong&gt; to handle this condition.&lt;/p&gt;
&lt;p&gt;Another problem that I faced was determining deflection and critical load for the&amp;#160;&lt;strong&gt;pinned-pinned&lt;/strong&gt;&amp;#160;end-condition. Here, the deflection comes out to be:&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;C1*sin(sqrt(P)*x/(sqrt(E)*sqrt(I)))&lt;/strong&gt; +&lt;strong&gt; C2*cos(sqrt(P)*x/(sqrt(E)*sqrt(I)))&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Now on solving it for constants &lt;strong&gt;C1&lt;/strong&gt; and &lt;strong&gt;C2, &lt;/strong&gt;using initial boundary conditions,&amp;#160;both come out to be &lt;strong&gt;0&lt;/strong&gt;, making the deflection &lt;strong&gt;zero&lt;/strong&gt;. This implies that no buckling occurs, which is not the case.&lt;/p&gt;
&lt;p&gt;Even when solving it manually, this situation occurs, we deal with it by putting &lt;strong&gt;C2 = 0 &lt;/strong&gt;and instead of putting &lt;strong&gt;C1 = 0,&lt;/strong&gt; we consider the &lt;strong&gt;sin &lt;/strong&gt;term equal to zero and then solve for &lt;strong&gt;P (critical load).&amp;#160;&lt;/strong&gt;So, I will be adding a few more lines of code to deal with this situation.&lt;/p&gt;
&lt;p&gt;Apart from working on this module, I have also opened another &lt;a href="https://github.com/sympy/sympy/pull/17153"&gt;PR #17153&lt;/a&gt; which implement methods&amp;#160;to determine &lt;strong&gt;section modulus&lt;/strong&gt; and &lt;strong&gt;polar modulus&lt;/strong&gt; of any polygon (more precisely a cross-section). Initially it was a draft PR, but now the work has been completed on it. Once I get the approval, I will also be adding the same for the Ellipses module. Also, if &lt;strong&gt;&lt;a href="https://github.com/sympy/sympy/pull/17001"&gt;cut_section()&lt;/a&gt; &lt;/strong&gt;gets successfully implemented I will be adding another method to determine the first moment.&lt;/p&gt;
&lt;p&gt;I am pretty sure the work on &lt;strong&gt;Column class&lt;/strong&gt; will be successfully completed before the end of the next week. Also, we will be heading towards the next stage which intends to plot beam diagrams using matplotlib. Till then we can have an initial discussion regarding the same.&lt;/p&gt;
&lt;h2&gt;&lt;strong&gt;Next Week:&lt;/strong&gt;&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;Improving the &lt;strong&gt;critical_load()&lt;/strong&gt; to handle the above problems&lt;/li&gt;
&lt;li&gt;Completing the Column class (documentation and tests)&lt;/li&gt;
&lt;li&gt;Starting with the next phase&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Will keep you updated!&lt;/p&gt;
&lt;p&gt;Thanks!&lt;/p&gt;</description>
    </item>
    <item>
      <guid isPermaLink="false">https://czgdp1807.github.io/week_6</guid>
      <author>Gagandeep Singh (czgdp1807)</author>
      <title>Gagandeep Singh (czgdp1807): Week 6 - Some extensions</title>
      <pubDate>Mon, 08 Jul 2019 00:00:00 GMT</pubDate>
      <link>https://czgdp1807.github.io/week_6/</link>
      <description>&lt;p&gt;This week was a mix of discussion on design and extending previous work. I also got to know about some new cool features of &lt;code class="highlighter-rouge"&gt;SymPy&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;According to the plan proposed in &lt;a href="https://czgdp1807.github.io/week_4/"&gt;Week 4&lt;/a&gt;, I have completed my work on &lt;code class="highlighter-rouge"&gt;DiscreteMarkovChain&lt;/code&gt; via &lt;a href="https://github.com/sympy/sympy/pull/17083"&gt;PR #17083&lt;/a&gt;. I used the &lt;code class="highlighter-rouge"&gt;as_set&lt;/code&gt; and &lt;code class="highlighter-rouge"&gt;as_relational&lt;/code&gt; methods which helped me to cover many miscellaneous cases and probably, now &lt;code class="highlighter-rouge"&gt;DiscreteMarkovChain&lt;/code&gt; is quite dynamic and can handle various generic &lt;code class="highlighter-rouge"&gt;probability&lt;/code&gt; and &lt;code class="highlighter-rouge"&gt;expectation&lt;/code&gt; queries. I have also started the &lt;a href="https://github.com/sympy/sympy/pull/17163"&gt;PR #17163&lt;/a&gt; for adding &lt;code class="highlighter-rouge"&gt;ContinuousMarkovChain&lt;/code&gt; and I am observing that it&amp;#8217;s a bit tricky to maintain both the performance and result quality while working on it. Now, moving on to symbolic &lt;code class="highlighter-rouge"&gt;Range&lt;/code&gt;,well, the work has been started in the &lt;a href="https://github.com/sympy/sympy/pull/17146"&gt;PR #17146&lt;/a&gt; and I have figured out one disparity between &lt;code class="highlighter-rouge"&gt;Range&lt;/code&gt; and python&amp;#8217;s &lt;code class="highlighter-rouge"&gt;range&lt;/code&gt;(details available at &lt;a href="https://github.com/sympy/sympy/pull/17146#discussion_r300162219"&gt;this thread&lt;/a&gt;). I will try to fix it by making minimal changes to the code. The tensorflow related &lt;a href="https://github.com/sympy/sympy/pull/17103"&gt;PR #17103&lt;/a&gt; which I started in the previous week is also almost complete and is waiting for &lt;code class="highlighter-rouge"&gt;Tensorflow 2.0&lt;/code&gt; release. I am also studying a bit about the architecture of the above framework to make changes to &lt;code class="highlighter-rouge"&gt;lambdify&lt;/code&gt;. Regarding random matrices, I believe that discussion has reached its final stages and I am waiting for the comments from Francesco for improvements at the issue &lt;a href="https://github.com/sympy/sympy/issues/17039"&gt;#17039&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Let me share with you about my discoveries and learnings in this week. Well, thanks to Francesco for telling me about, &lt;code class="highlighter-rouge"&gt;sympy.multipledispatch&lt;/code&gt;. It helps in implementing operator overloading like in C/C++. I liked it very much. I also read about continuous Markov chain and discovered about generator matrix, forward and backward equations. Adding one interesting fact, that Poisson process and continuous Markov chain are very closely related via generator matrices it will make the implementation of the former much easier :D.&lt;/p&gt;

&lt;p&gt;Leaving you for now, Bye!!&lt;/p&gt;</description>
    </item>
    <item>
      <guid isPermaLink="false">https://divyanshu132.github.io//gsoc-week-6</guid>
      <author>Divyanshu Thakur (divyanshu132)</author>
      <title>Divyanshu Thakur (divyanshu132): GSoC 2019 - Week 6 - Computation of Polycyclic presentation</title>
      <pubDate>Mon, 08 Jul 2019 00:00:00 GMT</pubDate>
      <link>https://divyanshu132.github.io//gsoc-week-6</link>
      <description>&lt;p&gt;The sixth week of coding period has ended and a good amount of work has been done on polycyclic groups. Polycyclic presentation, Polycyclic generating sequence(pcgs) and it&amp;#8217;s series is implemented which for sure need some improvement &lt;a href="https://github.com/sympy/sympy/pull/16991"&gt;sympy/sympy#16991&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;The polycyclic series is computed starting from the bottom of the derived series of a group by adding the missing generators in the subgroups, and collecting these missing generators provide us the polycyclic generating sequence.&lt;/p&gt;

&lt;p&gt;As we discussed last week &lt;a href="https://divyanshu132.github.io/gsoc-week-5"&gt;here&lt;/a&gt; that to compute conjugate relators of a polycyclic group we were missing the &lt;code class="highlighter-rouge"&gt;RHS&lt;/code&gt; term, which was of the form &lt;code class="highlighter-rouge"&gt;x[i]**-1*x[i+1]*x[i] == RHS&lt;/code&gt;. So, starting from the bottom of the polycyclic generating sequence forming the subgroup and finding all the generators of the RHS using &lt;code class="highlighter-rouge"&gt;generator_product&lt;/code&gt;, mapping these generators with the free group elements and forming a word, finally collect the above formed word which will give us the collected RHS.&lt;/p&gt;

&lt;p&gt;Below is an example to compute polycyclic presentation for S(9).sylow_subgroup(3)&lt;/p&gt;

&lt;div class="highlighter-rouge"&gt;&lt;div class="highlight"&gt;&lt;pre class="highlight"&gt;&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; from sympy.combinatorics import *
&amp;gt;&amp;gt;&amp;gt; from sympy.combinatorics.free_groups import free_group
&amp;gt;&amp;gt;&amp;gt; F, x0, x1, x2, x3 = free_group("x0, x1, x2, x3")
&amp;gt;&amp;gt;&amp;gt; S = SymmetricGroup(9)
&amp;gt;&amp;gt;&amp;gt; G = S.sylow_subgroup(3)
&amp;gt;&amp;gt;&amp;gt; pc_group = G.polycyclic_group()
&amp;gt;&amp;gt;&amp;gt; group = F
&amp;gt;&amp;gt;&amp;gt; pc_group.pc_presentation(group)
{x3**3: (), x2**3: (), x1**3: (), x0**3: (), x2**-1*x3*x2: x3, x1**-1*x3*x1: x3, x1**-1*x2*x1: x2, x0**-1*x3*x0: x2**2*x3**2, x0**-1*x2*x0: x3, x0**-1*x1*x0: x1*x3}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;One problem that we&amp;#8217;ve encountered is that the generators in pcgs may change for the same group on executing it several times which makes it difficult to test pc_presentation but, Kalevi advised me to initalize &lt;code class="highlighter-rouge"&gt;random.seed&lt;/code&gt; with some chosen value and then it will result in the same repeatable result, will try it by today!&lt;/p&gt;

&lt;p&gt;The tasks that I&amp;#8217;m hopping to accomplish next week are&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Add tests for plycyclic presentation and be sure that it works properly.&lt;/li&gt;
  &lt;li&gt;Include more functionalities to pc groups like &lt;code class="highlighter-rouge"&gt;exponent_vector&lt;/code&gt;, &lt;code class="highlighter-rouge"&gt;element_depth&lt;/code&gt;, &lt;code class="highlighter-rouge"&gt;leading_coefficient&lt;/code&gt;.&lt;/li&gt;
  &lt;li&gt;Add documentation for all the functions.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Till then, good byee..&lt;/p&gt;</description>
    </item>
    <item>
      <guid isPermaLink="false">https://arighnaiitg.github.io/2019-07-07-gsoc-week6/</guid>
      <author>Arighna Chakrabarty (arighnaiitg)</author>
      <title>Arighna Chakrabarty (arighnaiitg): GSoC Week 6 !!</title>
      <pubDate>Sun, 07 Jul 2019 07:00:00 GMT</pubDate>
      <link>https://arighnaiitg.github.io/2019-07-07-gsoc-week6/</link>
      <description>&lt;p&gt;Week 6 ends.. - 
          Phase 2 of the coding period is smoothly being traversed. I recently had a meeting with Sartaj on 4th of July, Thursday. Here were the minutes of the meeting, along with the deliverables completed over the week. The meeting commenced with the discussion that we need to wrap up the...</description>
    </item>
    <item>
      <guid isPermaLink="false">https://anpandey.github.io/posts/sympy/2019-07-07-week-6.html</guid>
      <author>Ankit Pandey (anpandey)</author>
      <title>Ankit Pandey (anpandey): Google Summer of Code Week 6: Unification and Tensors Continued</title>
      <pubDate>Sun, 07 Jul 2019 00:00:00 GMT</pubDate>
      <link>https://anpandey.github.io/posts/sympy/2019-07-07-week-6.html</link>
      <description>&lt;p&gt;&lt;em&gt;See the &lt;a href="https://anpandey.github.io/2019-06-28-week-5.html"&gt;previous post&lt;/a&gt; for Week 5&lt;/em&gt;.&lt;/p&gt;
&lt;p&gt;This week I&amp;#8217;ve made some progress on matching and tensors, though I haven&amp;#8217;t filed any pull requests.&lt;/p&gt;
&lt;h2 id="unification"&gt;Unification&lt;/h2&gt;
&lt;p&gt;I have a working implementation of rewriting non-commutative expressions using SymPy&amp;#8217;s unify. It works by generating a &lt;code&gt;ReplaceOptim&lt;/code&gt; object that applies the rewriting rules to any term it&amp;#8217;s called with. Here&amp;#8217;s how we specify the rewriting rules:&lt;/p&gt;
&lt;div class="sourceCode" id="cb1"&gt;&lt;pre class="sourceCode python"&gt;&lt;code class="sourceCode python"&gt;&lt;a class="sourceLine" id="cb1-1" title="1"&gt;&lt;span class="op"&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class="im"&gt;from&lt;/span&gt; sympy &lt;span class="im"&gt;import&lt;/span&gt; Symbol, MatrixSymbol&lt;/a&gt;
&lt;a class="sourceLine" id="cb1-2" title="2"&gt;&lt;span class="op"&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt; n &lt;span class="op"&gt;=&lt;/span&gt; Symbol(&lt;span class="st"&gt;'N_matcher'&lt;/span&gt;, integer&lt;span class="op"&gt;=&lt;/span&gt;&lt;span class="va"&gt;True&lt;/span&gt;)&lt;/a&gt;
&lt;a class="sourceLine" id="cb1-3" title="3"&gt;&lt;span class="op"&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt; X &lt;span class="op"&gt;=&lt;/span&gt; MatrixSymbol(&lt;span class="st"&gt;'X_matcher'&lt;/span&gt;, n, n)&lt;/a&gt;
&lt;a class="sourceLine" id="cb1-4" title="4"&gt;&lt;span class="op"&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt; Y &lt;span class="op"&gt;=&lt;/span&gt; MatrixSymbol(&lt;span class="st"&gt;'Y_matcher'&lt;/span&gt;, n, &lt;span class="dv"&gt;1&lt;/span&gt;)&lt;/a&gt;
&lt;a class="sourceLine" id="cb1-5" title="5"&gt;&lt;span class="op"&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt; variables &lt;span class="op"&gt;=&lt;/span&gt; [n, X, Y]&lt;/a&gt;
&lt;a class="sourceLine" id="cb1-6" title="6"&gt;&lt;span class="op"&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt; matcher &lt;span class="op"&gt;=&lt;/span&gt; X&lt;span class="op"&gt;**&lt;/span&gt;(&lt;span class="op"&gt;-&lt;/span&gt;&lt;span class="dv"&gt;1&lt;/span&gt;) &lt;span class="op"&gt;*&lt;/span&gt; Y&lt;/a&gt;
&lt;a class="sourceLine" id="cb1-7" title="7"&gt;&lt;span class="op"&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt; goal &lt;span class="op"&gt;=&lt;/span&gt; MatrixSolve(X, Y)&lt;/a&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Here, the combination of &lt;code&gt;matcher&lt;/code&gt; and &lt;code&gt;variables&lt;/code&gt; specifies that we&amp;#8217;re looking for any expression of the form &lt;span class="math inline"&gt;&lt;em&gt;X&lt;/em&gt;&lt;sup&gt;&amp;#8197;&amp;#8722;&amp;#8197;1&lt;/sup&gt;&lt;em&gt;Y&lt;/em&gt;&lt;/span&gt;, where both &lt;span class="math inline"&gt;&lt;em&gt;X&lt;/em&gt;&lt;/span&gt; and &lt;span class="math inline"&gt;&lt;em&gt;Y&lt;/em&gt;&lt;/span&gt; can be any compound matrix expression. The inclusion of &lt;code&gt;n&lt;/code&gt; in &lt;code&gt;variables&lt;/code&gt; imposes the additional restriction that the matrix expression matched by &lt;span class="math inline"&gt;&lt;em&gt;X&lt;/em&gt;&lt;/span&gt; must be square (i.e. &lt;span class="math inline"&gt;&lt;em&gt;n&lt;/em&gt;&amp;#8197;&amp;#215;&amp;#8197;&lt;em&gt;n&lt;/em&gt;&lt;/span&gt;) while the expression matched by &lt;span class="math inline"&gt;&lt;em&gt;Y&lt;/em&gt;&lt;/span&gt; must be a vector (i.e. &lt;span class="math inline"&gt;&lt;em&gt;n&lt;/em&gt;&amp;#8197;&amp;#215;&amp;#8197;1&lt;/span&gt;). &lt;code&gt;goal&lt;/code&gt; specifies what the matched expression should be replaced with, where &lt;code&gt;X&lt;/code&gt; and &lt;code&gt;Y&lt;/code&gt; serve as stand-ins for the matched terms.&lt;/p&gt;
&lt;p&gt;After specifying our goals, we can construct the object and apply the replacement to some expressions:&lt;/p&gt;
&lt;div class="sourceCode" id="cb2"&gt;&lt;pre class="sourceCode python"&gt;&lt;code class="sourceCode python"&gt;&lt;a class="sourceLine" id="cb2-1" title="1"&gt;&lt;span class="op"&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt; replacer &lt;span class="op"&gt;=&lt;/span&gt; gen_replacement_operator(matcher, goal, variables)&lt;/a&gt;
&lt;a class="sourceLine" id="cb2-2" title="2"&gt;&lt;span class="op"&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt; A, B, x &lt;span class="op"&gt;=&lt;/span&gt; MatrixSymbol(&lt;span class="st"&gt;'A'&lt;/span&gt;, &lt;span class="dv"&gt;3&lt;/span&gt;, &lt;span class="dv"&gt;3&lt;/span&gt;), MatrixSymbol(&lt;span class="st"&gt;'B'&lt;/span&gt;, &lt;span class="dv"&gt;3&lt;/span&gt;, &lt;span class="dv"&gt;3&lt;/span&gt;), MatrixSymbol(&lt;span class="st"&gt;'x'&lt;/span&gt;, &lt;span class="dv"&gt;3&lt;/span&gt;, &lt;span class="dv"&gt;1&lt;/span&gt;)&lt;/a&gt;
&lt;a class="sourceLine" id="cb2-3" title="3"&gt;&lt;span class="op"&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt; replacer(A &lt;span class="op"&gt;**&lt;/span&gt; (&lt;span class="op"&gt;-&lt;/span&gt;&lt;span class="dv"&gt;1&lt;/span&gt;) &lt;span class="op"&gt;*&lt;/span&gt; x)&lt;/a&gt;
&lt;a class="sourceLine" id="cb2-4" title="4"&gt;(MatrixSolve(A, vector&lt;span class="op"&gt;=&lt;/span&gt;x))&lt;/a&gt;
&lt;a class="sourceLine" id="cb2-5" title="5"&gt;&lt;span class="op"&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt; replacer(A &lt;span class="op"&gt;**&lt;/span&gt; (&lt;span class="op"&gt;-&lt;/span&gt;&lt;span class="dv"&gt;1&lt;/span&gt;) &lt;span class="op"&gt;*&lt;/span&gt; B)&lt;/a&gt;
&lt;a class="sourceLine" id="cb2-6" title="6"&gt;A &lt;span class="op"&gt;**&lt;/span&gt; (&lt;span class="op"&gt;-&lt;/span&gt;&lt;span class="dv"&gt;1&lt;/span&gt;) &lt;span class="op"&gt;*&lt;/span&gt; B&lt;/a&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;The first term was replaced since the dimensions of &lt;code&gt;A&lt;/code&gt; and &lt;code&gt;x&lt;/code&gt; agreed with what was specified in matcher, while the second expression was left untouched since &lt;code&gt;B&lt;/code&gt; is not a vector.&lt;/p&gt;
&lt;p&gt;While the matcher does work, I haven&amp;#8217;t filed a pull request because of some problems which don&amp;#8217;t seem like they could be easily addressed:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;I had to give add the suffix &lt;code&gt;_matcher&lt;/code&gt; to the variable names to avoid variable capture, since SymPy symbols are considered equal if they have the same name. &lt;code&gt;unify&lt;/code&gt; does not support &lt;code&gt;Dummy&lt;/code&gt; symbols as variables.&lt;/li&gt;
&lt;li&gt;Some compound expressions are not matched. I&amp;#8217;ve narrowed this down to the way the variables are being passed to &lt;code&gt;unify&lt;/code&gt;, since they need to be converted to symbols. It seems like this conversion sometimes causes expressions to no longer be unifiable.&lt;/li&gt;
&lt;li&gt;Unification doesn&amp;#8217;t seem to work for a mixture of commutative and non-commutative expressions. I&amp;#8217;m not sure if this is a problem with &lt;code&gt;unify&lt;/code&gt; itself or the way that I&amp;#8217;m using it, since the only test of &lt;code&gt;unify&lt;/code&gt; in the SymPy codebase involving matrix expressions is on matrix multiplication.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;As I mentioned in my last blog post, SymPy already supports this sort of pattern matching through &lt;code&gt;Wild&lt;/code&gt;, though it currently does not support expressions involving matrices. Before trying to address these issues, I think it would be worthwhile to look into extending the functionality of &lt;code&gt;Wild&lt;/code&gt; as an alternative.&lt;/p&gt;
&lt;h2 id="tensors"&gt;Tensors&lt;/h2&gt;
&lt;p&gt;I&amp;#8217;ve made some progress in low-level code generation of matrix expressions. I tried seeing if instances of classes in the &lt;code&gt;array_utils&lt;/code&gt; module could be converted to SymPy&amp;#8217;s AST representation before being passed off to the code generators. This doesn&amp;#8217;t seem possible at the moment, since the AST has a number of limitations (such as not supporting variables in &lt;code&gt;for&lt;/code&gt; loop ranges). The &lt;code&gt;IndexedBase&lt;/code&gt; printer already has some of the functionality that I&amp;#8217;m trying to implement, so I&amp;#8217;ve settled on extending the printer to support arbitrary contractions. This same functionality can probably be reused for the &lt;code&gt;array_utils&lt;/code&gt; printers. The implementation will hopefully be straightforward.&lt;/p&gt;
&lt;h2 id="next-steps"&gt;Next steps&lt;/h2&gt;
&lt;p&gt;My goal for this week is to have a pull request for the tensor code generation ready, along with a plan for what to do with matching.&lt;/p&gt;</description>
    </item>
    <item>
      <guid isPermaLink="false">https://jmig5776.github.io//gsoc-week-6</guid>
      <author>Jogi Miglani (jmig5776)</author>
      <title>Jogi Miglani (jmig5776): GSoC 2019 - Week 6</title>
      <pubDate>Sun, 07 Jul 2019 00:00:00 GMT</pubDate>
      <link>https://jmig5776.github.io//gsoc-week-6</link>
      <description>&lt;p&gt;This was the sixth week meeting with the GSoC mentors which was scheduled on
Sunday 7th July, 2019 between 1:45 - 2:45 PM (IST). Me, Yathartha and Amit
were the attendees of the meeting. This meeting was short.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Discussing previous week&amp;#8217;s progress&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;In this meeting both the mentors were convinced by the code for Lambert&amp;#8217;s.
And few modifications in documentation and code clean up were suggested by them.
In this week the whole idea of power_list was droppped because @smichr suggested
code for replacing the symbol more targetted as we wanted by which the whole code
was improved. And it was decided to work upon on &lt;code class="highlighter-rouge"&gt;_solve_modular&lt;/code&gt; mainly now
onwards.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;Next week goals&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Getting merge existing PR for Lambert&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Work upon &lt;code class="highlighter-rouge"&gt;_solve_modular&lt;/code&gt; PR&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;If time left then find plan for Imageset Union.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Code improvement takes time!!&lt;/p&gt;</description>
    </item>
    <item>
      <guid isPermaLink="false">https://sc0rpi0n101.github.io/2019/07/week-6-the-most-chaotic-week-ever/</guid>
      <author>Nikhil Maan (Sc0rpi0n101)</author>
      <title>Nikhil Maan (Sc0rpi0n101): Week 6: The Most Chaotic Week Ever!!</title>
      <pubDate>Sat, 06 Jul 2019 00:00:00 GMT</pubDate>
      <link>https://sc0rpi0n101.github.io/2019/07/week-6-the-most-chaotic-week-ever/</link>
      <description>&lt;p&gt;&amp;#8220;A language that doesn&amp;rsquo;t affect the way you think about programming is not worth knowing.&amp;#8221;  &amp;#8213; Alan J. Perlis
 Welcome everyone, this is your host Nikhil Maan aka Sc0rpi0n101 and this week was one of the most chaotic weeks till now if not the most chaotic. I had to move places as the Uni opens next week, had the summer classes exams and had to convert the C parser to use SymPy&amp;rsquo;s Codegen AST from Python AST all in one week.</description>
    </item>
    <item>
      <guid isPermaLink="false">https://shubhamkjha.github.io/2019/07/03/GSoC-2019-Week-5</guid>
      <author>Shubham Kumar Jha (ShubhamKJha)</author>
      <title>Shubham Kumar Jha (ShubhamKJha): GSoC 2019: Week 5</title>
      <pubDate>Wed, 03 Jul 2019 00:00:00 GMT</pubDate>
      <link>https://shubhamkjha.github.io/2019/07/03/GSoC-2019-Week-5.html</link>
      <description>&lt;p&gt;With this the fifth week and the first phase of the official coding period has ended. I will try to give a brief summary of my work during this week.&lt;/p&gt;

&lt;p&gt;I spent most of this week learning the inner working of &lt;strong&gt;satask&lt;/strong&gt; module. It took a lot of debugging to understand the on-going processes efficiently &amp;#128517; . My major job was to reduce the unwanted slowing portions in the code. I had  &lt;a href="https://github.com/sympy/sympy/pull/11789"&gt;#11789&lt;/a&gt; for reference. Some of such performance reducing portions of code were:&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;A major segment of code was creating &lt;strong&gt;And&lt;/strong&gt; objects unnecessarily. As suggested in &lt;a href="https://github.com/sympy/sympy/issues/17087"&gt;#17087&lt;/a&gt; the sorting in the &lt;strong&gt;And&lt;/strong&gt; constructor takes up a significant amount of time. These have to be reduced.&lt;/li&gt;
  &lt;li&gt;Using SymPy objects is itself a bottleneck for performance. Having a system built over SymPy objects slows things down. Python&amp;#8217;s built-in types should be used as much as possible.&lt;/li&gt;
  &lt;li&gt;A specific segment (used many times in the code) calls &lt;code class="highlighter-rouge"&gt;rcall&lt;/code&gt; over propositions. The &lt;code class="highlighter-rouge"&gt;rcall&lt;/code&gt; which is a recursive process also takes a significant of time.&lt;/li&gt;
  &lt;li&gt;Also, I have tried to pre-compile results as much as possible.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;With the above and some other changes, the overall performance of &lt;code class="highlighter-rouge"&gt;satask&lt;/code&gt; has improved much. I have made a PR over this &lt;a href="https://github.com/sympy/sympy/pull/17144"&gt;#17144&lt;/a&gt;. For an instance,&lt;/p&gt;
&lt;table style="padding: 15px;"&gt;
    &lt;thead&gt;
        &lt;th&gt;Tests&lt;/th&gt;
        &lt;th&gt;After this PR&lt;/th&gt;
        &lt;th&gt;In master&lt;/th&gt;
    &lt;/thead&gt;
    &lt;tbody&gt;
        &lt;tr&gt;
            &lt;td&gt;test_satask&lt;/td&gt;
            &lt;td&gt;2.39 s&lt;/td&gt;
            &lt;td&gt;36.26 s&lt;/td&gt;
        &lt;/tr&gt;
        &lt;tr&gt;
            &lt;td&gt;assumptions/tests&lt;/td&gt;
            &lt;td&gt;16.74 s&lt;/td&gt;
            &lt;td&gt;127.21 s&lt;/td&gt;
        &lt;/tr&gt;
    &lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;&lt;br /&gt;
There is still scope for improvement in performance. In the coming week, I will try to work these out. I will also try to improve the performance of &lt;strong&gt;ask&lt;/strong&gt; module.&lt;/p&gt;

&lt;p&gt;Also, the first evaluations are over now and I feel happy to announce that I passed it. During the first phase I learnt a lot. In last few weeks I got to explore profiling and got to understand how small segments can influence performance. Before this I felt that I already know the codebase, but in reality I had much to explore. My mentors always gave me a good starting point and a direction over the course of this phase. With the hope to work much better in the coming phases, I take your leave now &amp;#128516; .&lt;/p&gt;</description>
    </item>
    <item>
      <guid isPermaLink="false">https://czgdp1807.github.io/week_5</guid>
      <author>Gagandeep Singh (czgdp1807)</author>
      <title>Gagandeep Singh (czgdp1807): Week 5 - Transition towards Phase 2</title>
      <pubDate>Tue, 02 Jul 2019 00:00:00 GMT</pubDate>
      <link>https://czgdp1807.github.io/week_5/</link>
      <description>&lt;p&gt;The evaluation results for phase 1 are out, and I am very glad to share with you that I have passed with flying colors. I received, &amp;#8220;Well done so far.&amp;#8221; as the feedback for my work till now.&lt;/p&gt;

&lt;p&gt;So now let us move to the work done in the gap between phase 1 and phase 2. Firstly, both of my open PRs of the previous phase, i.e., &lt;a href="https://github.com/sympy/sympy/pull/16962"&gt;#16962&lt;/a&gt; and &lt;a href="https://github.com/sympy/sympy/pull/16934"&gt;#16934&lt;/a&gt; have been merged. Though for symbolic dimensions some more work has to be done to make &lt;code class="highlighter-rouge"&gt;sympy.stats.frv&lt;/code&gt; more efficient and maintainable. I have also started my work, PR &lt;a href="https://github.com/sympy/sympy/pull/17083"&gt;#17083&lt;/a&gt;, to extend the scope of queries for &lt;code class="highlighter-rouge"&gt;DiscreteMarkovChain&lt;/code&gt; and the system has become a bit smarter. In fact, during this week, while working on the PR, &lt;a href="https://github.com/sympy/sympy/pull/17103"&gt;#17103&lt;/a&gt;, I came across the news that Tensorflow has changed a lot of APIs  while migrating from 1.x to 2.x. AFAIK, they are moving towards &lt;code class="highlighter-rouge"&gt;Function&lt;/code&gt; approach from the previous &lt;code class="highlighter-rouge"&gt;Session&lt;/code&gt; approach, and due to that, SymPy&amp;#8217;s &lt;code class="highlighter-rouge"&gt;lambdify&lt;/code&gt; faced some issues which I will be fixing soon with the help of other members. The Tensorflow details can be seen &lt;a href="https://github.com/tensorflow/community/blob/b1d83bf2ee3fc72650140b89656e29932db36226/rfcs/20180918-functions-not-sessions-20.md"&gt;here&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Now, let&amp;#8217;s move to the learning part. During the transition period I learnt about the dependencies of &lt;code class="highlighter-rouge"&gt;SymPy&lt;/code&gt;. Moreover, I came across, how, some bugs can be unnoticed when left untested. Thanks again to &lt;a href="https://github.com/oscarbenjamin"&gt;oscarbenjamin&lt;/a&gt; for letting me know about the bugs related to variance of finite random variables. I also got to know that, how bare &lt;code class="highlighter-rouge"&gt;except&lt;/code&gt; can even catch keyboard interrupt and that&amp;#8217;s what makes it quite vulnerable. Thanks to &lt;a href="https://github.com/sidhantnagpal"&gt;sidhantnagpal&lt;/a&gt; for helping me with this.&lt;/p&gt;

&lt;p&gt;So, that&amp;#8217;s all for this, see you next week. Bye!!&lt;/p&gt;</description>
    </item>
    <item>
      <guid isPermaLink="false">https://divyanshu132.github.io//gsoc-week-5</guid>
      <author>Divyanshu Thakur (divyanshu132)</author>
      <title>Divyanshu Thakur (divyanshu132): GSoC 2019 - Week 5 - Hand-made tests for Collector</title>
      <pubDate>Mon, 01 Jul 2019 00:00:00 GMT</pubDate>
      <link>https://divyanshu132.github.io//gsoc-week-5</link>
      <description>&lt;p&gt;This week was mostly about testing the collection of a word and fixing small bugs in the implementation pointed out by Kalevi. The major challenge was to construct the polycyclic presentation of a group to test the Collector since we don&amp;#8217;t have the implementation of polycyclic presentation and it&amp;#8217;s generating sequence yet. So, we decided to form some hand made tests and we started with SymmetricGroup(4) and further we also tried with S(3) the details can be found in the test file of the PR(&lt;a href="https://github.com/sympy/sympy/pull/16991"&gt;here&lt;/a&gt;).&lt;/p&gt;

&lt;p&gt;Now, the next step is to implement polycyclic presentation and polycyclic sequence. In the presentation we&amp;#8217;ll need generators which we can easily get and the relators. There are two types of relators needed for the presentation:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Power relations (ex. &lt;code class="highlighter-rouge"&gt;x^re = x'&lt;/code&gt;)&lt;/li&gt;
  &lt;li&gt;Conjugate relations (ex. &lt;code class="highlighter-rouge"&gt;x[i]**-1*x[i+1]*x[i] = RHS and x[i]*x[i+1]*x[i]**-1 = RHS&lt;/code&gt;)&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;For every pair of generators we&amp;#8217;ll form above conjugate relations but the tough part is computing that &lt;code class="highlighter-rouge"&gt;RHS&lt;/code&gt; which should be collected and for now we don&amp;#8217;t have that much idea about how to get that RHS.&lt;/p&gt;

&lt;p&gt;But, let&amp;#8217;s hope that in upcoming days we&amp;#8217;ll be able to figure it out, till then Good byeee&amp;#8230;&lt;/p&gt;</description>
    </item>
    <item>
      <guid isPermaLink="false">http://ishanaj.wordpress.com/?p=54</guid>
      <author>Ishan Joshi (ishanaj)</author>
      <title>Ishan Joshi (ishanaj): GSoC&#x2019;19: Week-5 &#x2013; Moving on with a Non-mutable Column class</title>
      <pubDate>Sun, 30 Jun 2019 18:52:29 GMT</pubDate>
      <link>https://ishanaj.wordpress.com/2019/07/01/gsoc19-week-5-moving-on-with-a-non-mutable-column-class/</link>
      <description>&lt;p&gt;A lot of things happened this week and I am happy to inform you that &lt;a href="https://github.com/sympy/sympy/pull/17055"&gt;PR #17055&lt;/a&gt; has been successfully merged. The beam module now supports the cross-sectional shape of the beam as an alternative parameter to the second moment. With this, the aim of the stage-I to integrate the geometry module with beam module has been accomplished.&lt;/p&gt;
&lt;p&gt;Although we need to add some examples in the docs, to make it easier for the user to understand how to use this new feature.&lt;/p&gt;
&lt;p&gt;Coming on to stage-II, I had already, initiated a &lt;a href="https://github.com/sympy/sympy/issues/17072"&gt;discussion&lt;/a&gt; to finalize the API of the new Column class that is to be implemented as a part of the continuum mechanics module in this stage.&lt;/p&gt;
&lt;p&gt;We concluded that it would be much better if the Column class remains non-mutable i.e. unlike the beam class where a beam is formed in a piecewise form, the new Column class would take all its required input data during the declaration and then one can call different methods to calculate different things.&lt;/p&gt;
&lt;p&gt;I have made a &lt;a href="https://github.com/sympy/sympy/pull/17122"&gt;work-in-progress PR #17122&lt;/a&gt; implementing the Column class which performs the required buckling calculations. Currently, I have not included a method to calculate the critical load as there was a bit of problem with the form of the equation which the &lt;strong&gt;dsolve() &lt;/strong&gt;returns after solving the differential equation of buckling. &lt;a href="https://docs.sympy.org/latest/modules/solvers/ode.html" rel="noopener" target="_blank"&gt;&lt;strong&gt;dsolve(&lt;/strong&gt;)&lt;/a&gt; is SymPy&amp;#8217;s differential equation solver.&lt;/p&gt;
&lt;p&gt;In general, if we solve the general equation of buckling manually, we might apply the &lt;strong&gt;method of undetermined coefficients&lt;/strong&gt;, which of course even &lt;strong&gt;dsolve() &lt;/strong&gt;&amp;#160;is capable to apply, but it gives the answer in an exponent form, while we need it in a trigonometric form (for ease of further calculations). So after seeking different methods trying to convert this equation in terms of &lt;strong&gt;sin(x)&lt;/strong&gt; and &lt;strong&gt;cos(x), &lt;/strong&gt;I finally had to put that problem in the discussion, where Oscar Benjamin, gave an idea to declare the variables as positive in order to get it in terms of &lt;strong&gt;sin &lt;/strong&gt;and&lt;strong&gt; cos.&amp;#160;&lt;/strong&gt;I tried that it works well for our case. I will have to figure out the further calculation of the critical load.&lt;/p&gt;
&lt;p&gt;Hopefully will be updating the code with a new method to calculate critical load, soon.&lt;/p&gt;
&lt;p&gt;Also, I have planned to have a method to solve the &lt;strong&gt;unknown reactions&lt;/strong&gt; and &lt;strong&gt;reaction moments&lt;/strong&gt;, which would use the &lt;strong&gt;boundary conditions&lt;/strong&gt; to get their values.&lt;/p&gt;
&lt;p&gt;With all these things going on, this week we also had our first evaluations, and I am very happy to say that I have passed it. &lt;strong&gt;Thanks to the mentors!&lt;/strong&gt;&lt;/p&gt;
&lt;h2&gt;&lt;strong&gt;&amp;#160;&lt;/strong&gt;&lt;strong&gt;Next Week:&lt;/strong&gt;&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;Completing Column class with all its methods&lt;/li&gt;
&lt;li&gt;Adding tests and documentation.&lt;/li&gt;
&lt;li&gt;Starting discussions for the next stage.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;I will try to finish working on the Column class this weekend.&lt;/p&gt;
&lt;p&gt;Will keep you updated!&lt;/p&gt;
&lt;p&gt;Thanks!&lt;/p&gt;
&lt;p&gt;&amp;nbsp;&lt;/p&gt;</description>
    </item>
    <item>
      <guid isPermaLink="false">https://arighnaiitg.github.io/2019-06-30-gsoc-week5/</guid>
      <author>Arighna Chakrabarty (arighnaiitg)</author>
      <title>Arighna Chakrabarty (arighnaiitg): GSoC Week 5 !!</title>
      <pubDate>Sun, 30 Jun 2019 07:00:00 GMT</pubDate>
      <link>https://arighnaiitg.github.io/2019-06-30-gsoc-week5/</link>
      <description>&lt;p&gt;Week 5 ends.. - 
          Phase 2 of the coding period has started. This week has gone in wrapping up the left-over work of FormalPowerSeries. I had a meeting with Sartaj on Tuesday 25th of June, about the work left to be done on FormalPowerSeries module. We agreed that some minor changes need to be...</description>
    </item>
    <item>
      <guid isPermaLink="false">https://www.kangzhiq.com/?p=24</guid>
      <author>Zhiqi KANG (kangzhiq)</author>
      <title>Zhiqi KANG (kangzhiq): [GSoC 2019] WEEK 4 and 5!</title>
      <pubDate>Sat, 29 Jun 2019 02:40:07 GMT</pubDate>
      <link>https://www.kangzhiq.com/2019/06/29/gsoc-2019-week-4-and-5/</link>
      <description>&lt;p&gt;Hello, the first phase is ended and I am happy to pass the first evaluation. I was struggling with my academic projects and final exams during the last two weeks. After talking about my difficulty of spending time contributing on my project with my mentors, Francesco allowed me to have a one-week break in condition that I should make up one week in the next phases. The goal is to have 40 hours work per week on average by the end of this program.&lt;/p&gt;



&lt;p&gt;Thanks to the comprehension of my mentor, I could successfully pass the exams. I am going to work more over the second phase in order to have more contributions to the community. &lt;img alt="&amp;#128578;" class="wp-smiley" src="https://s.w.org/images/core/emoji/12.0.0-1/72x72/1f642.png" style="height: 1em;" /&gt;&lt;/p&gt;</description>
    </item>
    <item>
      <guid isPermaLink="false">https://jmig5776.github.io//gsoc-week-5</guid>
      <author>Jogi Miglani (jmig5776)</author>
      <title>Jogi Miglani (jmig5776): GSoC 2019 - Week 5</title>
      <pubDate>Sat, 29 Jun 2019 00:00:00 GMT</pubDate>
      <link>https://jmig5776.github.io//gsoc-week-5</link>
      <description>&lt;p&gt;This was the fifth week meeting with the GSoC mentors which was scheduled on
Saturday 29th June, 2019 between 11:30 - 12:30 PM (IST). Me, Yathartha and Amit
were the attendees of the meeting. I passed my first evaluation, Amit gave his
feedback and told me some very important points to take notes on. I do personally
believe that his suggestions are the best a mentor could gave to his student after
practicing his suggestions in my real life.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Discussing previous week&amp;#8217;s progress&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;In this meeting both mentors suggested me to work upon the code improvements and
documentation improvement. And make it more readable to user. ALthough somehow
@smichr had some doubts on the logic that we were implementing. Although a lot
of progress has been there. So I decided to create and discussion for thinking
new logic for implementing Lambert all solutions and work on the current PR as
goes on.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;Next week goals&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Improving existing PR for Lambert&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Improving &lt;code class="highlighter-rouge"&gt;_solve_modular&lt;/code&gt; PR also&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;If time left then find plan for Imageset Union.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Code improvement takes time!!&lt;/p&gt;</description>
    </item>
    <item>
      <guid isPermaLink="false">https://sc0rpi0n101.github.io/2019/06/week-5-the-evaluation-is-here-end-of-phase-1/</guid>
      <author>Nikhil Maan (Sc0rpi0n101)</author>
      <title>Nikhil Maan (Sc0rpi0n101): Week 5: The Evaluation is here: End of Phase 1</title>
      <pubDate>Sat, 29 Jun 2019 00:00:00 GMT</pubDate>
      <link>https://sc0rpi0n101.github.io/2019/06/week-5-the-evaluation-is-here-end-of-phase-1/</link>
      <description>&lt;p&gt;&amp;ldquo;On two occasions I have been asked [by members of Parliament!]: &amp;lsquo;Pray, Mr. Babbage, if you put into the machine wrong figures, will the right answers come out ?&amp;rsquo; I am not able rightly to apprehend the kind of confusion of ideas that could provoke such a question.&amp;rdquo; &amp;#8212; Charles Babbage
 Welcome everyone, this is your host Nikhil Maan aka Sc0rpi0n101 and this week was the last week of Phase-1 and the evaluations for the first phase.</description>
    </item>
    <item>
      <guid isPermaLink="false">https://anpandey.github.io/posts/sympy/2019-06-28-week-5.html</guid>
      <author>Ankit Pandey (anpandey)</author>
      <title>Ankit Pandey (anpandey): Google Summer of Code Week 5: Unification and Tensors</title>
      <pubDate>Fri, 28 Jun 2019 00:00:00 GMT</pubDate>
      <link>https://anpandey.github.io/posts/sympy/2019-06-28-week-5.html</link>
      <description>&lt;p&gt;&lt;em&gt;See the &lt;a href="https://anpandey.github.io/2019-06-21-weeks-3-and-4.html"&gt;previous post&lt;/a&gt; for Weeks 3 and 4&lt;/em&gt;.&lt;/p&gt;
&lt;p&gt;This week I&amp;#8217;ve been mostly doing background reading. This post is mostly a summary of what I learned.&lt;/p&gt;
&lt;h2 id="unification"&gt;Unification&lt;/h2&gt;
&lt;p&gt;In short, unification is the process of finding substitutions of variables within two terms two terms to make them identical. For example, if we have the expressions &lt;span class="math inline"&gt;&lt;em&gt;x&lt;/em&gt;&amp;#8197;+&amp;#8197;2&lt;em&gt;y&lt;/em&gt;&lt;/span&gt; and &lt;span class="math inline"&gt;&lt;em&gt;a&lt;/em&gt;&amp;#8197;+&amp;#8197;3&lt;em&gt;b&lt;/em&gt;&lt;/span&gt;, the substitution &lt;span class="math inline"&gt;{&lt;em&gt;x&lt;/em&gt;&amp;#8196;&amp;#8614;&amp;#8196;&lt;em&gt;a&lt;/em&gt;,&amp;#8198;&lt;em&gt;y&lt;/em&gt;&amp;#8196;&amp;#8614;&amp;#8196;3,&amp;#8198;&lt;em&gt;b&lt;/em&gt;&amp;#8196;&amp;#8614;&amp;#8196;2}&lt;/span&gt; is a unifier, since applying the substitution to both expressions makes gives us the identical expression of &lt;span class="math inline"&gt;&lt;em&gt;a&lt;/em&gt;&amp;#8197;+&amp;#8197;3&amp;#8197;&amp;#8901;&amp;#8197;2&lt;/span&gt;. While this particular substitution includes variables from both expressions, we&amp;#8217;re mostly interested in rules involving substitutions of variables from just one expression (a case of unification known as matching). Several well-known algorithms for unification already exist.&lt;/p&gt;
&lt;h3 id="unification-in-sympy"&gt;Unification in SymPy&lt;/h3&gt;
&lt;p&gt;SymPy also has an implementation of a unification algorithm that is able to take the commutativity of operations into account. Suppose we wanted to unify the matrix expressions &lt;span class="math inline"&gt;&lt;em&gt;A&lt;/em&gt;&lt;sup&gt;&lt;em&gt;T&lt;/em&gt;&lt;/sup&gt;&lt;em&gt;B&lt;/em&gt;&lt;sup&gt;2&lt;/sup&gt;&lt;em&gt;C&lt;/em&gt;&lt;sup&gt;&amp;#8197;&amp;#8722;&amp;#8197;1&lt;/sup&gt;&lt;/span&gt; and &lt;span class="math inline"&gt;&lt;em&gt;X&lt;/em&gt;&lt;em&gt;Y&lt;/em&gt;&lt;sup&gt;&amp;#8197;&amp;#8722;&amp;#8197;1&lt;/sup&gt;&lt;/span&gt;. This is essentially the problem of finding a substitution that makes these two expressions equal. Using the &lt;code&gt;sympy.unify.usympy&lt;/code&gt; module, we can discover what this substitution is:&lt;/p&gt;
&lt;div class="sourceCode" id="cb1"&gt;&lt;pre class="sourceCode python"&gt;&lt;code class="sourceCode python"&gt;&lt;a class="sourceLine" id="cb1-1" title="1"&gt;&lt;span class="op"&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class="im"&gt;from&lt;/span&gt; sympy.unify.usympy &lt;span class="im"&gt;import&lt;/span&gt; &lt;span class="op"&gt;*&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb1-2" title="2"&gt;&lt;span class="op"&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class="im"&gt;from&lt;/span&gt; sympy.abc &lt;span class="im"&gt;import&lt;/span&gt; N&lt;/a&gt;
&lt;a class="sourceLine" id="cb1-3" title="3"&gt;&lt;span class="op"&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt; m &lt;span class="op"&gt;=&lt;/span&gt; &lt;span class="kw"&gt;lambda&lt;/span&gt; x: MatrixSymbol(x, N, N)&lt;/a&gt;
&lt;a class="sourceLine" id="cb1-4" title="4"&gt;&lt;span class="op"&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt; A, B, C, X, Y &lt;span class="op"&gt;=&lt;/span&gt; &lt;span class="bu"&gt;map&lt;/span&gt;(m, [&lt;span class="st"&gt;'A'&lt;/span&gt;, &lt;span class="st"&gt;'B'&lt;/span&gt;, &lt;span class="st"&gt;'X'&lt;/span&gt;, &lt;span class="st"&gt;'Y'&lt;/span&gt;])&lt;/a&gt;
&lt;a class="sourceLine" id="cb1-5" title="5"&gt;&lt;span class="op"&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt; e1 &lt;span class="op"&gt;=&lt;/span&gt; A.T &lt;span class="op"&gt;*&lt;/span&gt; B&lt;span class="op"&gt;**&lt;/span&gt;&lt;span class="dv"&gt;2&lt;/span&gt; &lt;span class="op"&gt;*&lt;/span&gt; C.I&lt;/a&gt;
&lt;a class="sourceLine" id="cb1-6" title="6"&gt;&lt;span class="op"&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt; e2 &lt;span class="op"&gt;=&lt;/span&gt; X &lt;span class="op"&gt;*&lt;/span&gt; Y &lt;span class="op"&gt;**&lt;/span&gt;(&lt;span class="op"&gt;-&lt;/span&gt;&lt;span class="dv"&gt;1&lt;/span&gt;)&lt;/a&gt;
&lt;a class="sourceLine" id="cb1-7" title="7"&gt;&lt;span class="op"&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class="bu"&gt;next&lt;/span&gt;(unify(e1, e2, variables&lt;span class="op"&gt;=&lt;/span&gt;[X, Y]))&lt;/a&gt;
&lt;a class="sourceLine" id="cb1-8" title="8"&gt;{X: A.T&lt;span class="op"&gt;*&lt;/span&gt;B&lt;span class="op"&gt;**&lt;/span&gt;&lt;span class="dv"&gt;2&lt;/span&gt;, Y: C}&lt;/a&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;We&amp;#8217;ve reduced this to a matching problem in which the variables are specified only in &lt;code&gt;e2&lt;/code&gt;. What&amp;#8217;s important to note here is that the matching rule within &lt;code&gt;e2&lt;/code&gt; we specified (&lt;span class="math inline"&gt;&lt;em&gt;X&lt;/em&gt;&lt;em&gt;Y&lt;/em&gt;&lt;sup&gt;&amp;#8197;&amp;#8722;&amp;#8197;1&lt;/sup&gt;&lt;/span&gt;) was a compound expression. This is something that is currently not possible for non-commutative expressions (such as matrix multiplication) using SymPy&amp;#8217;s &lt;code&gt;Wild&lt;/code&gt; interface. &lt;code&gt;unify&lt;/code&gt; allows use to express substitution rules that are able to match across sub-expressions in matrix multiplication.&lt;/p&gt;
&lt;p&gt;Through unification, we can express substitution rules for optimization as a simple term-rewriting rule. In my previous blog post, I mentioned rewriting the matrix multiplication &lt;span class="math inline"&gt;&lt;em&gt;A&lt;/em&gt;&lt;em&gt;x&lt;/em&gt;&lt;/span&gt; as a solving operation of &lt;code&gt;MatSolve(A, x)&lt;/code&gt; under certain assumptions. The actual implementation is restricted to cases where both the &lt;code&gt;A&lt;/code&gt; and the &lt;code&gt;x&lt;/code&gt; are matrix symbols, and the optimization can&amp;#8217;t identify cases where either the &lt;code&gt;A&lt;/code&gt; or the &lt;code&gt;x&lt;/code&gt; is a compound expression. With unification, we can identify the same pattern in more complex subexpressions. If we&amp;#8217;re given the matrix expression &lt;span class="math inline"&gt;&lt;em&gt;A&lt;/em&gt;&lt;sup&gt;&lt;em&gt;T&lt;/em&gt;&lt;/sup&gt;(&lt;em&gt;A&lt;/em&gt;&lt;em&gt;B&lt;/em&gt;)&lt;sup&gt;&amp;#8197;&amp;#8722;&amp;#8197;1&lt;/sup&gt;&lt;em&gt;x&lt;/em&gt;&lt;em&gt;y&lt;/em&gt;&lt;/span&gt;, a unification based transformer can produce &lt;code&gt;MatSolve(AB, x)&lt;/code&gt;, provided that the shapes of the matrices match the given rule.&lt;/p&gt;
&lt;h2 id="codegen-tensors"&gt;Codegen Tensors&lt;/h2&gt;
&lt;p&gt;I also looked into generating C and Fortran code from SymPy matrix expressions. For the purposes of code generation, SymPy has a relatively new &lt;code&gt;array_utils&lt;/code&gt; module. The AST nodes in this module express generalizations of operations on matrices, which require a bit of background in tensors.&lt;/p&gt;
&lt;p&gt;Many array operations (including matrix multiplication) involve &lt;em&gt;contraction&lt;/em&gt; along an axis. Contractions are a combination of multiplication and summation along certain axis of a tensor&lt;a class="footnote-ref" href="https://anpandey.github.io/atom-sympy.xml#fn1" id="fnref1"&gt;&lt;sup&gt;1&lt;/sup&gt;&lt;/a&gt;. In assigning the matrix multiplication &lt;span class="math inline"&gt;&lt;em&gt;A&lt;/em&gt;&lt;em&gt;B&lt;/em&gt;&lt;/span&gt; to the &lt;span class="math inline"&gt;&lt;em&gt;n&lt;/em&gt;&amp;#8197;&amp;#215;&amp;#8197;&lt;em&gt;n&lt;/em&gt;&lt;/span&gt; matrix &lt;span class="math inline"&gt;&lt;em&gt;C&lt;/em&gt;&lt;/span&gt;, we can explicitly write the summations (using subscripts for indexing matrix elements) as&lt;/p&gt;
&lt;p&gt;&lt;br /&gt;&lt;span class="math display"&gt;$$C_{ik} = \sum_{j = 1}^{n} A_{ij} B_{jk}$$&lt;/span&gt;&lt;br /&gt;&lt;/p&gt;
&lt;p&gt;The index &lt;span class="math inline"&gt;&lt;em&gt;j&lt;/em&gt;&lt;/span&gt; is contracted, as it is shared between both &lt;span class="math inline"&gt;&lt;em&gt;A&lt;/em&gt;&lt;/span&gt; and &lt;span class="math inline"&gt;&lt;em&gt;B&lt;/em&gt;&lt;/span&gt;, and describing this summation operation as a whole boils down to which indices are shared between the matrices. This is essentially what the &lt;code&gt;array_utils&lt;/code&gt; classes do. This is what happens when we use &lt;code&gt;array_utils&lt;/code&gt; to convert the matrix multiplication to an equivalent contraction operation:&lt;/p&gt;
&lt;div class="sourceCode" id="cb2"&gt;&lt;pre class="sourceCode python"&gt;&lt;code class="sourceCode python"&gt;&lt;a class="sourceLine" id="cb2-1" title="1"&gt;&lt;span class="op"&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class="im"&gt;from&lt;/span&gt; sympy.codegen.array_utils &lt;span class="im"&gt;import&lt;/span&gt; CodegenArrayContraction&lt;/a&gt;
&lt;a class="sourceLine" id="cb2-2" title="2"&gt;&lt;span class="op"&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class="im"&gt;from&lt;/span&gt; sympy.abc &lt;span class="im"&gt;import&lt;/span&gt; N&lt;/a&gt;
&lt;a class="sourceLine" id="cb2-3" title="3"&gt;&lt;span class="op"&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt; A &lt;span class="op"&gt;=&lt;/span&gt; MatrixSymbol(&lt;span class="st"&gt;'A'&lt;/span&gt;, N, N)&lt;/a&gt;
&lt;a class="sourceLine" id="cb2-4" title="4"&gt;&lt;span class="op"&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt; B &lt;span class="op"&gt;=&lt;/span&gt; MatrixSymbol(&lt;span class="st"&gt;'B'&lt;/span&gt;, N, N)&lt;/a&gt;
&lt;a class="sourceLine" id="cb2-5" title="5"&gt;&lt;span class="op"&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt; CodegenArrayContraction.from_MatMul(A &lt;span class="op"&gt;*&lt;/span&gt; B)&lt;/a&gt;
&lt;a class="sourceLine" id="cb2-6" title="6"&gt;CodegenArrayContraction(CodegenArrayTensorProduct(A, B), (&lt;span class="dv"&gt;1&lt;/span&gt;, &lt;span class="dv"&gt;2&lt;/span&gt;))&lt;/a&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;We&amp;#8217;re given a new&lt;code&gt;CodegenArrayContraction&lt;/code&gt; object that stores, along with the variables &lt;code&gt;A&lt;/code&gt; and &lt;code&gt;B&lt;/code&gt;, tuples of integers representing contractions along certain indices. Here, the &lt;code&gt;(1, 2)&lt;/code&gt; means that the variable at index 1 and index 2 (indices start at 0) are shared. We can confirm this by looking at the above summation, since both the second and third indices out of all indices that appear in the expression are &lt;span class="math inline"&gt;&lt;em&gt;j&lt;/em&gt;&lt;/span&gt;.&lt;/p&gt;
&lt;h2 id="next-steps"&gt;Next Steps&lt;/h2&gt;
&lt;p&gt;For next week, I&amp;#8217;ll try to re-implement the rewriting optimization in terms of &lt;code&gt;unify&lt;/code&gt;. This will both make it easier to express rules and extend to sub-expressions as well. I&amp;#8217;ll also start with implementing additional printers for the C and Fortran printers. The printer will probably just print naive &lt;code&gt;for&lt;/code&gt; loops to keep things simple (and it would probaly be better to use something like Theano for highly optimized code).&lt;/p&gt;
&lt;section class="footnotes"&gt;
&lt;hr /&gt;
&lt;ol&gt;
&lt;li id="fn1"&gt;&lt;p&gt;For our purposes, we can think of tensors as just &lt;span class="math inline"&gt;&lt;em&gt;n&lt;/em&gt;&lt;/span&gt;-dimensional arrays. Most of my reading on tensors was Justin C. Feng&amp;#8217;s &lt;a href="https://justincfeng.github.io/Tensors_Poor_Man.pdf"&gt;The Poor Man&amp;#8217;s Introduction to Tensors&lt;/a&gt;.&lt;a class="footnote-back" href="https://anpandey.github.io/atom-sympy.xml#fnref1"&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;/section&gt;</description>
    </item>
    <item>
      <guid isPermaLink="false">https://divyanshu132.github.io//gsoc-week-4</guid>
      <author>Divyanshu Thakur (divyanshu132)</author>
      <title>Divyanshu Thakur (divyanshu132): GSoC 2019 - Week 4 - Phase-I Completion</title>
      <pubDate>Mon, 24 Jun 2019 00:00:00 GMT</pubDate>
      <link>https://divyanshu132.github.io//gsoc-week-4</link>
      <description>&lt;p&gt;The fourth week of coding period has ended and now it&amp;#8217;s time for phase-I evaluations. Below, is a brief progress report of the project.&lt;/p&gt;

&lt;p&gt;The tasks that were proposed in the proposal for phase-I consists of:&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;Implementation of Abelian Invariants&lt;/li&gt;
  &lt;li&gt;Implementation of Composition Series&lt;/li&gt;
  &lt;li&gt;Computation with Polycyclic groups&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;Abelian Invariants&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;Implemented a function to compute the abelian invariants for a given permutation or free group. These are given as a list of prime-powers and describe the stucture of &lt;code class="highlighter-rouge"&gt;G/G'&lt;/code&gt; as a direct product of cyclic groups of prime power order.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;PR link &lt;a href="https://github.com/sympy/sympy/pull/16670"&gt;Added method to calculate Abelian Invariants&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;Composition Series&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;Implemented a function to compute the composition series. It provides a way to break up a group into simple pieces. Composition series of a group &lt;code class="highlighter-rouge"&gt;G&lt;/code&gt; is defined as the maximal subnormal series &lt;code class="highlighter-rouge"&gt;G = H_0 &amp;gt; H_1 &amp;gt; H_2 ... &amp;gt; H_k = 1&lt;/code&gt; where every factor group &lt;code class="highlighter-rouge"&gt;H(i+1)/H(i)&lt;/code&gt; is simple.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;PR link &lt;a href="https://github.com/sympy/sympy/pull/16881"&gt;Added method for Composition Series computation&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;Polycyclic Groups&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;The work on polycyclic group is in progress. For now, collection algorithm has been implemented which needs to be tested and a lot of discussions were made on the polycyclic generating sequence and its presentation and may be in a week we&amp;#8217;ll be ready with the stucture of polycyclic groups and collection of words.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;PR link &lt;a href="https://github.com/sympy/sympy/pull/16991"&gt;Added Polycyclic Group Class&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;Documentation&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;Some documentation is done to increase the sphinx coverage of SymPy.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;PR link &lt;a href="https://github.com/sympy/sympy/pull/16809"&gt;Increase Accessibility of docstrings from Sphinx&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;To follow the discussion on above topics and the further progress of the project one can check Gitter room &lt;a href="https://gitter.im/sympy/GroupTheory"&gt;sympy/GroupTheory&lt;/a&gt;&lt;/p&gt;</description>
    </item>
    <item>
      <guid isPermaLink="false">https://shubhamkjha.github.io/2019/06/24/GSoC-2019-Week-4</guid>
      <author>Shubham Kumar Jha (ShubhamKJha)</author>
      <title>Shubham Kumar Jha (ShubhamKJha): GSoC 2019: Week 4</title>
      <pubDate>Mon, 24 Jun 2019 00:00:00 GMT</pubDate>
      <link>https://shubhamkjha.github.io/2019/06/24/GSoC-2019-Week-4.html</link>
      <description>&lt;p&gt;With this the fourth week and the first phase of GSoC 2019 is over. Here I will give you a brief summary of my progress this week.&lt;/p&gt;

&lt;p&gt;I started this week by setting up my workspace for profiling the code related to new assumptions. I am using &lt;code class="highlighter-rouge"&gt;pyinstrument&lt;/code&gt; for that. The results of profiler suggests that a significant amount of time is spent in the &lt;code class="highlighter-rouge"&gt;to_cnf()&lt;/code&gt; function which converts the logical expression into their CNF counterparts, to be used by the SAT solver. Also, since this system is built over the SymPy core, a large amount of this time is spent in the core itself (See the graph &lt;a href="https://github.com/sympy/sympy/issues/17066#issuecomment-504774120"&gt;here&lt;/a&gt;). A possible solution to this is to use constructs at a level lower than the SymPy objects, hence removing the overheads.&lt;/p&gt;

&lt;p&gt;Also, as suggested in the last blog, there are various ideas proposed for improving the new assumptions mechanism. Some of them have been implemented to some extent in some PRs. Before proceeding for any new strategies, I need to look into these ideas first. I have started an &lt;a href="https://github.com/sympy/sympy/issues/17066"&gt;issue-tree&lt;/a&gt; to gather them.&lt;/p&gt;

&lt;p&gt;Over the end of the week, I also pushed my work on &lt;code class="highlighter-rouge"&gt;First Order Logic&lt;/code&gt; module at &lt;a href="https://github.com/sympy/sympy/pull/17069"&gt;#17069&lt;/a&gt;. This work is based on &lt;a href="https://github.com/sympy/sympy/pull/7608"&gt;#7608&lt;/a&gt; and extends it by adding &lt;code class="highlighter-rouge"&gt;Equality&lt;/code&gt; to it. Currently, there are test failures and some points to decide. I will try to get it done within this week.&lt;/p&gt;

&lt;p&gt;I spent most of this week exploring the profiling and benchmarking of code, and I learnt a lot during this. For the coming week, I will focus on speeding up the code in &lt;code class="highlighter-rouge"&gt;to_cnf&lt;/code&gt;. As suggested by Aaron, &lt;a href="https://github.com/sympy/sympy/pull/11789"&gt;this&lt;/a&gt; seems a good point to start with. Also, I will be working on the &lt;code class="highlighter-rouge"&gt;FOL&lt;/code&gt; module.&lt;/p&gt;</description>
    </item>
    <item>
      <guid isPermaLink="false">http://ishanaj.wordpress.com/?p=52</guid>
      <author>Ishan Joshi (ishanaj)</author>
      <title>Ishan Joshi (ishanaj): GSoC&#x2019;19: Week-4-Starting with Column Buckling implementation</title>
      <pubDate>Sun, 23 Jun 2019 18:41:36 GMT</pubDate>
      <link>https://ishanaj.wordpress.com/2019/06/24/gsoc19-week-4-starting-with-column-buckling-implementation/</link>
      <description>&lt;p&gt;Finalizing what had been discussed in &lt;a href="https://github.com/sympy/sympy/pull/16964"&gt;PR #16964&lt;/a&gt; for integrating geometry module with the beam module,&lt;a href="https://github.com/sympy/sympy/pull/17055"&gt; PR #17055&lt;/a&gt; was opened which is now ready to go!&lt;/p&gt;
&lt;p&gt;There is no special function for defining the cross-section of a Beam object. A user can simply pass the geometry object as a parameter instead of the &lt;strong&gt;second_moment, &lt;/strong&gt;and the corresponding second moment would be calculated internally. The example below might explain this better:&lt;/p&gt;
&lt;pre class="brush: python; collapse: false; title: ; wrap-lines: false; notranslate"&gt;

&amp;gt;&amp;gt;&amp;gt; b = Beam(l, E, Circle((0, 0), r))

&amp;gt;&amp;gt;&amp;gt; b.second_moment

pi*r*Abs(r)**3/4

&amp;gt;&amp;gt;&amp;gt; b.cross_section

Circle(Point2D(0, 0), r)

&lt;/pre&gt;
&lt;p&gt;Further, the &lt;strong&gt;cross_section&lt;/strong&gt; attribute can be changed even after the beam is created. Every time the &lt;strong&gt;cross_section&lt;/strong&gt; is assigned a new value, the &lt;strong&gt;second_moment&lt;/strong&gt; gets automatically updated.&lt;/p&gt;
&lt;p&gt;Similarly, every time the user changes the &lt;strong&gt;second_moment&lt;/strong&gt; explicitly after the creation of the beam, the previous &lt;strong&gt;cross_section&lt;/strong&gt; gets destroyed, or in other words, the &lt;strong&gt;cross_section&lt;/strong&gt; is set to None.&lt;/p&gt;
&lt;pre class="brush: python; collapse: false; title: ; wrap-lines: false; notranslate"&gt;

&amp;gt;&amp;gt;&amp;gt; b = Beam(l, E, Circle((0, 0), r))

&amp;gt;&amp;gt;&amp;gt; I&amp;#160; = Symbol(&amp;#8216;I&amp;#8217;)

&amp;gt;&amp;gt;&amp;gt; b.second_moment = I

&amp;gt;&amp;gt;&amp;gt; b.cross_section

None

&amp;gt;&amp;gt;&amp;gt; b.second_moment = Polygon((0, 0), (a, 0), (a, b), (0, b))

ValueError: To update cross-section geometry use `cross_section` attribute

&lt;/pre&gt;
&lt;p&gt;The PR is complete and just needs the final approval from the mentors.&lt;/p&gt;
&lt;p&gt;Simultaneously, I had worked on the column buckling calculations which is a part of the stage &amp;#8211;II.&lt;/p&gt;
&lt;p&gt;I have opened an &lt;a href="https://github.com/sympy/sympy/issues/17072"&gt;issue-cum-discussion&lt;/a&gt; for discussing its API and further implementations.&lt;/p&gt;
&lt;p&gt;Since the calculations of the Column Buckling are very much different from those of beam bending, we will have to make a separate class Column. The basic API and the way the calculations are supposed to go can be seen from the stage &amp;#8211;II in the &lt;a href="https://docs.google.com/document/d/1LOtMTr9cCrzQ8_OnKrgkZs8wFS9N9PxlR10h3aKG0jg/edit?usp=sharing"&gt;proposal&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;I would be making a PR for column buckling calculations within a day or two, once some initial questions (as mentioned in the issue-cum-discussion) gets clarified.&lt;/p&gt;
&lt;h2&gt;Next Week:&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;Finalizing the basic API and implementations of Column class&lt;/li&gt;
&lt;li&gt;Making a PR for the above implementations&lt;/li&gt;
&lt;li&gt;Documentation and testing&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Will keep you updated!&lt;/p&gt;
&lt;p&gt;Thanks!&lt;/p&gt;</description>
    </item>
    <item>
      <guid isPermaLink="false">https://arighnaiitg.github.io/2019-06-23-gsoc-week4/</guid>
      <author>Arighna Chakrabarty (arighnaiitg)</author>
      <title>Arighna Chakrabarty (arighnaiitg): GSoC Week 4 !!</title>
      <pubDate>Sun, 23 Jun 2019 07:00:00 GMT</pubDate>
      <link>https://arighnaiitg.github.io/2019-06-23-gsoc-week4/</link>
      <description>&lt;p&gt;Week 4 ends.. - 
          Week 4 and the final week of the first phase of the Coding Period is coming to an end. The work, which was initially proposed to be done in FormalPowerSeries has been done on a term-by-term level, i.e. the operations which have been implemented return truncated terms of the resultant...</description>
    </item>
    <item>
      <guid isPermaLink="false">https://czgdp1807.github.io/week_4</guid>
      <author>Gagandeep Singh (czgdp1807)</author>
      <title>Gagandeep Singh (czgdp1807): Week 4 - Phase 1 Ends</title>
      <pubDate>Sun, 23 Jun 2019 00:00:00 GMT</pubDate>
      <link>https://czgdp1807.github.io/week_4/</link>
      <description>&lt;p&gt;So, with the fourth week, the first phase of my journey with &lt;code class="highlighter-rouge"&gt;SymPy&lt;/code&gt; has come to an end. This blog post summarises the work done till now, in terms of PRs. Moreover, I will share with you the plans for phase 2.&lt;/p&gt;

&lt;p&gt;I worked on the following PRs(listed in chronological order) during the first phase, many of them got merged and few are open.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Merged&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href="https://github.com/sympy/sympy/pull/16528"&gt;#16528&lt;/a&gt; : I worked on extending the &lt;code class="highlighter-rouge"&gt;GumbelDistribution&lt;/code&gt; to  support both minimum and maximum versions of it.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href="https://github.com/sympy/sympy/pull/16576"&gt;#16576&lt;/a&gt;: This PR added &lt;code class="highlighter-rouge"&gt;Dirichlet&lt;/code&gt; and &lt;code class="highlighter-rouge"&gt;MultivariteEwens&lt;/code&gt; distributions.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href="https://github.com/sympy/sympy/pull/16808"&gt;#16808&lt;/a&gt; : This PR added &lt;code class="highlighter-rouge"&gt;Multinomial&lt;/code&gt; and &lt;code class="highlighter-rouge"&gt;NegativeMultinomial&lt;/code&gt; distribution.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href="https://github.com/sympy/sympy/pull/16810"&gt;#16810&lt;/a&gt; : This PR improved the API of &lt;code class="highlighter-rouge"&gt;Sum&lt;/code&gt; by allowing &lt;code class="highlighter-rouge"&gt;Range&lt;/code&gt; as the limits.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href="https://github.com/sympy/sympy/pull/16825"&gt;#16825&lt;/a&gt; : This PR in continuation, added &lt;code class="highlighter-rouge"&gt;GeneralizedMultivariateLogGamma&lt;/code&gt; distribution. This was an interesting one due to the complexity involved in its PDF.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href="https://github.com/sympy/sympy/pull/16834"&gt;#16834&lt;/a&gt; : This PR enhanced the &lt;code class="highlighter-rouge"&gt;Multinomial&lt;/code&gt; and &lt;code class="highlighter-rouge"&gt;NegativeMultinomial&lt;/code&gt; distributions by allowing symbolic dimensions for them.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href="https://github.com/sympy/sympy/pull/16897"&gt;#16897&lt;/a&gt; : This was related to &lt;code class="highlighter-rouge"&gt;sympy.core&lt;/code&gt; and it helped in removing disparity in the results of special function &lt;code class="highlighter-rouge"&gt;gamma&lt;/code&gt;.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href="https://github.com/sympy/sympy/pull/16899"&gt;#16899&lt;/a&gt; : This was a workflow related to PR to ignore the &lt;code class="highlighter-rouge"&gt;.vscode&lt;/code&gt; folder.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href="https://github.com/sympy/sympy/pull/16908"&gt;#16908&lt;/a&gt; : This PR improved &lt;code class="highlighter-rouge"&gt;sympy.stats.frv&lt;/code&gt; by allowing conditions with foriegn symbols.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href="https://github.com/sympy/sympy/pull/16913"&gt;#16913&lt;/a&gt; : This removed the unreachable code from &lt;code class="highlighter-rouge"&gt;sympy.stats.frv&lt;/code&gt;.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href="https://github.com/sympy/sympy/pull/16914"&gt;#16914&lt;/a&gt; : This PR allowed symbolic dimensions to &lt;code class="highlighter-rouge"&gt;MultivariateEwens&lt;/code&gt; distribution.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href="https://github.com/sympy/sympy/pull/16929"&gt;#16929&lt;/a&gt; : This one was for the &lt;code class="highlighter-rouge"&gt;sympy.tensor&lt;/code&gt; module. It optimized the &lt;code class="highlighter-rouge"&gt;ArrayComprehension&lt;/code&gt; and covered some corner cases.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href="https://github.com/sympy/sympy/pull/16981"&gt;#16981&lt;/a&gt; : This PR added the architecture of stochastic processes. It also added discrete Markov chain to &lt;code class="highlighter-rouge"&gt;sympy.stats&lt;/code&gt;.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href="https://github.com/sympy/sympy/pull/17003"&gt;#17003&lt;/a&gt; : This PR ignored the &lt;code class="highlighter-rouge"&gt;__pycahce__&lt;/code&gt; folder by adding it &lt;code class="highlighter-rouge"&gt;.gitignore&lt;/code&gt; file.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href="https://github.com/sympy/sympy/pull/17030"&gt;#17030&lt;/a&gt; : Some features like, &lt;code class="highlighter-rouge"&gt;joint_dsitribution&lt;/code&gt; were added in this PR.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href="https://github.com/sympy/sympy/pull/17046"&gt;#17046&lt;/a&gt; : Some common properties of discrete Markov chains, like fundamental matrix, fixed row vector were added.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;Open&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href="https://github.com/sympy/sympy/pull/16962"&gt;#16962&lt;/a&gt; : The aim of this PR is to allow symbolic dimensions to single finite distributions, like &lt;code class="highlighter-rouge"&gt;Die&lt;/code&gt;, &lt;code class="highlighter-rouge"&gt;Binomial&lt;/code&gt;. The work from my side is complete on this.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href="https://github.com/sympy/sympy/pull/16934"&gt;#16934&lt;/a&gt; : This PR aims to fix the bugs and test the code introduced in &lt;code class="highlighter-rouge"&gt;GSoC&lt;/code&gt; 2018.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Apart from the above PRs I also reviewed code written by other contributors.
Overall, according to me phase 1 was a great learning and working experience.&lt;/p&gt;

&lt;p&gt;Let me share with you my plan for phase 2. Since, I will be working on random matrices during the upcoming phase, I have started the discussions for design with my mentors and things are taking shape. However, apart from random matrices, I will also work on few more general improvements for my phase 1 work.&lt;/p&gt;

&lt;p&gt;The outline is given below,&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;I will work on extending the scope of queries handeled by discrete Markov chains by covering some uncommon cases.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Some work will be done to extend the &lt;code class="highlighter-rouge"&gt;DiscreteMarkovChain&lt;/code&gt; by adding &lt;code class="highlighter-rouge"&gt;ContinuousMarkovChain&lt;/code&gt; as the latter is almost same but with some extra parameters.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;I will implement random matrices and its various Gaussian ensembles according to the conclusion of the design discussions.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Last but not the least, I will try to merge my open PRs.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;Thanks for reading and see you soon in phase 2. Bye!!&lt;/p&gt;</description>
    </item>
    <item>
      <guid isPermaLink="false">https://ritesh99rakesh.github.io/Sympy_post6</guid>
      <author>Ritesh Kumar (ritesh99rakesh)</author>
      <title>Ritesh Kumar (ritesh99rakesh): Week 4</title>
      <pubDate>Sun, 23 Jun 2019 00:00:00 GMT</pubDate>
      <link>https://ritesh99rakesh.github.io/Sympy_post6/</link>
      <description>&lt;p&gt;Phase I has ended and here are the details of the PRs I have raised: #16935 #16843 #16848 #16858 #16886 #16888 #16970 #17004 #17033 #17036 #17068 #17070 #17076 #17077 Many of the above PRs are merged and some are open. I will work to get other merged. My plan for second phase: Complete the sampling method and finish the exporting of random variables to external libraries. I will work on Compound distributions and will finish it in the phase 2. I will add Wishart and Inverse Wishart distributions after multigamma function is merged. I will also discuss the implementation of Random Walks and will start working on the PR. This phase was a great learning experience. That&amp;#8217;s all from my side. Namaste!</description>
    </item>
    <item>
      <guid isPermaLink="false">https://jmig5776.github.io//gsoc-week-4</guid>
      <author>Jogi Miglani (jmig5776)</author>
      <title>Jogi Miglani (jmig5776): GSoC 2019 - Week 4</title>
      <pubDate>Sat, 22 Jun 2019 00:00:00 GMT</pubDate>
      <link>https://jmig5776.github.io//gsoc-week-4</link>
      <description>&lt;p&gt;This was the fourth week meeting with the GSoC mentors which was scheduled on
Sunday 22th June, 2019 between 12:30 - 01:30 PM (IST). Me and Yathartha
were the attendees of the meeting.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Discussing previous week&amp;#8217;s progress&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;In the previous week many things happened very suddenly. In the starting of the
week it was decided that we had to create a function &lt;code class="highlighter-rouge"&gt;power_list&lt;/code&gt; which could
return powers. So I thought to create this type of function as a new feature in
this PR &lt;a href="https://github.com/sympy/sympy/pull/17043"&gt;#17043&lt;/a&gt;.
But as @jksoum and @smichr advised that this function can act as
helper function in &lt;code class="highlighter-rouge"&gt;bivariate&lt;/code&gt; itself so it was decided to make it as helper
function there. And we discussed the code for handling modular equations also.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;Next week goals&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Implementing and get plan for defining imageset union&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;As per the timeline we decided that Imageset Union should be defined first rather
than code for handling nested trigonometric equation solver. So according to
timeline this week goes for discussion and getting plan for implementing imageset
union. A PR &lt;a href="https://github.com/sympy/sympy/pull/17079"&gt;#17079&lt;/a&gt; is also started
based on fundamental approach to solve the problem.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Getting merge Lambert Solver&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Most of the work had been done only a little improvement is to be done in &lt;code class="highlighter-rouge"&gt;power_list&lt;/code&gt;
function. Hope it gets merged by this week.&lt;/p&gt;

&lt;p&gt;Code improvement takes time!!&lt;/p&gt;</description>
    </item>
    <item>
      <guid isPermaLink="false">https://sc0rpi0n101.github.io/2019/06/week-4-the-fortran-parser-is-finally-here/</guid>
      <author>Nikhil Maan (Sc0rpi0n101)</author>
      <title>Nikhil Maan (Sc0rpi0n101): Week 4: The Fortran Parser is finally here</title>
      <pubDate>Sat, 22 Jun 2019 00:00:00 GMT</pubDate>
      <link>https://sc0rpi0n101.github.io/2019/06/week-4-the-fortran-parser-is-finally-here/</link>
      <description>&lt;p&gt;&amp;ldquo;When someone says: &amp;lsquo;I want a programming language in which I need only say what I wish done&amp;rsquo;, give him a lollipop.&amp;rdquo;  &amp;#8212; Alan J. Perlis in Software Metrics
 Welcome everyone, this is your host Nikhil Maan aka Sc0rpi0n101 and this week has been relatively a little odd. The week started a little slow but slowly it turned out to be a good and productive week.</description>
    </item>
  </channel>
</rss>
